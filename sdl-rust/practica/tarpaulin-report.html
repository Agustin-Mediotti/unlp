<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","lib.rs"],"content":"#![allow(dead_code)]\n\nmod tp1;\nmod tp2;\nmod tp3;\nmod tp4;\nmod tp5;\n\n// Gerenar Reporte de Coverage:\n// $ cargo tarpaulin --out Lcov \u0026\u0026 genhtml lcov.info -o coverage-report\n// $ cargo tarpaulin --target-dir src/coverage --skip-clean --out html\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej1.rs"],"content":"use std::io;\n\nfn main() -\u003e io::Result\u003c()\u003e {\n    let mut buf = String::new();\n    let pi: f32 = 3.14;\n\n    println!(\"enter a number: \");\n\n    io::stdin()\n        .read_line(\u0026mut buf)\n        .expect(\"failed to read line!\");\n    let num: u32 = buf.trim().parse().expect(\"not an integer!\");\n\n    println!(\"{num} * {pi} = {}\", num as f32 * pi);\n    println!(\"{num} / {pi} = {}\", num as f32 / pi);\n    println!(\"{num} + {pi} = {}\", num as f32 + pi);\n    println!(\"{num} - {pi} = {}\", num as f32 - pi);\n\n    Ok(())\n}\n","traces":[{"line":3,"address":[746362,744960],"length":1,"stats":{"Line":0}},{"line":4,"address":[744972],"length":1,"stats":{"Line":0}},{"line":5,"address":[744977],"length":1,"stats":{"Line":0}},{"line":7,"address":[744985,745049],"length":1,"stats":{"Line":0}},{"line":9,"address":[745065],"length":1,"stats":{"Line":0}},{"line":12,"address":[745169],"length":1,"stats":{"Line":0}},{"line":14,"address":[745329],"length":1,"stats":{"Line":0}},{"line":15,"address":[745579],"length":1,"stats":{"Line":0}},{"line":16,"address":[745829],"length":1,"stats":{"Line":0}},{"line":17,"address":[746079],"length":1,"stats":{"Line":0}},{"line":19,"address":[746329],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej10.rs"],"content":"fn main() {\n    let arr_01: Vec\u003cu32\u003e = vec![2, 4, 8, 16, 32];\n    let arr_02: Vec\u003cu32\u003e = vec![64, 128, 256, 512, 1024];\n    let arr_03: Vec\u003cu32\u003e = arr_01\n        .iter()\n        .zip(arr_02.iter())\n        .map(|(a, b)| a + b)\n        .collect();\n    println!(\"{:?}\", arr_03);\n}\n","traces":[{"line":1,"address":[729568,730379],"length":1,"stats":{"Line":0}},{"line":2,"address":[729575,729729],"length":1,"stats":{"Line":0}},{"line":3,"address":[729717,729791],"length":1,"stats":{"Line":0}},{"line":4,"address":[730004,729924,730133],"length":1,"stats":{"Line":0}},{"line":6,"address":[730045],"length":1,"stats":{"Line":0}},{"line":7,"address":[1002907,1002864],"length":1,"stats":{"Line":0}},{"line":9,"address":[730202,730253],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej11.rs"],"content":"use std::io;\n\nfn main() {\n    let text_vec = vec![\n        \"Hello World\",\n        \"UNLP Informatica\",\n        \"Seminario 2025\",\n        \"Rust is awesome\",\n        \"Lateralus\",\n    ];\n    let mut input = String::new();\n    io::stdin().read_line(\u0026mut input).expect(\"failed to read\");\n\n    if text_vec.contains(\u0026input.trim()) {\n        println!(\"I know that one\");\n    } else {\n        println!(\"A new spell?\");\n    }\n}\n","traces":[{"line":3,"address":[948771,948064],"length":1,"stats":{"Line":0}},{"line":4,"address":[948071,948281],"length":1,"stats":{"Line":0}},{"line":11,"address":[948274],"length":1,"stats":{"Line":0}},{"line":12,"address":[948396,948334],"length":1,"stats":{"Line":0}},{"line":14,"address":[948482],"length":1,"stats":{"Line":0}},{"line":15,"address":[948666,948732],"length":1,"stats":{"Line":0}},{"line":17,"address":[948692,948640],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej12.rs"],"content":"fn main() {\n    let t: (\u0026str, Vec\u003cu16\u003e) = (\"Powers of Two\", vec![2, 4, 8, 16, 32, 64, 128]);\n    println!(\"{}, {}\", t.0, t.1.iter().sum::\u003cu16\u003e());\n}\n","traces":[{"line":1,"address":[1136560,1137031],"length":1,"stats":{"Line":0}},{"line":2,"address":[1136774,1136567],"length":1,"stats":{"Line":0}},{"line":3,"address":[1136827,1136750],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej2.rs"],"content":"fn main() {\n    let int: u8 = 127;\n    println!(\"{int} =\u003e {}\", format!(\"{:X}\", int));\n}\n","traces":[{"line":1,"address":[573402,573056],"length":1,"stats":{"Line":0}},{"line":2,"address":[573063],"length":1,"stats":{"Line":0}},{"line":3,"address":[573086],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej3.rs"],"content":"use std::io;\n\nfn main() {\n    let boolean: bool = false;\n    let mut input = String::new();\n\n    println!(\"enter true or false: \");\n    io::stdin()\n        .read_line(\u0026mut input)\n        .expect(\"failed to read line!\");\n\n    match input.trim() {\n        \"true\" | \"t\" =\u003e {\n            println!(\"{boolean} \u0026 true = {}\", boolean \u0026 true);\n            println!(\"{boolean} | true = {}\", boolean | true);\n        }\n        \"false\" | \"f\" =\u003e {\n            println!(\"{boolean} \u0026 false = {}\", boolean \u0026 false);\n            println!(\"{boolean} | false = {}\", boolean | false);\n        }\n        _ =\u003e println!(\"{} is not a boolean\", input.trim()),\n    }\n}\n","traces":[{"line":3,"address":[845830,844448],"length":1,"stats":{"Line":0}},{"line":4,"address":[844455],"length":1,"stats":{"Line":0}},{"line":5,"address":[844468],"length":1,"stats":{"Line":0}},{"line":7,"address":[844473,844543],"length":1,"stats":{"Line":0}},{"line":8,"address":[844562],"length":1,"stats":{"Line":0}},{"line":12,"address":[844672],"length":1,"stats":{"Line":0}},{"line":13,"address":[844884,844742],"length":1,"stats":{"Line":0}},{"line":14,"address":[845537,844808],"length":1,"stats":{"Line":0}},{"line":15,"address":[845649],"length":1,"stats":{"Line":0}},{"line":17,"address":[844900,845037],"length":1,"stats":{"Line":0}},{"line":18,"address":[845239,844966],"length":1,"stats":{"Line":0}},{"line":19,"address":[845351],"length":1,"stats":{"Line":0}},{"line":21,"address":[845051],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej4.rs"],"content":"fn main() {\n    let t: (String, i32, bool) = (\"Rust 2025\".to_string(), -15, false);\n\n    println!(\"{}, {}, {}\", t.0, t.1, t.2);\n}\n","traces":[{"line":1,"address":[760096,760363],"length":1,"stats":{"Line":0}},{"line":2,"address":[760103],"length":1,"stats":{"Line":0}},{"line":4,"address":[760168,760210],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej5.rs"],"content":"use std::io;\n\nfn main() {\n    let text = String::from(\"I'm not screaming, \");\n    let mut input = String::new();\n\n    io::stdin().read_line(\u0026mut input).expect(\"bad input\");\n\n    println!(\"{}\", (text + \u0026input).to_uppercase());\n}\n","traces":[{"line":3,"address":[744208,744892,744923],"length":1,"stats":{"Line":0}},{"line":4,"address":[744215],"length":1,"stats":{"Line":0}},{"line":5,"address":[744266],"length":1,"stats":{"Line":0}},{"line":7,"address":[744373,744314],"length":1,"stats":{"Line":0}},{"line":9,"address":[744901,744445],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej6.rs"],"content":"use std::io;\n\nfn main() {\n    let a: u32 = 30;\n    let mut input = String::new();\n\n    io::stdin()\n        .read_line(\u0026mut input)\n        .expect(\"error reading input\");\n    let input: u32 = input.trim().parse().unwrap();\n\n    println!(\"({a} + {input})^2 = {}\", (a + input) * 2);\n}\n","traces":[{"line":3,"address":[808848,809497],"length":1,"stats":{"Line":0}},{"line":4,"address":[808855],"length":1,"stats":{"Line":0}},{"line":5,"address":[808868],"length":1,"stats":{"Line":0}},{"line":7,"address":[808935,808873],"length":1,"stats":{"Line":0}},{"line":10,"address":[809012],"length":1,"stats":{"Line":0}},{"line":12,"address":[809160],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej7.rs"],"content":"fn main() {\n    const PI: f32 = 6.28;\n\n    let arr = [2, 4, 8, 16, 32, 64]\n        .iter()\n        .map(|x| (*x as f32 * PI) as u32)\n        .collect::\u003cVec\u003cu32\u003e\u003e();\n\n    println!(\"{:?}\", arr);\n}\n","traces":[{"line":1,"address":[784576,784400],"length":1,"stats":{"Line":0}},{"line":4,"address":[784407],"length":1,"stats":{"Line":0}},{"line":6,"address":[575328,575338],"length":1,"stats":{"Line":0}},{"line":9,"address":[784461,784503],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej8.rs"],"content":"use std::io;\n\nfn main() {\n    const TEXT: \u0026str = \"Seminario de Lenguajes 2025: Rust\";\n\n    let mut input = String::new();\n    io::stdin().read_line(\u0026mut input).expect(\"failed to read\");\n    let input: char = input.chars().collect::\u003cVec\u003c_\u003e\u003e()[0];\n\n    let t = TEXT.chars().filter(|c| *c == input).count();\n\n    println!(\"{t}\");\n}\n","traces":[{"line":3,"address":[1148880,1149415],"length":1,"stats":{"Line":0}},{"line":6,"address":[1148892],"length":1,"stats":{"Line":0}},{"line":7,"address":[1148897,1148959],"length":1,"stats":{"Line":0}},{"line":8,"address":[1149036],"length":1,"stats":{"Line":0}},{"line":10,"address":[981610,981600],"length":1,"stats":{"Line":0}},{"line":12,"address":[1149300],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej9.rs"],"content":"fn main() {\n    let arr: Vec\u003cu8\u003e = vec![2, 4, 8, 16, 32];\n    println!(\"{}\", arr.iter().sum::\u003cu8\u003e());\n}\n","traces":[{"line":1,"address":[1093399,1093056],"length":1,"stats":{"Line":0}},{"line":2,"address":[1093063,1093170],"length":1,"stats":{"Line":0}},{"line":3,"address":[1093237,1093149],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","mod.rs"],"content":"pub mod ej1;\npub mod ej10;\npub mod ej11;\npub mod ej12;\npub mod ej2;\npub mod ej3;\npub mod ej4;\npub mod ej5;\npub mod ej6;\npub mod ej7;\npub mod ej8;\npub mod ej9;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej1.rs"],"content":"pub fn es_par(num: u64) -\u003e bool {\n    num % 2 == 0\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn numeros_pares_son_identificados_correctamente() {\n        assert!(es_par(4), \"4 debería ser par\");\n        assert!(es_par(0), \"0 debería ser par\");\n        assert!(!es_par(15), \"15 no debería ser par\");\n        assert!(!es_par(7), \"7 no debería ser par\");\n        assert!(!es_par(u64::MAX), \"u64::MAX no debería ser par\");\n    }\n}\n","traces":[{"line":1,"address":[592768],"length":1,"stats":{"Line":1}},{"line":2,"address":[592773],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej10.rs"],"content":"pub fn cantidad_de_cadenas_mayor_a(list: \u0026[\u0026str], limite: u32) -\u003e u32 {\n    list.iter()\n        .filter(|f| f.chars().count() as u32 \u003e limite)\n        .count() as u32\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn cuenta_cadenas_con_mas_caracteres_que_el_limite() {\n        let lista = [\n            \"String Corto\",\n            \"Cadena de string medianamente larga\",\n            \"Cadena de string relativamente mas largo\",\n            \"Una cadena de string considerablemente mas larga que las anteriores\",\n        ];\n        let limite = 12;\n        assert_eq!(\n            cantidad_de_cadenas_mayor_a(\u0026lista, limite),\n            3,\n            \"Debería haber 3 cadenas con más de {limite} caracteres\"\n        );\n        assert_eq!(\n            cantidad_de_cadenas_mayor_a(\u0026[], 5),\n            0,\n            \"No hay elementos en la lista, el resultado debería ser 0\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[997232],"length":1,"stats":{"Line":1}},{"line":2,"address":[997250],"length":1,"stats":{"Line":1}},{"line":3,"address":[962816,962834],"length":1,"stats":{"Line":2}}],"covered":3,"coverable":3},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej11.rs"],"content":"pub fn multiplicar_valores(lista: \u0026mut [i32], factor: i32) {\n    lista.iter_mut().for_each(|x| *x *= factor);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn multiplica_los_elementos_por_un_factor() {\n        let mut lista = [35, 23, 45, 18];\n        let factor = 2;\n        multiplicar_valores(\u0026mut lista, factor);\n        assert_eq!(\n            lista,\n            [70, 46, 90, 36],\n            \"Los elementos no fueron multiplicados correctamente por el factor\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[719776],"length":1,"stats":{"Line":1}},{"line":2,"address":[661795,661776],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej12.rs"],"content":"pub fn reemplazar_pares(lista: \u0026mut [i32]) {\n    lista\n        .iter_mut()\n        .filter(|e| **e % 2 == 0)\n        .for_each(|e| *e = -1);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn reemplaza_pares_con_menos_uno() {\n        let mut lista = [2, 5, 8, 11, 12, 16];\n        reemplazar_pares(\u0026mut lista);\n        assert_eq!(\n            lista,\n            [-1, 5, -1, 11, -1, -1],\n            \"Los números pares no fueron reemplazados correctamente\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[710272],"length":1,"stats":{"Line":1}},{"line":2,"address":[710286],"length":1,"stats":{"Line":1}},{"line":4,"address":[837168,837182],"length":1,"stats":{"Line":2}},{"line":5,"address":[837258,837248],"length":1,"stats":{"Line":2}}],"covered":4,"coverable":4},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej13.rs"],"content":"pub fn ordenar_nombres(list: \u0026mut [\u0026str]) {\n    list.sort();\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ordena_nombres_alfabeticamente() {\n        let mut lista = [\"ale\", \"Kim\", \"92\", \"Guillermo\", \"Juan Manuel\", \"\", \"Z\"];\n        ordenar_nombres(\u0026mut lista);\n        assert_eq!(\n            lista,\n            [\"\", \"92\", \"Guillermo\", \"Juan Manuel\", \"Kim\", \"Z\", \"ale\"],\n            \"Los nombres no fueron ordenados alfabéticamente como se esperaba\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[664144],"length":1,"stats":{"Line":1}},{"line":2,"address":[664158],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej14.rs"],"content":"pub fn incrementar(num: \u0026mut f32) {\n    *num += 1.0;\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn incrementa_variable_de_punto_flotante() {\n        let mut num: f32 = 2.0;\n        incrementar(\u0026mut num);\n        assert_eq!(\n            num, 3.0,\n            \"La variable {num} debería haber sido incrementada a 3.0\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[719824],"length":1,"stats":{"Line":1}},{"line":2,"address":[719829],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej2.rs"],"content":"pub fn es_primo(num: u64) -\u003e bool {\n    match num {\n        0 | 1 =\u003e false,\n        2 | 3 =\u003e true,\n        _ =\u003e !(2..=((num as f64).sqrt() as u64)).any(|i| num % i == 0),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn retorna_true_para_numeros_primos() {\n        let primos = [2, 3, 5, 7, 11, 13, 17, 19];\n        assert!(\n            primos.iter().all(|\u0026n| es_primo(n)),\n            \"Todos los números en la lista deberían ser primos\"\n        );\n        let no_primos = [0, 1, 4, 6, 8, 9, 10, 12, 15];\n        assert!(\n            no_primos.iter().all(|\u0026n| !es_primo(n)),\n            \"Ninguno de los números en la lista debería ser primo\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[1148640],"length":1,"stats":{"Line":1}},{"line":2,"address":[1148649],"length":1,"stats":{"Line":1}},{"line":3,"address":[1148854],"length":1,"stats":{"Line":1}},{"line":4,"address":[1148861],"length":1,"stats":{"Line":1}},{"line":5,"address":[997155,997136],"length":1,"stats":{"Line":3}}],"covered":5,"coverable":5},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej3.rs"],"content":"pub fn suma_pares(list: \u0026[i32]) -\u003e i32 {\n    list.iter().filter(|\u0026\u0026n| n % 2 == 0).sum()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn calcula_correctamente_la_suma_de_pares() {\n        let enteros_pares = [2, 4, 8, 16];\n        let enteros_impares = [1, 3, 5, 11];\n        assert_eq!(\n            suma_pares(\u0026enteros_pares),\n            30,\n            \"La suma de los pares [2, 4, 8, 16] debería ser 30\"\n        );\n        assert_eq!(\n            suma_pares(\u0026enteros_impares),\n            0,\n            \"No hay pares, el resultado debería ser 0\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[762736],"length":1,"stats":{"Line":1}},{"line":2,"address":[762750],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej4.rs"],"content":"pub fn cantidad_impares(list: \u0026[i32]) -\u003e i32 {\n    list.iter().filter(|\u0026\u0026e| e % 2 != 0).count() as i32\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn cuenta_la_cantidad_de_impares_correctamente() {\n        let enteros = [1, 2, 3, 5, 8, 11];\n        let sin_impares = [0, 2, 4, 8, 12, 18];\n        assert_eq!(\n            cantidad_impares(\u0026enteros),\n            4,\n            \"Debería haber 4 impares en la lista [1, 2, 3, 5, 8, 11]\"\n        );\n        assert_eq!(\n            cantidad_impares(\u0026sin_impares),\n            0,\n            \"No hay impares en la lista, el resultado debería ser 0\"\n        );\n        assert_eq!(\n            cantidad_impares(\u0026[]),\n            0,\n            \"No hay elementos en la lista, el resultado debería ser 0\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[719392],"length":1,"stats":{"Line":1}},{"line":2,"address":[719406],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej5.rs"],"content":"pub fn duplicar_valores(lista: \u0026[f32]) -\u003e Vec\u003cf32\u003e {\n    lista.iter().map(|\u0026e| e * 2.0).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn duplica_los_valores_correctamente() {\n        let lista = [1.0, 2.2, 4.8, 5.0, 0.0];\n        assert_eq!(\n            duplicar_valores(\u0026lista),\n            [2.0, 4.4, 9.6, 10.0, 0.0],\n            \"Los valores duplicados no coinciden con lo esperado\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[981632],"length":1,"stats":{"Line":1}},{"line":2,"address":[612880,612890],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej6.rs"],"content":"pub fn longitud_de_cadenas(lista: \u0026[\u0026str]) -\u003e Vec\u003cu32\u003e {\n    lista.iter().map(|e| e.chars().count() as u32).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn calcula_la_longitud_de_cada_string() {\n        let lista = [\n            \"Hola\",\n            \"UNLP\",\n            \"Informatica\",\n            \"A Don Cangrejo le gusta Rust\",\n        ];\n        assert_eq!(\n            longitud_de_cadenas(\u0026lista),\n            [4, 4, 11, 28],\n            \"Las longitudes de las cadenas no coinciden con lo esperado\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[1072448],"length":1,"stats":{"Line":1}},{"line":2,"address":[1072498],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej7.rs"],"content":"pub fn cantidad_de_mayores(lista: \u0026[u32], limite: \u0026u32) -\u003e u32 {\n    lista.iter().filter(|e| e \u003e \u0026limite).count() as u32\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn cuenta_cuantos_elementos_superan_el_limite() {\n        let lista = [2, 4, 8, 16, 32, 64];\n        let limite = 8;\n        assert_eq!(\n            cantidad_de_mayores(\u0026lista, \u0026limite),\n            3,\n            \"Debería haber 3 elementos mayores que {limite}\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[998032],"length":1,"stats":{"Line":1}},{"line":2,"address":[593072,593085],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej8.rs"],"content":"pub fn sumar_arreglos(left: \u0026[f32], right: \u0026[f32]) -\u003e Vec\u003cf32\u003e {\n    left.iter().zip(right.iter()).map(|(x, y)| x + y).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn suma_elemento_a_elemento_dos_arreglos() {\n        let a = [2.0, 4.2, 8.4, 1.1];\n        let b = [2.0, 4.2, 8.4, 1.1];\n        assert_eq!(\n            sumar_arreglos(\u0026a, \u0026b),\n            [4.0, 8.4, 16.8, 2.2],\n            \"La suma de los arreglos no coincide con lo esperado\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[958624],"length":1,"stats":{"Line":1}},{"line":2,"address":[864912,864955],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej9.rs"],"content":"pub fn cantidad_en_rango(lista: \u0026[i32], inferior: \u0026i32, superior: \u0026i32) -\u003e u32 {\n    lista\n        .iter()\n        .filter(|x| x \u003e= \u0026inferior \u0026\u0026 x \u003c= \u0026superior)\n        .count() as u32\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn cuenta_elementos_en_rango_inclusivo() {\n        let lista = [2, 4, 8, 16, 32, 64, 128];\n        let inferior = 16;\n        let superior = 64;\n        assert_eq!(\n            cantidad_en_rango(\u0026lista, \u0026inferior, \u0026superior),\n            3,\n            \"Debería haber 3 elementos dentro del rango {inferior}..{superior}\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[636384],"length":1,"stats":{"Line":1}},{"line":2,"address":[636408],"length":1,"stats":{"Line":1}},{"line":4,"address":[997043,997024],"length":1,"stats":{"Line":2}}],"covered":3,"coverable":3},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","mod.rs"],"content":"pub mod ej1;\npub mod ej10;\npub mod ej11;\npub mod ej12;\npub mod ej13;\npub mod ej14;\npub mod ej2;\npub mod ej3;\npub mod ej4;\npub mod ej5;\npub mod ej6;\npub mod ej7;\npub mod ej8;\npub mod ej9;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej1.rs"],"content":"pub struct Persona {\n    pub nombre: String,\n    pub edad: u8,\n    pub dir: Option\u003cString\u003e,\n}\n\nimpl Persona {\n    pub fn new(nombre: String, edad: u8, dir: Option\u003cString\u003e) -\u003e Persona {\n        Persona { nombre, edad, dir }\n    }\n\n    pub fn to_string(\u0026self) -\u003e String {\n        let direccion = match \u0026self.dir {\n            Some(dir) =\u003e dir.clone(),\n            None =\u003e \"Sin dirección\".to_string(),\n        };\n\n        format!(\"{}, {}, {}\", self.nombre, self.edad, direccion)\n    }\n\n    pub fn obtener_edad(\u0026self) -\u003e u8 {\n        self.edad\n    }\n\n    pub fn actualizar_direccion(\u0026mut self, nue_dir: String) {\n        self.dir = Some(nue_dir);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_nueva_persona_sin_direccion() {\n        let persona = Persona::new(\"Fausto\".to_string(), 11, None);\n        assert_eq!(persona.nombre, \"Fausto\");\n        assert_eq!(persona.edad, 11);\n        assert_eq!(persona.dir, None);\n    }\n\n    #[test]\n    fn crea_nueva_persona_con_direccion() {\n        let persona = Persona::new(\n            \"Fausto\".to_string(),\n            11,\n            Some(\"Calle Falsa 123\".to_string()),\n        );\n        assert_eq!(persona.nombre, \"Fausto\");\n        assert_eq!(persona.edad, 11);\n        assert_eq!(persona.dir, Some(\"Calle Falsa 123\".to_string()));\n    }\n\n    #[test]\n    fn persona_to_string_con_direccion() {\n        let persona_to_string = Persona::new(\n            \"Fausto\".to_string(),\n            11,\n            Some(\"Calle Falsa 123\".to_string()),\n        )\n        .to_string();\n\n        assert_eq!(persona_to_string, \"Fausto, 11, Calle Falsa 123\")\n    }\n\n    #[test]\n    fn obtener_edad_de_persona() {\n        let persona = Persona::new(\n            \"Fausto\".to_string(),\n            11,\n            Some(\"Calle Falsa 123\".to_string()),\n        );\n\n        assert_eq!(persona.obtener_edad(), 11);\n    }\n\n    #[test]\n    fn actualizar_direccion_de_persona() {\n        let mut persona = Persona::new(\"Fausto\".to_string(), 11, None);\n        persona.actualizar_direccion(\"Fausto, 11, Calle Falsa 123\".to_string());\n\n        assert_eq!(persona.dir, Some(\"Fausto, 11, Calle Falsa 123\".to_string()));\n    }\n}\n","traces":[{"line":8,"address":[686976],"length":1,"stats":{"Line":1}},{"line":12,"address":[687404,687040],"length":1,"stats":{"Line":1}},{"line":13,"address":[687069],"length":1,"stats":{"Line":1}},{"line":14,"address":[687141],"length":1,"stats":{"Line":1}},{"line":15,"address":[687112],"length":1,"stats":{"Line":0}},{"line":18,"address":[687172,687224],"length":1,"stats":{"Line":2}},{"line":21,"address":[687440],"length":1,"stats":{"Line":1}},{"line":22,"address":[687445],"length":1,"stats":{"Line":1}},{"line":25,"address":[687456,687525],"length":1,"stats":{"Line":1}},{"line":26,"address":[687470,687556],"length":1,"stats":{"Line":2}}],"covered":9,"coverable":10},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej10.rs"],"content":"use super::ej3::Fecha;\nuse std::collections::HashMap;\n\n#[derive(PartialEq, Clone, Debug)]\npub enum EstadoPrestamo {\n    Devuelto,\n    Prestamo,\n}\n\n#[derive(PartialEq, Eq, Hash, Clone)]\npub enum GeneroLibro {\n    Novela,\n    Infantil,\n    Tecnico,\n    Otros,\n}\n\npub struct Biblioteca {\n    pub mombre: String,\n    pub direccion: String,\n    pub prestamos_efectuados: Vec\u003cPrestamo\u003e,\n    pub libros_a_disposicion: HashMap\u003cLibro, u8\u003e,\n}\n\n#[derive(PartialEq, Eq, Hash, Clone)]\npub struct Libro {\n    pub isbn: u32,\n    pub titulo: String,\n    pub autor: String,\n    pub numero_de_paginas: u32,\n    pub genero: GeneroLibro,\n}\n\n#[derive(PartialEq, Clone)]\npub struct Cliente {\n    pub nombre: String,\n    pub telefono: u32,\n    pub email: String,\n}\n\n#[derive(Clone)]\npub struct Prestamo {\n    pub libro: Libro,\n    pub fecha_vencimiento: Fecha,\n    pub fecha_devolucion: Fecha,\n    pub cliente: Cliente,\n    pub estado: EstadoPrestamo,\n}\n\nimpl Biblioteca {\n    pub fn obtener_cantidad_de_copias(\u0026self, libro: Libro) -\u003e u8 {\n        if let Some(copias) = self.libros_a_disposicion.get(\u0026libro) {\n            *copias\n        } else {\n            0\n        }\n    }\n\n    pub fn decrementar_copias_a_disposicion(\u0026mut self, libro: Libro) {\n        if let Some(copias) = self.libros_a_disposicion.get_mut(\u0026libro) {\n            if *copias \u003e 0 {\n                *copias -= 1;\n            }\n        }\n    }\n\n    pub fn incrementar_copias_a_disposicion(\u0026mut self, libro: Libro) {\n        if let Some(copias) = self.libros_a_disposicion.get_mut(\u0026libro) {\n            if *copias \u003c u8::max_value() {\n                *copias += 1;\n            }\n        }\n    }\n\n    pub fn contar_prestamos_de_cliente(\u0026self, cliente: Cliente) -\u003e usize {\n        self.prestamos_efectuados\n            .iter()\n            .filter(|f| f.cliente == cliente \u0026\u0026 f.estado == EstadoPrestamo::Prestamo)\n            .count()\n    }\n\n    pub fn realizar_prestamo_a_cliente(\u0026mut self, cliente: Cliente, libro: Libro) -\u003e bool {\n        if self\n            .prestamos_efectuados\n            .iter()\n            .filter(|f| f.cliente == cliente \u0026\u0026 f.estado == EstadoPrestamo::Prestamo)\n            .count()\n            \u003c 5\n        {\n            self.incrementar_copias_a_disposicion(libro);\n            true\n        } else {\n            false\n        }\n    }\n\n    pub fn ver_prestamos_a_vencer(\u0026self, dias: u8, fecha_actual: Fecha) -\u003e Vec\u003cPrestamo\u003e {\n        self.prestamos_efectuados\n            .iter()\n            .filter(|f| f.estado == EstadoPrestamo::Prestamo)\n            .filter(|f| {\n                let mut fecha_limite = fecha_actual;\n                fecha_limite.sumar_dias(dias as i64);\n                f.fecha_vencimiento \u003c= fecha_limite\n            })\n            .cloned()\n            .collect()\n    }\n\n    pub fn ver_prestamos_vencidos(\u0026self, fecha_actual: Fecha) -\u003e Vec\u003cPrestamo\u003e {\n        self.prestamos_efectuados\n            .iter()\n            .filter(|f| f.estado == EstadoPrestamo::Prestamo)\n            .filter(|f| f.fecha_vencimiento \u003c= fecha_actual)\n            .cloned()\n            .collect()\n    }\n\n    pub fn buscar_prestamo(\u0026self, cliente: Cliente, libro: Libro) -\u003e Option\u003cPrestamo\u003e {\n        if let Some(prestamo) = self\n            .prestamos_efectuados\n            .iter()\n            .find(|f| f.libro == libro \u0026\u0026 f.cliente == cliente)\n            .cloned()\n        {\n            Some(prestamo)\n        } else {\n            None\n        }\n    }\n\n    pub fn devolver_libro(\u0026mut self, cliente: Cliente, libro: Libro) {\n        if let Some(prestamo) = self\n            .prestamos_efectuados\n            .iter_mut()\n            .find(|f| f.cliente == cliente \u0026\u0026 f.libro == libro)\n        {\n            prestamo.estado = EstadoPrestamo::Devuelto;\n            self.incrementar_copias_a_disposicion(libro);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn obtener_cantidad_de_copias_correctamente() {\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let mut map = HashMap::new();\n        map.insert(libro.clone(), 3);\n        let biblio = Biblioteca {\n            mombre: \"Biblio\".to_string(),\n            direccion: \"Calle 1\".to_string(),\n            prestamos_efectuados: vec![],\n            libros_a_disposicion: map,\n        };\n        assert_eq!(biblio.obtener_cantidad_de_copias(libro), 3);\n    }\n\n    #[test]\n    fn incrementar_y_decrementar_copias_correctamente() {\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let mut map = HashMap::new();\n        map.insert(libro.clone(), 1);\n        let mut biblio = Biblioteca {\n            mombre: \"B\".to_string(),\n            direccion: \"X\".to_string(),\n            prestamos_efectuados: vec![],\n            libros_a_disposicion: map,\n        };\n        biblio.incrementar_copias_a_disposicion(libro.clone());\n        assert_eq!(biblio.obtener_cantidad_de_copias(libro.clone()), 2);\n        biblio.decrementar_copias_a_disposicion(libro.clone());\n        assert_eq!(biblio.obtener_cantidad_de_copias(libro.clone()), 1);\n    }\n\n    #[test]\n    fn contar_prestamos_cliente_correctamente() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            email: \"juan@email.com\".to_string(),\n        };\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let biblio = Biblioteca {\n            mombre: \"B\".to_string(),\n            direccion: \"X\".to_string(),\n            prestamos_efectuados: vec![Prestamo {\n                libro,\n                fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                cliente: cliente.clone(),\n                estado: EstadoPrestamo::Prestamo,\n            }],\n            libros_a_disposicion: HashMap::new(),\n        };\n        assert_eq!(biblio.contar_prestamos_de_cliente(cliente), 1);\n    }\n\n    #[test]\n    fn realizar_prestamo_a_cliente_correctamente() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            email: \"juan@email.com\".to_string(),\n        };\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let mut biblio = Biblioteca {\n            mombre: \"B\".to_string(),\n            direccion: \"X\".to_string(),\n            prestamos_efectuados: vec![Prestamo {\n                libro: libro.clone(),\n                fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                cliente: cliente.clone(),\n                estado: EstadoPrestamo::Prestamo,\n            }],\n            libros_a_disposicion: HashMap::new(),\n        };\n        biblio.realizar_prestamo_a_cliente(cliente, libro);\n        assert_eq!(biblio.prestamos_efectuados.len(), 1);\n    }\n\n    #[test]\n    fn ver_prestamos_vencidos_correctamente() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            email: \"juan@email.com\".to_string(),\n        };\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let biblio = Biblioteca {\n            mombre: \"B\".to_string(),\n            direccion: \"X\".to_string(),\n            prestamos_efectuados: vec![\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Prestamo,\n                },\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Devuelto,\n                },\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Prestamo,\n                },\n            ],\n            libros_a_disposicion: HashMap::new(),\n        };\n        let vencidos = biblio.ver_prestamos_vencidos(Fecha::new(02, 05, 2025).unwrap());\n        assert_eq!(vencidos.len(), 2);\n    }\n\n    #[test]\n    fn buscar_prestamo_correctamente() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            email: \"juan@email.com\".to_string(),\n        };\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let biblio = Biblioteca {\n            mombre: \"B\".to_string(),\n            direccion: \"X\".to_string(),\n            prestamos_efectuados: vec![\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Prestamo,\n                },\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Devuelto,\n                },\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Prestamo,\n                },\n            ],\n            libros_a_disposicion: HashMap::new(),\n        };\n        let found = biblio.buscar_prestamo(cliente, libro);\n        assert!(found.is_some());\n    }\n\n    #[test]\n    fn devolver_libro_correctamente() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            email: \"juan@email.com\".to_string(),\n        };\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let mut biblio = Biblioteca {\n            mombre: \"B\".to_string(),\n            direccion: \"X\".to_string(),\n            prestamos_efectuados: vec![\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Prestamo,\n                },\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Devuelto,\n                },\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Prestamo,\n                },\n            ],\n            libros_a_disposicion: HashMap::from([(libro.clone(), 0)]),\n        };\n        biblio.devolver_libro(cliente.clone(), libro.clone());\n        assert_eq!(biblio.obtener_cantidad_de_copias(libro.clone()), 1);\n        assert_eq!(\n            biblio.prestamos_efectuados[0].estado,\n            EstadoPrestamo::Devuelto\n        );\n    }\n}\n","traces":[{"line":51,"address":[966296,966160],"length":1,"stats":{"Line":1}},{"line":52,"address":[966174,966223,966270],"length":1,"stats":{"Line":3}},{"line":53,"address":[966264],"length":1,"stats":{"Line":1}},{"line":55,"address":[966272],"length":1,"stats":{"Line":0}},{"line":59,"address":[966320,966505],"length":1,"stats":{"Line":1}},{"line":60,"address":[966334,966386],"length":1,"stats":{"Line":2}},{"line":61,"address":[966432,966483],"length":1,"stats":{"Line":2}},{"line":62,"address":[966485,966457],"length":1,"stats":{"Line":1}},{"line":67,"address":[966528,966737],"length":1,"stats":{"Line":1}},{"line":68,"address":[966542,966594],"length":1,"stats":{"Line":2}},{"line":69,"address":[966715,966680,966640],"length":1,"stats":{"Line":3}},{"line":70,"address":[966717,966689],"length":1,"stats":{"Line":1}},{"line":75,"address":[966768,966922],"length":1,"stats":{"Line":1}},{"line":76,"address":[966841,966782],"length":1,"stats":{"Line":2}},{"line":78,"address":[728800,728822],"length":1,"stats":{"Line":2}},{"line":82,"address":[967311,966944],"length":1,"stats":{"Line":1}},{"line":83,"address":[966974,967062,967137,967227],"length":1,"stats":{"Line":3}},{"line":86,"address":[728896,728918],"length":1,"stats":{"Line":2}},{"line":90,"address":[967149],"length":1,"stats":{"Line":1}},{"line":91,"address":[967222],"length":1,"stats":{"Line":1}},{"line":93,"address":[967132],"length":1,"stats":{"Line":0}},{"line":97,"address":[967344],"length":1,"stats":{"Line":0}},{"line":98,"address":[967384],"length":1,"stats":{"Line":0}},{"line":100,"address":[729006,728992],"length":1,"stats":{"Line":0}},{"line":101,"address":[729040],"length":1,"stats":{"Line":0}},{"line":102,"address":[729059],"length":1,"stats":{"Line":0}},{"line":103,"address":[729068],"length":1,"stats":{"Line":0}},{"line":104,"address":[729092],"length":1,"stats":{"Line":0}},{"line":110,"address":[967488],"length":1,"stats":{"Line":1}},{"line":111,"address":[967522],"length":1,"stats":{"Line":1}},{"line":113,"address":[729134,729120],"length":1,"stats":{"Line":2}},{"line":114,"address":[729185,729168],"length":1,"stats":{"Line":2}},{"line":119,"address":[968001,967616],"length":1,"stats":{"Line":1}},{"line":120,"address":[967898,967664,967732,967942],"length":1,"stats":{"Line":3}},{"line":123,"address":[729242,729216],"length":1,"stats":{"Line":2}},{"line":126,"address":[967880],"length":1,"stats":{"Line":1}},{"line":128,"address":[967929],"length":1,"stats":{"Line":0}},{"line":132,"address":[968032,968440],"length":1,"stats":{"Line":1}},{"line":133,"address":[968150,968062],"length":1,"stats":{"Line":2}},{"line":136,"address":[729338,729312],"length":1,"stats":{"Line":2}},{"line":138,"address":[968271],"length":1,"stats":{"Line":1}},{"line":139,"address":[968362,968289],"length":1,"stats":{"Line":2}}],"covered":32,"coverable":42},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej2.rs"],"content":"pub struct Rectangulo {\n    pub longitud: u32,\n    pub ancho: u32,\n}\n\nimpl Rectangulo {\n    pub fn new(longitud: u32, ancho: u32) -\u003e Rectangulo {\n        Rectangulo { longitud, ancho }\n    }\n\n    pub fn calcular_area(\u0026self) -\u003e u64 {\n        self.longitud as u64 * self.ancho as u64\n    }\n\n    pub fn calcular_perimetro(\u0026self) -\u003e u64 {\n        (self.longitud as u64 * self.ancho as u64) * 2\n    }\n\n    pub fn es_cuadrado(\u0026self) -\u003e bool {\n        self.longitud == self.ancho\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_rectangulo_con_parametros_correctos() {\n        let rect = Rectangulo::new(5, 5);\n\n        assert_eq!(rect.ancho, 5);\n        assert_eq!(rect.longitud, 5);\n    }\n\n    #[test]\n    fn calcular_correctamente_area_de_rectangulo() {\n        assert_eq!(Rectangulo::new(2, 0).calcular_area(), 0);\n        assert_eq!(Rectangulo::new(1, 1).calcular_area(), 1);\n        assert_eq!(Rectangulo::new(5, 6).calcular_area(), 30);\n    }\n\n    #[test]\n    fn calcular_correctamente_perimetro_de_rectangulo() {\n        assert_eq!(Rectangulo::new(2, 0).calcular_perimetro(), 0);\n        assert_eq!(Rectangulo::new(1, 1).calcular_perimetro(), 2);\n        assert_eq!(Rectangulo::new(5, 6).calcular_perimetro(), 60);\n    }\n\n    #[test]\n    fn identifica_cuadrado_correctamente() {\n        assert!(!Rectangulo::new(2, 0).es_cuadrado());\n        assert!(Rectangulo::new(1, 1).es_cuadrado());\n        assert!(!Rectangulo::new(5, 6).es_cuadrado());\n        assert!(Rectangulo::new(u32::max_value(), u32::max_value()).es_cuadrado());\n    }\n}\n","traces":[{"line":7,"address":[829152],"length":1,"stats":{"Line":1}},{"line":11,"address":[829168],"length":1,"stats":{"Line":1}},{"line":12,"address":[829177,829205],"length":1,"stats":{"Line":1}},{"line":15,"address":[829232],"length":1,"stats":{"Line":1}},{"line":16,"address":[829308,829241],"length":1,"stats":{"Line":1}},{"line":19,"address":[829328],"length":1,"stats":{"Line":1}},{"line":20,"address":[829333],"length":1,"stats":{"Line":1}}],"covered":7,"coverable":7},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej3.rs"],"content":"use time::{\n    Duration, {Date, Month},\n};\n\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\npub struct Fecha {\n    fecha: Date,\n}\n\nimpl Fecha {\n    pub fn new(dia: u8, mes: u8, anio: i32) -\u003e Option\u003cSelf\u003e {\n        if Self::es_fecha_valida(dia, mes, anio) {\n            Some(Self {\n                fecha: Date::from_calendar_date(anio, Month::try_from(mes).unwrap(), dia).unwrap(),\n            })\n        } else {\n            None\n        }\n    }\n\n    pub fn es_fecha_valida(dia: u8, mes: u8, anio: i32) -\u003e bool {\n        if let Ok(month) = Month::try_from(mes) {\n            Date::from_calendar_date(anio, month, dia).is_ok()\n        } else {\n            false\n        }\n    }\n\n    pub fn es_bisiesto(\u0026self) -\u003e bool {\n        /*\n            https://es.wikipedia.org/wiki/A%C3%B1o_bisiesto\n\n           p: Es divisible por 4\n           q: Es divisible por 100\n           r: Es divisible por 400\n\n           (p ∧ ~q) ∨ r\n        */\n        (self.fecha.year() % 4 == 0 \u0026\u0026 self.fecha.year() \u0026 100 != 0) || self.fecha.year() \u0026 400 == 0\n    }\n\n    pub fn sumar_dias(\u0026mut self, dias: i64) {\n        self.fecha = self.fecha + Duration::days(dias);\n    }\n\n    pub fn restar_dias(\u0026mut self, dias: i64) {\n        self.fecha = self.fecha - Duration::days(dias);\n    }\n\n    pub fn es_mayor(\u0026self, una_fecha: \u0026Fecha) -\u003e bool {\n        self.fecha \u003e una_fecha.fecha\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_una_fecha_con_correctamente() {\n        assert!(Fecha::new(11, 09, 2001).is_some());\n        assert!(Fecha::new(31, 11, 2025).is_none());\n        assert!(Fecha::new(29, 2, 2023).is_none());\n    }\n\n    #[test]\n    fn verifica_fecha_valida() {\n        assert!(!Fecha::es_fecha_valida(29, 2, 2023));\n        assert!(!Fecha::es_fecha_valida(31, 11, 2025));\n        assert!(Fecha::es_fecha_valida(31, 12, 2025));\n    }\n\n    #[test]\n    fn verifica_fecha_bisiesto() {\n        assert!(\n            Fecha::new(29, 3, 2024)\n                .expect(\"Fecha incorrecta\")\n                .es_bisiesto()\n        );\n        assert!(\n            !Fecha::new(19, 5, 2023)\n                .expect(\"Fecha incorrecta\")\n                .es_bisiesto()\n        );\n    }\n\n    #[test]\n    fn verifica_sumar_dias_a_fecha() {\n        let mut fecha = Fecha::new(11, 09, 2001).unwrap();\n        fecha.sumar_dias(15);\n\n        assert_eq!(fecha, Fecha::new(26, 09, 2001).unwrap());\n    }\n\n    #[test]\n    fn verifica_restar_dias_a_fecha() {\n        let mut fecha = Fecha::new(11, 09, 2001).unwrap();\n        fecha.restar_dias(2);\n\n        assert_eq!(fecha, Fecha::new(09, 09, 2001).unwrap());\n    }\n}\n","traces":[{"line":11,"address":[779184],"length":1,"stats":{"Line":1}},{"line":12,"address":[779253,779230],"length":1,"stats":{"Line":2}},{"line":13,"address":[779334],"length":1,"stats":{"Line":2}},{"line":14,"address":[779259],"length":1,"stats":{"Line":1}},{"line":17,"address":[779245],"length":1,"stats":{"Line":1}},{"line":21,"address":[779360],"length":1,"stats":{"Line":1}},{"line":22,"address":[779395],"length":1,"stats":{"Line":1}},{"line":23,"address":[779453],"length":1,"stats":{"Line":1}},{"line":25,"address":[779488],"length":1,"stats":{"Line":0}},{"line":29,"address":[779520],"length":1,"stats":{"Line":1}},{"line":39,"address":[779533],"length":1,"stats":{"Line":1}},{"line":42,"address":[779664],"length":1,"stats":{"Line":1}},{"line":43,"address":[779683],"length":1,"stats":{"Line":1}},{"line":46,"address":[779728],"length":1,"stats":{"Line":1}},{"line":47,"address":[779747],"length":1,"stats":{"Line":1}},{"line":50,"address":[779792],"length":1,"stats":{"Line":0}},{"line":51,"address":[779806],"length":1,"stats":{"Line":0}}],"covered":14,"coverable":17},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej4.rs"],"content":"#[derive(Debug, PartialEq)]\npub enum TrianguloTipo {\n    Equilatero,\n    Isosceles,\n    Escaleno,\n}\n\n#[derive(Debug, PartialEq)]\npub struct Triangulo {\n    pub x: i64,\n    pub y: i64,\n    pub z: i64,\n}\n\nimpl Triangulo {\n    pub fn new(x: i64, y: i64, z: i64) -\u003e Self {\n        Triangulo { x, y, z }\n    }\n\n    pub fn determinar_tipo(\u0026self) -\u003e Option\u003cTrianguloTipo\u003e {\n        if self.x == self.y \u0026\u0026 self.y == self.z {\n            Some(TrianguloTipo::Equilatero)\n        } else if (self.x == self.y) || (self.x == self.z) || (self.z == self.y) {\n            Some(TrianguloTipo::Isosceles)\n        } else if (self.x != self.y) \u0026\u0026 (self.x != self.z) \u0026\u0026 (self.z != self.y) {\n            Some(TrianguloTipo::Escaleno)\n        } else {\n            None\n        }\n    }\n\n    pub fn calcular_area(\u0026self) -\u003e f64 {\n        (f64::sqrt(3.0) / 4.0) * (self.y * self.y) as f64\n    }\n\n    pub fn calcular_perimetro(\u0026self) -\u003e i64 {\n        self.x + self.y + self.z\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_nuevo_triangulo_correctamente() {\n        assert_eq!(Triangulo::new(5, 5, 5), Triangulo { x: 5, y: 5, z: 5 });\n        assert_ne!(Triangulo::new(2, 7, 3), Triangulo { x: 1, y: 1, z: 1 });\n    }\n\n    #[test]\n    fn determinar_tipo_triangulo_correctamente() {\n        assert_eq!(\n            Triangulo::new(5, 5, 5).determinar_tipo().unwrap(),\n            TrianguloTipo::Equilatero\n        );\n        assert_eq!(\n            Triangulo::new(2, 7, 1).determinar_tipo().unwrap(),\n            TrianguloTipo::Escaleno\n        );\n\n        assert_eq!(\n            Triangulo::new(2, 2, 1).determinar_tipo().unwrap(),\n            TrianguloTipo::Isosceles\n        );\n    }\n\n    #[test]\n    fn calcula_correctamente_el_area_del_rectangulo() {\n        assert_eq!(\n            Triangulo::new(5, 5, 5).calcular_area(),\n            (f64::sqrt(3.0) / 4.0) * (5.0_f64.powf(2.0))\n        );\n        assert_eq!(\n            Triangulo::new(7, 2, 6).calcular_area(),\n            (f64::sqrt(3.0) / 4.0) * (2.0_f64.powf(2.0))\n        );\n    }\n\n    #[test]\n    fn calcular_correctamente_perimetro_del_triangulo() {\n        assert_eq!(Triangulo::new(5, 5, 5).calcular_perimetro(), 15);\n        assert_eq!(Triangulo::new(2, 7, 9).calcular_perimetro(), 18);\n        assert_eq!(Triangulo::new(2, 3, 5).calcular_perimetro(), 10);\n    }\n}\n","traces":[{"line":16,"address":[1068192],"length":1,"stats":{"Line":1}},{"line":20,"address":[1068224],"length":1,"stats":{"Line":1}},{"line":21,"address":[1068287,1068264,1068234],"length":1,"stats":{"Line":3}},{"line":22,"address":[1068274],"length":1,"stats":{"Line":1}},{"line":23,"address":[1068248,1068294,1068316],"length":1,"stats":{"Line":3}},{"line":24,"address":[1068303],"length":1,"stats":{"Line":1}},{"line":25,"address":[1068338,1068352],"length":1,"stats":{"Line":1}},{"line":26,"address":[1068383],"length":1,"stats":{"Line":1}},{"line":28,"address":[1068347],"length":1,"stats":{"Line":0}},{"line":32,"address":[1068416],"length":1,"stats":{"Line":1}},{"line":33,"address":[1068510,1068430],"length":1,"stats":{"Line":1}},{"line":36,"address":[1068528],"length":1,"stats":{"Line":1}},{"line":37,"address":[1068611,1068542],"length":1,"stats":{"Line":1}}],"covered":12,"coverable":13},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej5.rs"],"content":"#[derive(Debug, PartialEq)]\npub struct Producto {\n    pub nombre: String,\n    pub precio_bruto: f32,\n    pub numero_ident: u64,\n}\n\nimpl Producto {\n    pub fn new(nombre: String, precio_bruto: f32, numero_ident: u64) -\u003e Self {\n        Producto {\n            nombre,\n            precio_bruto,\n            numero_ident,\n        }\n    }\n\n    pub fn calcular_impuestos(\u0026self, porcentaje_de_impuestos: f32) -\u003e f32 {\n        self.precio_bruto * (porcentaje_de_impuestos / 100.0)\n    }\n\n    pub fn aplicar_descuento(\u0026self, porcentaje_de_descuento: f32) -\u003e f32 {\n        self.precio_bruto * (porcentaje_de_descuento / 100.0)\n    }\n\n    pub fn calcular_precio_total(\n        \u0026self,\n        porcentaje_de_impuestos: Option\u003cf32\u003e,\n        porcentaje_de_descuento: Option\u003cf32\u003e,\n    ) -\u003e f32 {\n        if let Some(descuento) = porcentaje_de_descuento {\n            if let Some(impuesto) = porcentaje_de_impuestos {\n                return self.precio_bruto + self.calcular_impuestos(impuesto)\n                    - self.aplicar_descuento(descuento);\n            } else {\n                return self.precio_bruto - self.aplicar_descuento(descuento);\n            }\n        } else if let Some(impuesto) = porcentaje_de_impuestos {\n            return self.precio_bruto + self.calcular_impuestos(impuesto);\n        } else {\n            self.precio_bruto\n        }\n\n        /*\n           Lo mismo pero mas aburrido ._.\n\n           let mut total = self.precio_bruto;\n           if porcentaje_de_descuento.is_some() {\n               total = -self.aplicar_descuento(porcentaje_de_descuento.unwrap());\n           }\n           if porcentaje_de_impuestos.is_some() {\n               total += self.calcular_impuestos(porcentaje_de_impuestos.unwrap())\n           }\n           total\n        */\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_nuevo_producto_correctamente() {\n        assert_eq!(\n            Producto::new(\"Nodemcu Esp32\".to_string(), 14990.00, 3032192),\n            Producto {\n                nombre: \"Nodemcu Esp32\".to_string(),\n                precio_bruto: 14990.00,\n                numero_ident: 3032192\n            }\n        );\n    }\n\n    #[test]\n    fn calcula_impuestos_de_producto_correctamente() {\n        assert_eq!(\n            Producto::new(\"Nodemcu Esp32\".to_string(), 14990.00, 3032192).calcular_impuestos(20.00),\n            14990.00 * (20.00 / 100.0)\n        );\n    }\n\n    #[test]\n    fn calcula_descuento_de_producto_correctamente() {\n        assert_eq!(\n            Producto::new(\"Nodemcu Esp32\".to_string(), 14990.00, 3032192).aplicar_descuento(35.00),\n            14990.00 * (35.00 / 100.0)\n        );\n    }\n\n    #[test]\n    fn calcula_correctamente_precio_total_de_producto() {\n        assert_eq!(\n            Producto::new(\"Nodemcu Esp32\".to_string(), 14990.00, 3032192)\n                .calcular_precio_total(Some(20.00), None),\n            14990.00 + (14990.00 * (20.00 / 100.0)),\n            \"El precio total no se calculo como se esperaba (20% impuestos y 0% descuento)\"\n        );\n\n        assert_eq!(\n            Producto::new(\"Nodemcu Esp32\".to_string(), 14990.00, 3032192)\n                .calcular_precio_total(None, Some(35.00)),\n            14990.00 - (14990.00 * (35.00 / 100.0)),\n            \"El precio total no se calculo como se esperaba (0% impuestos y 35% descuento)\"\n        );\n\n        assert_eq!(\n            Producto::new(\"Nodemcu Esp32\".to_string(), 14990.00, 3032192)\n                .calcular_precio_total(Some(20.00), Some(35.00)),\n            14990.00 - (14990.00 * (35.00 / 100.0)) + (14990.00 * (20.00 / 100.0)),\n            \"El precio total no se calculo como se esperaba (20% impuestos y 35% descuento)\"\n        );\n    }\n}\n","traces":[{"line":9,"address":[593472],"length":1,"stats":{"Line":1}},{"line":17,"address":[593520],"length":1,"stats":{"Line":1}},{"line":18,"address":[593534],"length":1,"stats":{"Line":1}},{"line":21,"address":[593568],"length":1,"stats":{"Line":1}},{"line":22,"address":[593582],"length":1,"stats":{"Line":2}},{"line":25,"address":[593616],"length":1,"stats":{"Line":1}},{"line":30,"address":[593650],"length":1,"stats":{"Line":1}},{"line":31,"address":[593678,593714],"length":1,"stats":{"Line":2}},{"line":32,"address":[593726,593786],"length":1,"stats":{"Line":2}},{"line":33,"address":[593772],"length":1,"stats":{"Line":1}},{"line":35,"address":[593809],"length":1,"stats":{"Line":1}},{"line":37,"address":[593690,593925,593860],"length":1,"stats":{"Line":2}},{"line":38,"address":[593872],"length":1,"stats":{"Line":1}},{"line":40,"address":[593914],"length":1,"stats":{"Line":0}}],"covered":13,"coverable":14},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej6.rs"],"content":"#[derive(Debug, PartialEq)]\npub struct Examen {\n    pub nombre_materia: String,\n    pub nota: u8,\n}\n\npub struct Informe {\n    nombre: String,\n    numero_ident: u64,\n    total_examenes_rendidos: usize,\n    promedio_general_notas: f64,\n    nota_mas_alta: (u8, String),\n    nota_mas_baja: (u8, String),\n}\n\n#[derive(Debug, PartialEq)]\npub struct Estudiante {\n    pub nombre: String,\n    pub numero_ident: u64,\n    pub calificaciones: Vec\u003cExamen\u003e,\n}\n\nimpl Examen {\n    pub fn new(nombre_materia: String, nota: u8) -\u003e Self {\n        Examen {\n            nombre_materia,\n            nota,\n        }\n    }\n}\n\nimpl Estudiante {\n    pub fn new(nombre: String, numero_ident: u64, calificaciones: Vec\u003cExamen\u003e) -\u003e Estudiante {\n        Estudiante {\n            nombre,\n            numero_ident,\n            calificaciones,\n        }\n    }\n\n    pub fn obtener_promedio(\u0026self) -\u003e f64 {\n        let total: u32 = self.calificaciones.iter().map(|f| f.nota as u32).sum();\n        let cantidad = self.calificaciones.len() as f64;\n\n        if cantidad == 0.0 {\n            0.0\n        } else {\n            total as f64 / cantidad\n        }\n    }\n\n    pub fn obtener_calificacion_mas_alta(\u0026self) -\u003e u8 {\n        self.calificaciones\n            .iter()\n            .map(|f| f.nota)\n            .max()\n            .unwrap_or(0)\n    }\n\n    pub fn obtener_calificacion_mas_baja(\u0026self) -\u003e u8 {\n        self.calificaciones\n            .iter()\n            .map(|f| f.nota)\n            .min()\n            .unwrap_or(0)\n    }\n\n    pub fn generar_informe(\u0026self) -\u003e Option\u003cInforme\u003e {\n        if self.calificaciones.is_empty() {\n            None\n        } else {\n            Some(Informe {\n                nombre: self.nombre.clone(),\n                numero_ident: self.numero_ident,\n                total_examenes_rendidos: self.calificaciones.iter().count(),\n                promedio_general_notas: self.calificaciones.iter().count() as f64\n                    / self.calificaciones.iter().fold(0, |acc, x| acc + x.nota) as f64,\n                nota_mas_alta: (0, \"todo\".to_owned()),\n                nota_mas_baja: (0, \"todo\".to_owned()),\n            })\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn obtiene_promedio_correctamente() {\n        let mut calificaciones: Vec\u003cExamen\u003e = Vec::new();\n        calificaciones.push(Examen::new(\"Matemática\".to_owned(), 8));\n        calificaciones.push(Examen::new(\"Historia\".to_owned(), 10));\n        let estudiante = Estudiante::new(\"Calamardo\".to_owned(), 42, calificaciones);\n\n        assert_eq!(\n            estudiante.obtener_promedio(),\n            9.0,\n            \"El promedio no se calculo como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn obtiene_calificacion_mas_alta_correctamente() {\n        let mut calificaciones: Vec\u003cExamen\u003e = Vec::new();\n        calificaciones.push(Examen::new(\"Matemática\".to_owned(), 8));\n        calificaciones.push(Examen::new(\"Historia\".to_owned(), 10));\n        let estudiante = Estudiante::new(\"Calamardo\".to_owned(), 42, calificaciones);\n\n        assert_eq!(\n            estudiante.obtener_calificacion_mas_alta(),\n            10,\n            \"No se obtubo el elemento esperado\"\n        );\n    }\n\n    #[test]\n    fn obtiene_calificacion_mas_baja_correctamente() {\n        let mut calificaciones: Vec\u003cExamen\u003e = Vec::new();\n        calificaciones.push(Examen::new(\"Matemática\".to_owned(), 8));\n        calificaciones.push(Examen::new(\"Historia\".to_owned(), 10));\n        let estudiante = Estudiante::new(\"Calamardo\".to_owned(), 42, calificaciones);\n\n        assert_eq!(\n            estudiante.obtener_calificacion_mas_baja(),\n            8,\n            \"No se obtubo el elemento esperado\"\n        );\n    }\n}\n","traces":[{"line":24,"address":[634432],"length":1,"stats":{"Line":1}},{"line":33,"address":[634480],"length":1,"stats":{"Line":1}},{"line":41,"address":[634544],"length":1,"stats":{"Line":1}},{"line":42,"address":[634553],"length":1,"stats":{"Line":3}},{"line":43,"address":[634613],"length":1,"stats":{"Line":1}},{"line":45,"address":[634709,634669],"length":1,"stats":{"Line":2}},{"line":46,"address":[634711],"length":1,"stats":{"Line":0}},{"line":48,"address":[634692],"length":1,"stats":{"Line":1}},{"line":52,"address":[634736],"length":1,"stats":{"Line":1}},{"line":53,"address":[634741],"length":1,"stats":{"Line":1}},{"line":55,"address":[1078752,1078762],"length":1,"stats":{"Line":2}},{"line":60,"address":[634816],"length":1,"stats":{"Line":1}},{"line":61,"address":[634821],"length":1,"stats":{"Line":1}},{"line":63,"address":[1078768,1078778],"length":1,"stats":{"Line":2}},{"line":68,"address":[634896,635834],"length":1,"stats":{"Line":0}},{"line":69,"address":[635049,634946],"length":1,"stats":{"Line":0}},{"line":70,"address":[635036],"length":1,"stats":{"Line":0}},{"line":72,"address":[635599],"length":1,"stats":{"Line":0}},{"line":73,"address":[634967],"length":1,"stats":{"Line":0}},{"line":74,"address":[634992],"length":1,"stats":{"Line":0}},{"line":75,"address":[635114,635001],"length":1,"stats":{"Line":0}},{"line":76,"address":[635377,635161],"length":1,"stats":{"Line":0}},{"line":77,"address":[635289],"length":1,"stats":{"Line":0}},{"line":78,"address":[635386],"length":1,"stats":{"Line":0}},{"line":79,"address":[635453,635543],"length":1,"stats":{"Line":0}}],"covered":13,"coverable":25},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej7.rs"],"content":"#[derive(PartialEq, Debug, Clone)]\npub enum ColorAuto {\n    Rojo,\n    Verde,\n    Azul,\n    Amarillo,\n    Blanco,\n    Negro,\n}\n\n#[derive(PartialEq, Debug, Clone)]\npub struct Auto {\n    pub marca: String,\n    pub modelo: String,\n    pub anio: u32,\n    pub precio_bruto: f64,\n    pub color: ColorAuto,\n}\n\nimpl Auto {\n    pub fn new(\n        marca: String,\n        modelo: String,\n        anio: u32,\n        precio_bruto: f64,\n        color: ColorAuto,\n    ) -\u003e Self {\n        Auto {\n            marca,\n            modelo,\n            anio,\n            precio_bruto,\n            color,\n        }\n    }\n\n    pub fn calcular_precio(\u0026self) -\u003e f64 {\n        let mut total: f64 = self.precio_bruto;\n        match self.color {\n            ColorAuto::Rojo | ColorAuto::Verde | ColorAuto::Amarillo =\u003e {\n                total += self.precio_bruto * 25.0 / 100.0\n            }\n            _ =\u003e total -= self.precio_bruto * 10.0 / 100.0,\n        };\n        if self.marca == \"BMW\" {\n            total += self.precio_bruto * 15.0 / 100.0;\n        }\n        if self.anio \u003c 2000 {\n            total -= self.precio_bruto * 5.0 / 100.0;\n        }\n        total\n    }\n}\n\n#[derive(Debug, PartialEq)]\npub struct ConcesionarioAuto {\n    pub nombre: String,\n    pub direccion: String,\n    pub capacidad_max: usize,\n    pub autos: Vec\u003cAuto\u003e,\n}\n\nimpl ConcesionarioAuto {\n    pub fn new(nombre: String, direccion: String, capacidad_max: usize, autos: Vec\u003cAuto\u003e) -\u003e Self {\n        ConcesionarioAuto {\n            nombre,\n            direccion,\n            capacidad_max,\n            autos,\n        }\n    }\n\n    pub fn agregar_auto(\u0026mut self, auto: Auto) {\n        if self.autos.len() \u003c self.capacidad_max {\n            self.autos.push(auto);\n        }\n    }\n\n    pub fn eliminar_auto(\u0026mut self, auto: Auto) {\n        if let Some(pos) = self.autos.iter().position(|f| *f == auto) {\n            self.autos.remove(pos);\n        }\n    }\n\n    pub fn buscar_auto(\u0026self, auto: Auto) -\u003e Option\u003cAuto\u003e {\n        if let Some(pos) = self.autos.iter().position(|f| *f == auto) {\n            Some(self.autos[pos].clone())\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_nuevo_concesionario_auto_correctamente() {\n        assert_eq!(\n            ConcesionarioAuto::new(\n                \"Concesionario 44\".to_owned(),\n                \"44 13 y 14\".to_owned(),\n                5,\n                Vec::new()\n            ),\n            ConcesionarioAuto {\n                nombre: \"Concesionario 44\".to_owned(),\n                direccion: \"44 13 y 14\".to_owned(),\n                capacidad_max: 5,\n                autos: Vec::new()\n            },\n            \"No se creo el objeto como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn agregar_auto_a_concesionario_correctamente() {\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            5,\n            Vec::new(),\n        );\n        conce.agregar_auto(Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        });\n        assert_eq!(\n            conce.autos.len(),\n            1,\n            \"No se agrego el auto al concesionario como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn eliminar_auto_de_concesionario_correctamente() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            5,\n            Vec::new(),\n        );\n        conce.agregar_auto(auto.clone());\n        assert_eq!(conce.autos.len(), 1,);\n        conce.eliminar_auto(auto);\n        assert_eq!(\n            conce.autos.len(),\n            0,\n            \"No se elimino el auto al concesionario como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn buscar_auto_en_concesionario_correctamente() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            5,\n            Vec::new(),\n        );\n        conce.agregar_auto(auto.clone());\n\n        assert_eq!(\n            conce.buscar_auto(auto.clone()),\n            Some(auto),\n            \"No se encontro el auto en el concesionario como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn calcular_precio_de_auto_correctamente() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n\n        assert_eq!(\n            auto.calcular_precio(),\n            40_500.0,\n            \"No se calculo el precio del auto como se esperaba\"\n        );\n    }\n}\n","traces":[{"line":21,"address":[655664],"length":1,"stats":{"Line":0}},{"line":37,"address":[655776],"length":1,"stats":{"Line":1}},{"line":38,"address":[655790],"length":1,"stats":{"Line":1}},{"line":39,"address":[655801],"length":1,"stats":{"Line":1}},{"line":41,"address":[655884],"length":1,"stats":{"Line":1}},{"line":43,"address":[655836],"length":1,"stats":{"Line":0}},{"line":45,"address":[656000,655926],"length":1,"stats":{"Line":2}},{"line":46,"address":[655963],"length":1,"stats":{"Line":1}},{"line":48,"address":[656059,655947],"length":1,"stats":{"Line":2}},{"line":49,"address":[656018],"length":1,"stats":{"Line":1}},{"line":51,"address":[656002],"length":1,"stats":{"Line":1}},{"line":64,"address":[656064],"length":1,"stats":{"Line":1}},{"line":73,"address":[656385,656160,656363],"length":1,"stats":{"Line":1}},{"line":74,"address":[656182,656253],"length":1,"stats":{"Line":2}},{"line":75,"address":[656278],"length":1,"stats":{"Line":1}},{"line":79,"address":[656656,656400],"length":1,"stats":{"Line":1}},{"line":80,"address":[656493,656425],"length":1,"stats":{"Line":4}},{"line":81,"address":[656603,656649],"length":1,"stats":{"Line":2}},{"line":85,"address":[656688,657010],"length":1,"stats":{"Line":1}},{"line":86,"address":[656731,656949,656799],"length":1,"stats":{"Line":4}},{"line":87,"address":[656960,656909],"length":1,"stats":{"Line":2}},{"line":89,"address":[656936],"length":1,"stats":{"Line":0}}],"covered":19,"coverable":22},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej8.rs"],"content":"#[derive(Debug, PartialEq, Clone)]\npub enum Genero {\n    Rock,\n    Pop,\n    Rap,\n    Jazz,\n    Otros,\n}\n\n#[derive(Debug, PartialEq, Clone)]\npub struct Cancion {\n    pub titulo: String,\n    pub artista: String,\n    pub genero: Genero,\n}\n\npub struct Playlist {\n    pub canciones: Vec\u003cCancion\u003e,\n    pub nombre: String,\n}\n\nimpl Playlist {\n    pub fn agregar_cancion(\u0026mut self, cancion: Cancion) {\n        self.canciones.push(cancion);\n    }\n\n    pub fn eliminar_cancion(\u0026mut self, cancion: Cancion) {\n        if let Some(pos) = self.canciones.iter().position(|f| *f == cancion) {\n            self.canciones.remove(pos);\n        }\n    }\n\n    pub fn mover_cancion(\u0026mut self, cancion: Cancion, posicion: usize) {\n        if let Some(pos) = self.canciones.iter().position(|f| *f == cancion) {\n            let cancion = self.canciones.remove(pos);\n            let nueva_posicion = if posicion \u003e self.canciones.len() {\n                self.canciones.len()\n            } else {\n                posicion\n            };\n\n            self.canciones.insert(nueva_posicion, cancion);\n        }\n    }\n\n    pub fn buscar_cancion_por_nombre(\u0026self, cancion: Cancion) -\u003e Option\u003c\u0026Cancion\u003e {\n        self.canciones.iter().find(|f| **f == cancion)\n    }\n\n    pub fn obtener_canciones_por_genero(\u0026self, genero: Genero) -\u003e Vec\u003c\u0026Cancion\u003e {\n        self.canciones\n            .iter()\n            .filter(|f| f.genero == genero)\n            .collect()\n    }\n\n    pub fn obtener_canciones_por_artista(\u0026self, artista: String) -\u003e Vec\u003c\u0026Cancion\u003e {\n        self.canciones\n            .iter()\n            .filter(|f| f.artista == artista)\n            .collect()\n    }\n\n    pub fn modificar_titulo(\u0026mut self, titulo: String) {\n        self.nombre = titulo;\n    }\n\n    pub fn limpiar_playlist(\u0026mut self) {\n        self.canciones.clear();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn agrega_cancion_a_playlist_correctamente() {\n        let cancion = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion.clone());\n\n        assert_eq!(\n            playlist.canciones[0], cancion,\n            \"No se agrego la cancion a la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn elimina_cancion_de_playlist_correctamente() {\n        let cancion = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion.clone());\n        playlist.eliminar_cancion(cancion);\n\n        assert_eq!(\n            playlist.canciones.len(),\n            0,\n            \"No se elimino la cancion de la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn mueve_cancion_a_una_determinada_posicion_de_la_playlist() {\n        let cancion_1 = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n        let cancion_2 = Cancion {\n            titulo: \"Trance Awake\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Lacuna Coil\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion_1.clone());\n        playlist.agregar_cancion(cancion_2);\n\n        playlist.mover_cancion(cancion_1.clone(), 1);\n\n        assert_eq!(\n            playlist.canciones[1], cancion_1,\n            \"No se movio la cancion de la playlist a la posicion que se esperaba\"\n        );\n    }\n\n    #[test]\n    fn busca_cancion_por_nombre_en_playlist() {\n        let cancion = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion.clone());\n\n        assert_eq!(\n            playlist\n                .buscar_cancion_por_nombre(cancion.clone())\n                .unwrap()\n                .to_owned(),\n            cancion,\n            \"No se encontro la cancion en la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn obtener_canciones_por_genero_en_playlist() {\n        let cancion_1 = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n        let cancion_2 = Cancion {\n            titulo: \"Trance Awake\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Lacuna Coil\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion_1.clone());\n        playlist.agregar_cancion(cancion_2.clone());\n\n        let mut expected = Vec::\u003c\u0026Cancion\u003e::new();\n        expected.push(\u0026cancion_1);\n        expected.push(\u0026cancion_2);\n\n        assert_eq!(\n            playlist.obtener_canciones_por_genero(Genero::Otros),\n            expected,\n            \"No se obtuvieron las canciones de la playlist por genero como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn obtener_canciones_por_artista_en_playlist() {\n        let cancion_1 = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n        let cancion_2 = Cancion {\n            titulo: \"Trance Awake\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Lacuna Coil\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion_1.clone());\n        playlist.agregar_cancion(cancion_2.clone());\n\n        let mut expected = Vec::\u003c\u0026Cancion\u003e::new();\n        expected.push(\u0026cancion_2);\n\n        assert_eq!(\n            playlist.obtener_canciones_por_artista(\"Lacuna Coil\".to_owned()),\n            expected,\n            \"No se obtuvieron las canciones de la playlist por artista como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn modificar_titulo_de_playlist() {\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.modificar_titulo(\"Metal only\".to_owned());\n\n        assert_eq!(\n            playlist.nombre,\n            \"Metal only\".to_owned(),\n            \"No se cambio el título de la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn eliminar_canciones_de_playlist() {\n        let cancion_1 = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n        let cancion_2 = Cancion {\n            titulo: \"Trance Awake\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Lacuna Coil\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion_1.clone());\n        playlist.agregar_cancion(cancion_2.clone());\n\n        playlist.limpiar_playlist();\n\n        assert_eq!(\n            playlist.canciones,\n            Vec::\u003cCancion\u003e::new(),\n            \"No se eliminaron todas las canciones de la playlist como se esperaba\"\n        );\n    }\n}\n","traces":[{"line":23,"address":[948800],"length":1,"stats":{"Line":1}},{"line":24,"address":[948805],"length":1,"stats":{"Line":1}},{"line":27,"address":[949078,948832],"length":1,"stats":{"Line":1}},{"line":28,"address":[663888,663913],"length":1,"stats":{"Line":4}},{"line":29,"address":[949029,949071],"length":1,"stats":{"Line":2}},{"line":33,"address":[949104,949630],"length":1,"stats":{"Line":1}},{"line":34,"address":[949607,949142,949214],"length":1,"stats":{"Line":5}},{"line":35,"address":[949324,949369],"length":1,"stats":{"Line":2}},{"line":36,"address":[949440,949377,949458],"length":1,"stats":{"Line":3}},{"line":37,"address":[949589,949465],"length":1,"stats":{"Line":0}},{"line":39,"address":[949450],"length":1,"stats":{"Line":1}},{"line":42,"address":[949482],"length":1,"stats":{"Line":1}},{"line":46,"address":[949664,949810],"length":1,"stats":{"Line":1}},{"line":47,"address":[663984,664001],"length":1,"stats":{"Line":4}},{"line":50,"address":[949840],"length":1,"stats":{"Line":1}},{"line":51,"address":[949878],"length":1,"stats":{"Line":1}},{"line":53,"address":[664032,664049],"length":1,"stats":{"Line":2}},{"line":57,"address":[950130,949952],"length":1,"stats":{"Line":1}},{"line":58,"address":[949989,950048],"length":1,"stats":{"Line":2}},{"line":60,"address":[664080,664097],"length":1,"stats":{"Line":2}},{"line":64,"address":[950160,950217],"length":1,"stats":{"Line":1}},{"line":65,"address":[950178,950252],"length":1,"stats":{"Line":2}},{"line":68,"address":[950288],"length":1,"stats":{"Line":1}},{"line":69,"address":[950293],"length":1,"stats":{"Line":1}}],"covered":23,"coverable":24},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej9.rs"],"content":"use super::ej3::Fecha;\nuse std::collections::VecDeque;\n\n#[derive(Debug, Eq, Ord, PartialEq, PartialOrd, Clone)]\npub enum TipoAnimal {\n    Perro,\n    Gato,\n    Caballo,\n    Otros,\n}\n\n#[derive(Debug, Eq, Ord, PartialEq, PartialOrd, Clone)]\npub struct Atencion {\n    pub mascota: Mascota,\n    pub diagnostico_final: String,\n    pub tratamiento: String,\n    pub fecha_proxima_visita: Option\u003cFecha\u003e,\n}\n\n#[derive(Debug, Eq, Ord, PartialEq, PartialOrd, Clone)]\npub struct Propietario {\n    pub nombre: String,\n    pub direccion: String,\n    pub telefono: u32,\n}\n\n#[derive(Debug, PartialEq)]\npub struct Veterinaria {\n    pub nombre: String,\n    pub direccion: String,\n    pub id: u32,\n    pub registro_atenciones: Vec\u003cAtencion\u003e,\n    pub cola_atencion: VecDeque\u003cMascota\u003e,\n    pub mascota_actual: Option\u003cMascota\u003e,\n}\n\n#[derive(Debug, Eq, Ord, PartialEq, PartialOrd, Clone)]\npub struct Mascota {\n    pub nombre: String,\n    pub edad: u8,\n    pub tipo_animal: TipoAnimal,\n    pub propietario: Propietario,\n}\n\nimpl Veterinaria {\n    pub fn new(nombre: String, direccion: String, id: u32) -\u003e Self {\n        Veterinaria {\n            nombre,\n            direccion,\n            id,\n            registro_atenciones: Vec::\u003cAtencion\u003e::new(),\n            cola_atencion: VecDeque::\u003cMascota\u003e::new(),\n            mascota_actual: None,\n        }\n    }\n\n    pub fn agregar_a_cola_de_atencion(\u0026mut self, mascota: Mascota) {\n        self.cola_atencion.push_back(mascota);\n    }\n\n    pub fn agregar_a_cola_de_atencion_prioridad(\u0026mut self, mascota: Mascota) {\n        self.cola_atencion.push_front(mascota);\n    }\n\n    pub fn atender_siguiente_mascota(\u0026mut self) {\n        self.mascota_actual = self.cola_atencion.pop_front();\n    }\n\n    pub fn eliminar_mascota_de_cola(\u0026mut self, mascota: Mascota) {\n        if let Some(pos) = self.cola_atencion.iter().position(|f| *f == mascota) {\n            self.cola_atencion.remove(pos);\n        }\n    }\n\n    pub fn registrar_atencion(\n        \u0026mut self,\n        diagnostico_final: String,\n        tratamiento: String,\n        fecha_proxima_visita: Option\u003cFecha\u003e,\n    ) {\n        if let Some(mascota) = \u0026self.mascota_actual {\n            self.registro_atenciones.push(Atencion {\n                mascota: mascota.to_owned(),\n                diagnostico_final,\n                tratamiento,\n                fecha_proxima_visita,\n            });\n        }\n    }\n\n    pub fn buscar_atencion(\n        \u0026self,\n        nombre_mascota: String,\n        nombre_propietario: String,\n        telefono: u32,\n    ) -\u003e Option\u003cAtencion\u003e {\n        if let Some(pos) = self.registro_atenciones.iter().position(|f| {\n            *f.mascota.nombre == nombre_mascota\n                \u0026\u0026 *f.mascota.propietario.nombre == nombre_propietario\n                \u0026\u0026 f.mascota.propietario.telefono == telefono\n        }) {\n            Some(self.registro_atenciones[pos].to_owned())\n        } else {\n            None\n        }\n    }\n\n    pub fn modificar_diagnostico(\u0026mut self, indice_atencion: usize, diagnostico_final: String) {\n        if let Some(atencion) = self.registro_atenciones.get_mut(indice_atencion) {\n            atencion.diagnostico_final = diagnostico_final;\n        }\n    }\n\n    pub fn modificar_fecha_proxima_visita(\u0026mut self, indice_atencion: usize, fecha: Option\u003cFecha\u003e) {\n        if let Some(atencion) = self.registro_atenciones.get_mut(indice_atencion) {\n            atencion.fecha_proxima_visita = fecha;\n        }\n    }\n\n    pub fn eliminar_atencion(\u0026mut self, indice_atencion: usize) {\n        if self.registro_atenciones.get(indice_atencion).is_some() {\n            self.registro_atenciones.remove(indice_atencion);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_nueva_veterinaria_correctamente() {\n        let vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        assert_eq!(\n            vete,\n            Veterinaria {\n                nombre: \"Vet01\".to_owned(),\n                direccion: \"44 n552\".to_owned(),\n                id: 32,\n                registro_atenciones: Vec::\u003cAtencion\u003e::new(),\n                cola_atencion: VecDeque::\u003cMascota\u003e::new(),\n                mascota_actual: None,\n            },\n            \"No se creo el objeto veterinaria como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn agregar_a_cola_de_atencion_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        assert!(\n            vete.cola_atencion.contains(\u0026mascota),\n            \"No se agrego la mascota a la cola de atencion como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn agregar_a_cola_de_atencion_prioridad_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        assert!(\n            vete.cola_atencion[0] == mascota_2,\n            \"No se agrego la mascota a la cola de atencion con prioridad como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn atender_siguiente_mascota_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.atender_siguiente_mascota();\n\n        assert!(\n            vete.cola_atencion[0] == mascota.clone(),\n            \"No se quito la mascota a la cola de atencion como se esperaba\"\n        );\n        assert!(\n            vete.mascota_actual == Some(mascota_2),\n            \"No se agrego la mascota como mascota actual como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn eliminar_mascota_de_cola_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.eliminar_mascota_de_cola(mascota);\n        assert!(\n            vete.cola_atencion.len() == 1,\n            \"No se elimino la mascota de la cola de atencion como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn registrar_atencion_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.atender_siguiente_mascota();\n        vete.registrar_atencion(\n            \"Mala alimentacion\".to_owned(),\n            \"Mejor alimento\".to_owned(),\n            Fecha::new(20, 06, 2025),\n        );\n        assert!(\n            vete.registro_atenciones.len() == 1,\n            \"No se registro una nueva atencion como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn buscar_atencion_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.atender_siguiente_mascota();\n        vete.registrar_atencion(\n            \"Mala alimentacion\".to_owned(),\n            \"Mejor alimento\".to_owned(),\n            Fecha::new(20, 06, 2025),\n        );\n        assert!(\n            vete.buscar_atencion(\"Picudo\".to_owned(), \"Pedro\".to_owned(), 726123)\n                .is_some(),\n            \"No se encontro la atencion guardada en el registro como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn modificar_diagnostico_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.atender_siguiente_mascota();\n        vete.registrar_atencion(\n            \"Mala alimentacion\".to_owned(),\n            \"Mejor alimento\".to_owned(),\n            Fecha::new(20, 06, 2025),\n        );\n        vete.modificar_diagnostico(0, \"Mal aliento\".to_owned());\n        assert!(\n            vete.buscar_atencion(\"Picudo\".to_owned(), \"Pedro\".to_owned(), 726123)\n                .unwrap()\n                .diagnostico_final\n                == \"Mal aliento\".to_owned(),\n            \"No se modifico el diagnostico en la atencion registrada como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn modificar_fecha_proxima_visita_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.atender_siguiente_mascota();\n        vete.registrar_atencion(\n            \"Mala alimentacion\".to_owned(),\n            \"Mejor alimento\".to_owned(),\n            Fecha::new(20, 06, 2025),\n        );\n        vete.modificar_fecha_proxima_visita(0, Fecha::new(20, 05, 2025));\n        assert!(\n            vete.buscar_atencion(\"Picudo\".to_owned(), \"Pedro\".to_owned(), 726123)\n                .unwrap()\n                .fecha_proxima_visita\n                == Fecha::new(20, 05, 2025),\n            \"No se modifico la fecha de proxima visita en la atencion registrada como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn eliminar_atencion_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.atender_siguiente_mascota();\n        vete.registrar_atencion(\n            \"Mala alimentacion\".to_owned(),\n            \"Mejor alimento\".to_owned(),\n            Fecha::new(20, 06, 2025),\n        );\n        vete.eliminar_atencion(0);\n        assert!(\n            vete.registro_atenciones.len() == 0,\n            \"No se elimino la atencion registrada como se esperaba\"\n        );\n    }\n}\n","traces":[{"line":46,"address":[846210,845856,846235],"length":1,"stats":{"Line":1}},{"line":51,"address":[845923],"length":1,"stats":{"Line":1}},{"line":52,"address":[845976],"length":1,"stats":{"Line":2}},{"line":57,"address":[846256],"length":1,"stats":{"Line":2}},{"line":58,"address":[846261],"length":1,"stats":{"Line":2}},{"line":61,"address":[846288],"length":1,"stats":{"Line":1}},{"line":62,"address":[846293],"length":1,"stats":{"Line":2}},{"line":65,"address":[846435,846320],"length":1,"stats":{"Line":1}},{"line":66,"address":[846465,846336],"length":1,"stats":{"Line":4}},{"line":69,"address":[846697,846496],"length":1,"stats":{"Line":1}},{"line":70,"address":[739401,739376],"length":1,"stats":{"Line":4}},{"line":71,"address":[846651,846690],"length":1,"stats":{"Line":2}},{"line":75,"address":[846720,847221,847301],"length":1,"stats":{"Line":1}},{"line":81,"address":[846761],"length":1,"stats":{"Line":2}},{"line":82,"address":[847017,846854],"length":1,"stats":{"Line":3}},{"line":83,"address":[846870],"length":1,"stats":{"Line":2}},{"line":84,"address":[846955],"length":1,"stats":{"Line":2}},{"line":85,"address":[846986],"length":1,"stats":{"Line":1}},{"line":91,"address":[847344,847794],"length":1,"stats":{"Line":1}},{"line":97,"address":[739424],"length":1,"stats":{"Line":3}},{"line":98,"address":[739461],"length":1,"stats":{"Line":1}},{"line":99,"address":[739501],"length":1,"stats":{"Line":1}},{"line":100,"address":[739546],"length":1,"stats":{"Line":1}},{"line":102,"address":[847630,847686],"length":1,"stats":{"Line":2}},{"line":104,"address":[847658],"length":1,"stats":{"Line":0}},{"line":108,"address":[848154,848180,847824],"length":1,"stats":{"Line":1}},{"line":109,"address":[847929,847851,848131],"length":1,"stats":{"Line":3}},{"line":110,"address":[848000,848051],"length":1,"stats":{"Line":1}},{"line":114,"address":[848192],"length":1,"stats":{"Line":1}},{"line":115,"address":[848219],"length":1,"stats":{"Line":1}},{"line":116,"address":[848289],"length":1,"stats":{"Line":1}},{"line":120,"address":[848304],"length":1,"stats":{"Line":1}},{"line":121,"address":[848336],"length":1,"stats":{"Line":1}},{"line":122,"address":[848397],"length":1,"stats":{"Line":1}}],"covered":33,"coverable":34},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","mod.rs"],"content":"pub mod ej1;\npub mod ej10;\npub mod ej2;\npub mod ej3;\npub mod ej4;\npub mod ej5;\npub mod ej6;\npub mod ej7;\npub mod ej8;\npub mod ej9;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp4","ej1.rs"],"content":"pub trait I32Primos {\n    fn es_primo(\u0026self) -\u003e bool;\n}\nimpl I32Primos for i32 {\n    fn es_primo(\u0026self) -\u003e bool {\n        if *self \u003c 2 {\n            return false;\n        }\n        if *self == 2 {\n            return true;\n        }\n        if *self % 2 == 0 {\n            return false;\n        }\n        let limite = (*self as f64).sqrt() as i32 + 1;\n        for i in (3..limite).step_by(2) {\n            if *self % i == 0 {\n                return false;\n            }\n        }\n        true\n    }\n}\n\npub fn cant_primos(vec: \u0026[i32]) -\u003e i32 {\n    vec.iter().filter(|\u0026\u0026e| e.es_primo()).count() as i32\n}\n\n#[test]\nfn verifica_cantidad_primos_correctamente() {\n    assert_eq!(cant_primos(\u0026[2, 3, 4, 5, 6, 7]), 4);\n}\n","traces":[{"line":5,"address":[639136],"length":1,"stats":{"Line":1}},{"line":6,"address":[639153],"length":1,"stats":{"Line":1}},{"line":7,"address":[639170],"length":1,"stats":{"Line":0}},{"line":9,"address":[639163],"length":1,"stats":{"Line":1}},{"line":10,"address":[639177],"length":1,"stats":{"Line":1}},{"line":12,"address":[639229,639189],"length":1,"stats":{"Line":2}},{"line":13,"address":[639260],"length":1,"stats":{"Line":1}},{"line":15,"address":[639410,639272],"length":1,"stats":{"Line":1}},{"line":16,"address":[639343,639426,639469],"length":1,"stats":{"Line":2}},{"line":17,"address":[639484],"length":1,"stats":{"Line":0}},{"line":18,"address":[639579],"length":1,"stats":{"Line":0}},{"line":21,"address":[639454],"length":1,"stats":{"Line":1}},{"line":25,"address":[639600],"length":1,"stats":{"Line":1}},{"line":26,"address":[639614],"length":1,"stats":{"Line":3}}],"covered":11,"coverable":14},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp4","ej2.rs"],"content":"#[derive(Debug, Clone)]\npub struct Persona\u003c'a\u003e {\n    nombre: \u0026'a str,\n    apellido: \u0026'a str,\n    direccion: \u0026'a str,\n    ciudad: \u0026'a str,\n    salario: f64,\n    edad: u8,\n}\n\nimpl\u003c'a\u003e PartialEq for Persona\u003c'a\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.nombre == other.nombre\n            \u0026\u0026 self.apellido == other.apellido\n            \u0026\u0026 self.ciudad == other.ciudad\n            \u0026\u0026 self.edad == other.edad\n            \u0026\u0026 self.direccion == other.direccion\n            \u0026\u0026 self.salario == other.salario\n    }\n}\n\npub fn con_salario_mayor\u003c'a\u003e(lista: Vec\u003cPersona\u003c'a\u003e\u003e, min: f64) -\u003e Vec\u003cPersona\u003c'a\u003e\u003e {\n    lista.into_iter().filter(|x| x.salario \u003e min).collect()\n}\n\npub fn edad_mayor_ciudad_igual\u003c'a\u003e(\n    lista: Vec\u003cPersona\u003c'a\u003e\u003e,\n    edad: u8,\n    ciudad: \u0026str,\n) -\u003e Vec\u003cPersona\u003c'a\u003e\u003e {\n    lista\n        .into_iter()\n        .filter(|e| (e.edad \u003e edad) \u0026\u0026 (e.ciudad == ciudad))\n        .collect()\n}\n\npub fn pertenecen_a_ciudad\u003c'a\u003e(lista: Vec\u003cPersona\u003c'a\u003e\u003e, ciudad: \u0026str) -\u003e bool {\n    lista.into_iter().all(|f| f.ciudad == ciudad)\n}\n\npub fn almenos_uno_pertenece\u003c'a\u003e(lista: Vec\u003cPersona\u003c'a\u003e\u003e, ciudad: \u0026str) -\u003e bool {\n    lista.into_iter().any(|f| f.ciudad == ciudad)\n}\n\npub fn existe_en_arreglo\u003c'a\u003e(lista: Vec\u003cPersona\u003c'a\u003e\u003e, persona: Persona\u003c'a\u003e) -\u003e bool {\n    lista.into_iter().find(|e| *e == persona).is_some()\n}\n\npub fn edades\u003c'a\u003e(lista: Vec\u003cPersona\u003c'a\u003e\u003e) -\u003e Vec\u003cu8\u003e {\n    let mut edades: Vec\u003cu8\u003e = Vec::new();\n    lista.into_iter().for_each(|f| edades.push(f.edad));\n    edades\n}\n\npub fn menor_mayor_salario\u003c'a\u003e(lista: Vec\u003cPersona\u003c'a\u003e\u003e) -\u003e Option\u003c(Persona\u003c'a\u003e, Persona\u003c'a\u003e)\u003e {\n    if lista.is_empty() {\n        return None;\n    }\n\n    let menor = lista\n        .iter()\n        .min_by(|a, b| {\n            a.salario\n                .partial_cmp(\u0026b.salario)\n                .unwrap_or(std::cmp::Ordering::Equal)\n                .then_with(|| b.edad.cmp(\u0026a.edad))\n        })\n        .map(|p| p.clone())?;\n\n    let mayor = lista\n        .iter()\n        .max_by(|a, b| {\n            a.salario\n                .partial_cmp(\u0026b.salario)\n                .unwrap_or(std::cmp::Ordering::Equal)\n                .then_with(|| a.edad.cmp(\u0026b.edad)) // mayor edad preferida\n        })\n        .map(|p| p.clone())?;\n\n    Some((menor, mayor))\n}\n\n#[test]\nfn verifica_salario_mayor() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"santiago del estero\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01, persona02.clone()]);\n    let lista_vacia = Vec::new();\n    assert_eq!(\n        con_salario_mayor(lista.clone(), 750_000.00),\n        [persona02.clone()],\n        \"Debería devolver la persona con salario superior al parámetro\"\n    );\n    assert_eq!(\n        con_salario_mayor(lista_vacia, 500_000.00),\n        [],\n        \"Debería devolver una lista vacía\"\n    );\n    assert_eq!(\n        con_salario_mayor(lista, 560_000.00),\n        [persona02],\n        \"Debería devolver solo la pesona con salario superior al parámetro\"\n    );\n}\n\n#[test]\nfn verifica_edad_mayor_ciudad_igual() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"santiago del estero\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01.clone(), persona02]);\n    let lista_vacia = Vec::new();\n    assert_eq!(\n        edad_mayor_ciudad_igual(lista, 21, \"twin peaks\"),\n        [persona01],\n        \"Debería devolver la persona con edad superior al parámetro y ciudad igual al parámetro\"\n    );\n    assert_eq!(\n        edad_mayor_ciudad_igual(lista_vacia, 35, \"Calle falsa 123\"),\n        [],\n        \"Debería devolver una lista vacía\"\n    );\n}\n\n#[test]\nfn verifica_pertenecen_a_ciudad() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"twin peaks\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01.clone(), persona02]);\n    let lista_vacia = Vec::new();\n    assert!(\n        pertenecen_a_ciudad(lista, \"twin peaks\"),\n        \"Debería devolver verdadero una lista con personas de la misma ciudad\"\n    );\n    assert!(\n        pertenecen_a_ciudad(lista_vacia, \"twin peaks\"),\n        \"Debería devolver falso a una lista vacía\"\n    );\n}\n\n#[test]\nfn verifica_almenos_uno_pertenece() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"santiago del estero\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01.clone(), persona02]);\n    let lista_vacia = Vec::new();\n    assert!(\n        almenos_uno_pertenece(lista, \"twin peaks\"),\n        \"Debería devolver verdadero una lista con una persona de la ciudad pasada por parámetro\"\n    );\n    assert!(\n        !almenos_uno_pertenece(lista_vacia, \"twin peaks\"),\n        \"Debería devolver falso a una lista vacía\"\n    );\n}\n\n#[test]\nfn verifica_existe_en_arreglo() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"santiago del estero\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01.clone(), persona02.clone()]);\n    let lista_vacia = Vec::new();\n    assert!(\n        existe_en_arreglo(lista, persona02),\n        \"Debería devolver verdadero una lista que contiene la persona pasada por parámetro\"\n    );\n    assert!(\n        !existe_en_arreglo(lista_vacia, persona01),\n        \"Debería devolver falso a una lista vacía\"\n    );\n}\n\n#[test]\nfn verifica_edades() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"santiago del estero\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01.clone(), persona02.clone()]);\n    let lista_vacia = Vec::new();\n    assert_eq!(\n        edades(lista),\n        [25, 35],\n        \"Debería devolver una lista con las edades de las personas en la lista\"\n    );\n    assert_eq!(\n        edades(lista_vacia),\n        Vec::\u003cu8\u003e::new(),\n        \"Debería devolver una lista vacía\"\n    );\n}\n\n#[test]\nfn verifica_mayor_menor_salario() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"santiago del estero\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01.clone(), persona02.clone()]);\n    let lista_vacia = Vec::new();\n    assert_eq!(\n        menor_mayor_salario(lista),\n        Some((persona01.clone(), persona02.clone())),\n        \"Debería devolver Some de una tupla con las personas de menor y mayor salario\"\n    );\n    assert_eq!(\n        menor_mayor_salario(lista_vacia),\n        None,\n        \"Debería devolver None\"\n    );\n}\n","traces":[{"line":12,"address":[576432],"length":1,"stats":{"Line":1}},{"line":13,"address":[576455],"length":1,"stats":{"Line":1}},{"line":14,"address":[576484],"length":1,"stats":{"Line":1}},{"line":15,"address":[576513],"length":1,"stats":{"Line":1}},{"line":16,"address":[576542],"length":1,"stats":{"Line":1}},{"line":17,"address":[576559],"length":1,"stats":{"Line":1}},{"line":18,"address":[576588],"length":1,"stats":{"Line":1}},{"line":22,"address":[576624],"length":1,"stats":{"Line":1}},{"line":23,"address":[576644],"length":1,"stats":{"Line":3}},{"line":26,"address":[576704],"length":1,"stats":{"Line":1}},{"line":31,"address":[576733],"length":1,"stats":{"Line":1}},{"line":33,"address":[956384,956407],"length":1,"stats":{"Line":2}},{"line":37,"address":[576800,576905],"length":1,"stats":{"Line":1}},{"line":38,"address":[576830],"length":1,"stats":{"Line":3}},{"line":41,"address":[576928,577033],"length":1,"stats":{"Line":1}},{"line":42,"address":[576958],"length":1,"stats":{"Line":3}},{"line":45,"address":[577056,577185],"length":1,"stats":{"Line":1}},{"line":46,"address":[577084],"length":1,"stats":{"Line":3}},{"line":49,"address":[577216,577437],"length":1,"stats":{"Line":1}},{"line":50,"address":[577237],"length":1,"stats":{"Line":1}},{"line":51,"address":[577386,577302],"length":1,"stats":{"Line":4}},{"line":52,"address":[577403],"length":1,"stats":{"Line":1}},{"line":55,"address":[577472,578105],"length":1,"stats":{"Line":1}},{"line":56,"address":[577502,577554],"length":1,"stats":{"Line":2}},{"line":57,"address":[577587],"length":1,"stats":{"Line":1}},{"line":60,"address":[578103,577565,577609,577818],"length":1,"stats":{"Line":2}},{"line":62,"address":[956640],"length":1,"stats":{"Line":1}},{"line":63,"address":[956683,956722,956669,956693],"length":1,"stats":{"Line":4}},{"line":64,"address":[956676],"length":1,"stats":{"Line":1}},{"line":65,"address":[956688],"length":1,"stats":{"Line":1}},{"line":66,"address":[956750,956716,956736],"length":1,"stats":{"Line":1}},{"line":68,"address":[956784,956800],"length":1,"stats":{"Line":2}},{"line":70,"address":[578069,577796,577838,578089],"length":1,"stats":{"Line":2}},{"line":72,"address":[956816],"length":1,"stats":{"Line":1}},{"line":73,"address":[956898,956859,956845,956869],"length":1,"stats":{"Line":4}},{"line":74,"address":[956852],"length":1,"stats":{"Line":1}},{"line":75,"address":[956864],"length":1,"stats":{"Line":1}},{"line":76,"address":[956892,956912,956926],"length":1,"stats":{"Line":1}},{"line":78,"address":[956976,956960],"length":1,"stats":{"Line":2}},{"line":80,"address":[577973],"length":1,"stats":{"Line":1}}],"covered":40,"coverable":40},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp4","ej3.rs"],"content":"use std::collections::HashMap;\nuse time::{Date, OffsetDateTime};\n\nstruct App {\n    usuarios: Vec\u003cUsuario\u003e,\n    estadisticas: Estadisticas,\n}\n\nimpl App {\n    pub fn new() -\u003e Self {\n        App {\n            usuarios: Vec::new(),\n            estadisticas: Estadisticas {\n                medio_de_pago_mas_utilizado_subs_activas: None,\n                subscripcion_mas_contratada_subs_activas: None,\n                medio_de_pago_mas_utilizado: None,\n                subscripcion_mas_contratada: None,\n                total_medio_de_pago: HashMap::new(),\n                total_subscripcion: HashMap::new(),\n            },\n        }\n    }\n\n    pub fn create_user(\u0026mut self, subscripcion: Subscripcion, medio_de_pago: MedioDePago) {\n        if let Some(tipo) = subscripcion.tipo {\n            *self\n                .estadisticas\n                .total_subscripcion\n                .entry(tipo)\n                .or_insert(0) += 1;\n        }\n\n        *self\n            .estadisticas\n            .total_medio_de_pago\n            .entry(TipoMedioDePago::from(\u0026medio_de_pago))\n            .or_insert(0) += 1;\n\n        let user = Usuario::new(medio_de_pago, subscripcion);\n        self.usuarios.push(user);\n    }\n\n    pub fn cancel_subscripcion(\u0026mut self, usuario: \u0026Usuario) {\n        if let Some(user) = self.usuarios.iter_mut().find(|x| **x == *usuario) {\n            user.cancel_subscripcion();\n        }\n    }\n\n    pub fn update_stats(\u0026mut self) {\n        let mut med_pago_subs_act: HashMap\u003cTipoMedioDePago, u32\u003e = HashMap::new();\n        let mut sub_mas_cont_subs_act: HashMap\u003cTipoSubscripcion, u32\u003e = HashMap::new();\n\n        for usuario in \u0026self.usuarios {\n            if usuario\n                .subscripcion\n                .last()\n                .expect(\"expected sub\")\n                .tipo\n                .is_some()\n            {\n                if let Some(tipo) = \u0026usuario.subscripcion.last().expect(\"expected sub\").tipo {\n                    *sub_mas_cont_subs_act.entry(*tipo).or_insert(0) += 1;\n                }\n                let tipo_pago = TipoMedioDePago::from(\u0026usuario.medio_de_pago);\n                *med_pago_subs_act.entry(tipo_pago).or_insert(0) += 1;\n            }\n        }\n\n        self.estadisticas.subscripcion_mas_contratada = self\n            .estadisticas\n            .total_subscripcion\n            .clone()\n            .into_iter()\n            .max_by_key(|(_, v)| *v)\n            .map(|(k, _)| k);\n\n        self.estadisticas.medio_de_pago_mas_utilizado = self\n            .estadisticas\n            .total_medio_de_pago\n            .clone()\n            .into_iter()\n            .max_by_key(|(_, v)| *v)\n            .map(|(k, _)| k);\n\n        self.estadisticas.subscripcion_mas_contratada_subs_activas = sub_mas_cont_subs_act\n            .into_iter()\n            .max_by_key(|(_, v)| *v)\n            .map(|(k, _)| k);\n\n        self.estadisticas.medio_de_pago_mas_utilizado_subs_activas = med_pago_subs_act\n            .into_iter()\n            .max_by_key(|(_, v)| *v)\n            .map(|(k, _)| k);\n    }\n}\n\nstruct Estadisticas {\n    medio_de_pago_mas_utilizado_subs_activas: Option\u003cTipoMedioDePago\u003e,\n    subscripcion_mas_contratada_subs_activas: Option\u003cTipoSubscripcion\u003e,\n    medio_de_pago_mas_utilizado: Option\u003cTipoMedioDePago\u003e,\n    subscripcion_mas_contratada: Option\u003cTipoSubscripcion\u003e,\n    total_medio_de_pago: HashMap\u003cTipoMedioDePago, u32\u003e,\n    total_subscripcion: HashMap\u003cTipoSubscripcion, u32\u003e,\n}\n\n#[derive(Eq, Hash, Copy, Clone, Debug)]\nenum TipoSubscripcion {\n    Basic,\n    Clasic,\n    Super,\n}\n\nimpl TipoSubscripcion {\n    pub fn config(\u0026self) -\u003e (f64, u8) {\n        match self {\n            TipoSubscripcion::Basic =\u003e (5.0, 3),\n            TipoSubscripcion::Clasic =\u003e (15.0, 12),\n            TipoSubscripcion::Super =\u003e (25.0, 24),\n        }\n    }\n}\n\nimpl PartialEq for TipoSubscripcion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        core::mem::discriminant(self) == core::mem::discriminant(other)\n    }\n}\n\n#[derive(Eq, PartialEq, Hash, Debug, Clone)]\nenum TipoMedioDePago {\n    Efectivo,\n    MercadoPago,\n    TarjetaCredito,\n    Transferencia,\n    Cripto,\n}\n\nimpl From\u003c\u0026MedioDePago\u003e for TipoMedioDePago {\n    fn from(m: \u0026MedioDePago) -\u003e Self {\n        match m {\n            MedioDePago::Efectivo =\u003e TipoMedioDePago::Efectivo,\n            MedioDePago::MercadoPago { .. } =\u003e TipoMedioDePago::MercadoPago,\n            MedioDePago::TarjetaCredito { .. } =\u003e TipoMedioDePago::TarjetaCredito,\n            MedioDePago::Transferencia { .. } =\u003e TipoMedioDePago::Transferencia,\n            MedioDePago::Cripto { .. } =\u003e TipoMedioDePago::Cripto,\n        }\n    }\n}\n\n#[derive(Hash, Debug)]\nenum MedioDePago {\n    Efectivo,\n    MercadoPago {\n        cuentamp: String,\n        cbu: String,\n    },\n    TarjetaCredito {\n        numero_tarjeta: u64,\n        numero_seguridad: u32,\n        nombre_titular: String,\n    },\n    Transferencia {\n        numero_cuenta: u64,\n        nombre_titular: String,\n        entidad_bancaria: String,\n    },\n    Cripto {\n        wallet: String,\n        red: String,\n        tipo_token: Option\u003cString\u003e,\n        tx_hash: Option\u003cString\u003e,\n    },\n}\n\nimpl PartialEq for MedioDePago {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (\n                Self::MercadoPago {\n                    cuentamp: l_cuentamp,\n                    cbu: l_cbu,\n                },\n                Self::MercadoPago {\n                    cuentamp: r_cuentamp,\n                    cbu: r_cbu,\n                },\n            ) =\u003e l_cuentamp == r_cuentamp \u0026\u0026 l_cbu == r_cbu,\n            (\n                Self::TarjetaCredito {\n                    numero_tarjeta: l_numero_tarjeta,\n                    numero_seguridad: l_numero_seguridad,\n                    nombre_titular: l_nombre_titular,\n                },\n                Self::TarjetaCredito {\n                    numero_tarjeta: r_numero_tarjeta,\n                    numero_seguridad: r_numero_seguridad,\n                    nombre_titular: r_nombre_titular,\n                },\n            ) =\u003e {\n                l_numero_tarjeta == r_numero_tarjeta\n                    \u0026\u0026 l_numero_seguridad == r_numero_seguridad\n                    \u0026\u0026 l_nombre_titular == r_nombre_titular\n            }\n            (\n                Self::Transferencia {\n                    numero_cuenta: l_numero_cuenta,\n                    nombre_titular: l_nombre_titular,\n                    entidad_bancaria: l_entidad_bancaria,\n                },\n                Self::Transferencia {\n                    numero_cuenta: r_numero_cuenta,\n                    nombre_titular: r_nombre_titular,\n                    entidad_bancaria: r_entidad_bancaria,\n                },\n            ) =\u003e {\n                l_numero_cuenta == r_numero_cuenta\n                    \u0026\u0026 l_nombre_titular == r_nombre_titular\n                    \u0026\u0026 l_entidad_bancaria == r_entidad_bancaria\n            }\n            (\n                Self::Cripto {\n                    wallet: l_wallet,\n                    red: l_red,\n                    tipo_token: l_tipo_token,\n                    tx_hash: l_tx_hash,\n                },\n                Self::Cripto {\n                    wallet: r_wallet,\n                    red: r_red,\n                    tipo_token: r_tipo_token,\n                    tx_hash: r_tx_hash,\n                },\n            ) =\u003e {\n                l_wallet == r_wallet\n                    \u0026\u0026 l_red == r_red\n                    \u0026\u0026 l_tipo_token == r_tipo_token\n                    \u0026\u0026 l_tx_hash == r_tx_hash\n            }\n            _ =\u003e core::mem::discriminant(self) == core::mem::discriminant(other),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct Subscripcion {\n    fecha_inicio: Date,\n    costo_mensual: f64,\n    duracion: u8,\n    tipo: Option\u003cTipoSubscripcion\u003e,\n    activa: bool,\n}\n\nimpl Subscripcion {\n    pub fn new(tipo: Option\u003cTipoSubscripcion\u003e) -\u003e Self {\n        let fecha_inicio = OffsetDateTime::now_utc().date();\n        let activa = tipo.is_some();\n        let (costo_mensual, duracion) = match \u0026tipo {\n            Some(tipo) =\u003e tipo.config(),\n            None =\u003e (0.0, 0),\n        };\n\n        Subscripcion {\n            fecha_inicio,\n            costo_mensual,\n            duracion,\n            tipo,\n            activa,\n        }\n    }\n}\n\nimpl PartialEq for Subscripcion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.fecha_inicio == other.fecha_inicio\n            \u0026\u0026 self.costo_mensual == other.costo_mensual\n            \u0026\u0026 self.duracion == other.duracion\n            \u0026\u0026 self.tipo == other.tipo\n    }\n}\n\n#[derive(Debug)]\nstruct Usuario {\n    subscripcion: Vec\u003cSubscripcion\u003e,\n    medio_de_pago: MedioDePago,\n}\n\nimpl PartialEq for Usuario {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.subscripcion == other.subscripcion \u0026\u0026 self.medio_de_pago == other.medio_de_pago\n    }\n}\n\nimpl Usuario {\n    fn new(medio_de_pago: MedioDePago, subscripcion: Subscripcion) -\u003e Self {\n        Usuario {\n            subscripcion: vec![subscripcion],\n            medio_de_pago,\n        }\n    }\n\n    fn upgrade_sub(\u0026mut self) {\n        if let Some(subscripcion) = self.subscripcion.last_mut() {\n            match subscripcion.tipo {\n                Some(TipoSubscripcion::Basic) =\u003e {\n                    subscripcion.activa = false;\n                    self.subscripcion\n                        .push(Subscripcion::new(Some(TipoSubscripcion::Clasic)));\n                }\n                Some(TipoSubscripcion::Clasic) =\u003e {\n                    subscripcion.activa = false;\n                    self.subscripcion\n                        .push(Subscripcion::new(Some(TipoSubscripcion::Super)));\n                }\n                Some(TipoSubscripcion::Super) =\u003e (),\n                None =\u003e self\n                    .subscripcion\n                    .push(Subscripcion::new(Some(TipoSubscripcion::Basic))),\n            }\n        }\n    }\n\n    fn downgrade_sub(\u0026mut self) {\n        if let Some(subscripcion) = self.subscripcion.last_mut() {\n            match subscripcion.tipo {\n                Some(TipoSubscripcion::Basic) =\u003e {\n                    self.cancel_subscripcion();\n                }\n                Some(TipoSubscripcion::Clasic) =\u003e {\n                    subscripcion.activa = false;\n                    self.subscripcion\n                        .push(Subscripcion::new(Some(TipoSubscripcion::Basic)));\n                }\n                Some(TipoSubscripcion::Super) =\u003e subscripcion.tipo = Some(TipoSubscripcion::Clasic),\n                None =\u003e (),\n            }\n        }\n    }\n\n    fn cancel_subscripcion(\u0026mut self) {\n        if let Some(sub) = self.subscripcion.last_mut() {\n            sub.activa = false;\n            self.subscripcion.push(Subscripcion::new(None));\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn build_fecha() -\u003e Date {\n        OffsetDateTime::now_utc().date()\n    }\n\n    fn build_subscripcion_basic() -\u003e Subscripcion {\n        Subscripcion::new(Some(TipoSubscripcion::Basic))\n    }\n\n    fn build_subscripcion_clasic() -\u003e Subscripcion {\n        Subscripcion::new(Some(TipoSubscripcion::Clasic))\n    }\n\n    fn build_subscripcion_super() -\u003e Subscripcion {\n        Subscripcion::new(Some(TipoSubscripcion::Super))\n    }\n\n    fn build_medio_de_pago_mp() -\u003e MedioDePago {\n        MedioDePago::MercadoPago {\n            cuentamp: \"datosfalsos123\".to_owned(),\n            cbu: \"12345678910111213\".to_owned(),\n        }\n    }\n\n    fn build_medio_de_pago_cripto() -\u003e MedioDePago {\n        MedioDePago::Cripto {\n            wallet: \"datosfalsos123\".to_owned(),\n            red: \"eth\".to_owned(),\n            tipo_token: Some(\"ethereum\".to_owned()),\n            tx_hash: None,\n        }\n    }\n\n    fn build_medio_de_pago_tarjeta() -\u003e MedioDePago {\n        MedioDePago::TarjetaCredito {\n            numero_tarjeta: 123456789101112,\n            numero_seguridad: 1234,\n            nombre_titular: \"john doe\".to_owned(),\n        }\n    }\n\n    fn build_usuario_basic() -\u003e Usuario {\n        Usuario::new(MedioDePago::Efectivo, build_subscripcion_basic())\n    }\n\n    fn build_usuario_super() -\u003e Usuario {\n        Usuario::new(MedioDePago::Efectivo, build_subscripcion_super())\n    }\n\n    #[test]\n    fn verifica_crear_usuario() {\n        let mut app = App::new();\n\n        let sub = build_subscripcion_basic();\n        let expect = build_usuario_basic();\n\n        app.create_user(build_subscripcion_basic(), MedioDePago::Efectivo);\n\n        assert_eq!(app.usuarios.len(), 1);\n        assert_eq!(app.usuarios[0], expect);\n        assert_eq!(app.usuarios[0].subscripcion.last(), Some(sub).as_ref());\n        assert_eq!(app.usuarios[0].medio_de_pago, MedioDePago::Efectivo);\n    }\n\n    #[test]\n    fn verifica_cancelar_subscripcion() {\n        let mut app = App::new();\n        let usuario = build_usuario_basic();\n\n        app.create_user(build_subscripcion_basic(), MedioDePago::Efectivo);\n        assert_eq!(app.usuarios.len(), 1);\n\n        app.cancel_subscripcion(\u0026usuario);\n        assert_eq!(\n            app.usuarios[0]\n                .subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            None\n        );\n    }\n\n    #[test]\n    fn verifica_upgrade_subscripcion() {\n        let mut user = build_usuario_basic();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            Some(TipoSubscripcion::Basic)\n        );\n        user.upgrade_sub();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            Some(TipoSubscripcion::Clasic)\n        );\n        user.upgrade_sub();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            Some(TipoSubscripcion::Super)\n        );\n    }\n\n    #[test]\n    fn verifica_downgrade_subscripcion() {\n        let mut user = build_usuario_super();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            Some(TipoSubscripcion::Super)\n        );\n        user.downgrade_sub();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            Some(TipoSubscripcion::Clasic)\n        );\n        user.downgrade_sub();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            Some(TipoSubscripcion::Basic)\n        );\n        user.downgrade_sub();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            None\n        );\n    }\n\n    #[test]\n    fn verifica_datos_estadisticos() {\n        let mut app = App::new();\n\n        app.create_user(build_subscripcion_basic(), MedioDePago::Efectivo);\n        app.create_user(build_subscripcion_basic(), build_medio_de_pago_tarjeta());\n        app.create_user(build_subscripcion_basic(), build_medio_de_pago_tarjeta());\n        app.create_user(build_subscripcion_clasic(), MedioDePago::Efectivo);\n        app.create_user(build_subscripcion_basic(), build_medio_de_pago_tarjeta());\n        app.create_user(build_subscripcion_clasic(), build_medio_de_pago_mp());\n        app.create_user(build_subscripcion_clasic(), build_medio_de_pago_cripto());\n        app.usuarios[1].cancel_subscripcion();\n        app.usuarios[2].cancel_subscripcion();\n\n        app.update_stats();\n        assert_eq!(\n            app.estadisticas.medio_de_pago_mas_utilizado,\n            Some(TipoMedioDePago::TarjetaCredito)\n        );\n        assert_eq!(\n            app.estadisticas.medio_de_pago_mas_utilizado_subs_activas,\n            Some(TipoMedioDePago::Efectivo)\n        );\n        assert_eq!(\n            app.estadisticas.subscripcion_mas_contratada,\n            Some(TipoSubscripcion::Basic)\n        );\n        assert_eq!(\n            app.estadisticas.subscripcion_mas_contratada_subs_activas,\n            Some(TipoSubscripcion::Clasic)\n        );\n    }\n}\n","traces":[{"line":10,"address":[1050858,1050528],"length":1,"stats":{"Line":1}},{"line":12,"address":[1050549],"length":1,"stats":{"Line":1}},{"line":13,"address":[1050690],"length":1,"stats":{"Line":1}},{"line":24,"address":[1051363,1050880,1051388],"length":1,"stats":{"Line":1}},{"line":25,"address":[1050910,1050961,1051106],"length":1,"stats":{"Line":4}},{"line":26,"address":[1050970,1051064,1051108,1050957],"length":1,"stats":{"Line":3}},{"line":33,"address":[1050996,1051137,1051310],"length":1,"stats":{"Line":3}},{"line":36,"address":[1051005],"length":1,"stats":{"Line":1}},{"line":39,"address":[1051211],"length":1,"stats":{"Line":2}},{"line":40,"address":[1051336],"length":1,"stats":{"Line":1}},{"line":43,"address":[1051408],"length":1,"stats":{"Line":1}},{"line":44,"address":[811201,811184],"length":1,"stats":{"Line":3}},{"line":45,"address":[1051507],"length":1,"stats":{"Line":1}},{"line":49,"address":[1051520,1052894],"length":1,"stats":{"Line":1}},{"line":50,"address":[1051543],"length":1,"stats":{"Line":1}},{"line":51,"address":[1051588],"length":1,"stats":{"Line":1}},{"line":53,"address":[1051644,1051729,1051840],"length":1,"stats":{"Line":3}},{"line":54,"address":[1052853,1052426,1051864],"length":1,"stats":{"Line":3}},{"line":61,"address":[1052515,1052742],"length":1,"stats":{"Line":2}},{"line":62,"address":[1052700,1052744,1052641],"length":1,"stats":{"Line":2}},{"line":64,"address":[1052675,1052768],"length":1,"stats":{"Line":2}},{"line":65,"address":[1052775,1052858],"length":1,"stats":{"Line":1}},{"line":69,"address":[1051906,1051821],"length":1,"stats":{"Line":2}},{"line":74,"address":[811242,811232],"length":1,"stats":{"Line":2}},{"line":75,"address":[811264,811275],"length":1,"stats":{"Line":2}},{"line":77,"address":[1052006],"length":1,"stats":{"Line":1}},{"line":82,"address":[811290,811280],"length":1,"stats":{"Line":2}},{"line":83,"address":[811323,811312],"length":1,"stats":{"Line":2}},{"line":85,"address":[1052108],"length":1,"stats":{"Line":1}},{"line":87,"address":[811328,811338],"length":1,"stats":{"Line":2}},{"line":88,"address":[811371,811360],"length":1,"stats":{"Line":2}},{"line":90,"address":[1052247],"length":1,"stats":{"Line":1}},{"line":92,"address":[811376,811386],"length":1,"stats":{"Line":2}},{"line":93,"address":[811419,811408],"length":1,"stats":{"Line":2}},{"line":114,"address":[1052944],"length":1,"stats":{"Line":1}},{"line":115,"address":[1052949],"length":1,"stats":{"Line":1}},{"line":116,"address":[1052981],"length":1,"stats":{"Line":1}},{"line":117,"address":[1053002],"length":1,"stats":{"Line":1}},{"line":118,"address":[1053023],"length":1,"stats":{"Line":1}},{"line":124,"address":[1053056],"length":1,"stats":{"Line":1}},{"line":125,"address":[1053074],"length":1,"stats":{"Line":1}},{"line":139,"address":[1053120],"length":1,"stats":{"Line":2}},{"line":140,"address":[1053125],"length":1,"stats":{"Line":2}},{"line":141,"address":[1053185],"length":1,"stats":{"Line":2}},{"line":142,"address":[1053192],"length":1,"stats":{"Line":1}},{"line":143,"address":[1053199],"length":1,"stats":{"Line":1}},{"line":144,"address":[1053206],"length":1,"stats":{"Line":0}},{"line":145,"address":[1053213],"length":1,"stats":{"Line":1}},{"line":176,"address":[1053338,1053232],"length":1,"stats":{"Line":1}},{"line":177,"address":[1053265,1053340],"length":1,"stats":{"Line":2}},{"line":178,"address":[1053618],"length":1,"stats":{"Line":0}},{"line":188,"address":[1053723],"length":1,"stats":{"Line":0}},{"line":200,"address":[1053796],"length":1,"stats":{"Line":0}},{"line":201,"address":[1053823],"length":1,"stats":{"Line":0}},{"line":202,"address":[1053845],"length":1,"stats":{"Line":0}},{"line":204,"address":[1053943],"length":1,"stats":{"Line":0}},{"line":216,"address":[1053977],"length":1,"stats":{"Line":0}},{"line":217,"address":[1054013],"length":1,"stats":{"Line":0}},{"line":218,"address":[1054041],"length":1,"stats":{"Line":0}},{"line":220,"address":[1054151],"length":1,"stats":{"Line":0}},{"line":234,"address":[1054202],"length":1,"stats":{"Line":0}},{"line":235,"address":[1054238],"length":1,"stats":{"Line":0}},{"line":236,"address":[1054266],"length":1,"stats":{"Line":0}},{"line":237,"address":[1054293],"length":1,"stats":{"Line":0}},{"line":239,"address":[1053530],"length":1,"stats":{"Line":2}},{"line":254,"address":[1054336],"length":1,"stats":{"Line":1}},{"line":255,"address":[1054356],"length":1,"stats":{"Line":1}},{"line":256,"address":[1054386],"length":1,"stats":{"Line":1}},{"line":257,"address":[1054406,1054491],"length":1,"stats":{"Line":2}},{"line":258,"address":[1054444],"length":1,"stats":{"Line":1}},{"line":259,"address":[1054428],"length":1,"stats":{"Line":2}},{"line":273,"address":[1054544],"length":1,"stats":{"Line":1}},{"line":274,"address":[1054567],"length":1,"stats":{"Line":1}},{"line":275,"address":[1054600],"length":1,"stats":{"Line":1}},{"line":276,"address":[1054621],"length":1,"stats":{"Line":1}},{"line":277,"address":[1054638],"length":1,"stats":{"Line":1}},{"line":288,"address":[1054672],"length":1,"stats":{"Line":1}},{"line":289,"address":[1054695],"length":1,"stats":{"Line":1}},{"line":294,"address":[1055033,1054752],"length":1,"stats":{"Line":1}},{"line":296,"address":[1054789,1054843],"length":1,"stats":{"Line":2}},{"line":301,"address":[1055056],"length":1,"stats":{"Line":1}},{"line":302,"address":[1055070],"length":1,"stats":{"Line":1}},{"line":303,"address":[1055217,1055132],"length":1,"stats":{"Line":2}},{"line":305,"address":[1055253],"length":1,"stats":{"Line":1}},{"line":306,"address":[1055290],"length":1,"stats":{"Line":1}},{"line":307,"address":[1055257],"length":1,"stats":{"Line":1}},{"line":310,"address":[1055317],"length":1,"stats":{"Line":1}},{"line":311,"address":[1055354],"length":1,"stats":{"Line":1}},{"line":312,"address":[1055321],"length":1,"stats":{"Line":1}},{"line":315,"address":[1055193],"length":1,"stats":{"Line":0}},{"line":317,"address":[1055160],"length":1,"stats":{"Line":0}},{"line":322,"address":[1055376],"length":1,"stats":{"Line":1}},{"line":323,"address":[1055390],"length":1,"stats":{"Line":1}},{"line":324,"address":[1055452,1055483],"length":1,"stats":{"Line":2}},{"line":326,"address":[1055519],"length":1,"stats":{"Line":1}},{"line":329,"address":[1055531],"length":1,"stats":{"Line":1}},{"line":330,"address":[1055568],"length":1,"stats":{"Line":1}},{"line":331,"address":[1055535],"length":1,"stats":{"Line":1}},{"line":333,"address":[1055592],"length":1,"stats":{"Line":1}},{"line":339,"address":[1055632],"length":1,"stats":{"Line":1}},{"line":340,"address":[1055645],"length":1,"stats":{"Line":1}},{"line":341,"address":[1055702],"length":1,"stats":{"Line":1}},{"line":342,"address":[1055706],"length":1,"stats":{"Line":1}}],"covered":86,"coverable":103},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp4","ej4.rs"],"content":"use std::collections::HashMap;\nuse time::Date;\n\nenum MedioDePago {\n    TarjetaCredito,\n    TarjetaDebito,\n    Transferencia,\n    Efectivo,\n}\n\nstruct DatosPersonales {\n    nombre: String,\n    apellido: String,\n    direccion: String,\n    dni: String,\n}\n\nstruct Vendedor {\n    datos_personales: DatosPersonales,\n    legajo: String,\n    antiguedad: u32,\n    salario: f64,\n}\n\nstruct Cliente {\n    datos_personales: DatosPersonales,\n    subscripcion: Option\u003cString\u003e,\n}\n\nimpl Cliente {\n    pub fn esta_subscripto(\u0026self) -\u003e bool {\n        self.subscripcion != None\n    }\n}\n\nstruct Producto {\n    nombre: String,\n    categoria: String,\n    precio_base: f64,\n}\n\nstruct Venta {\n    fecha: Date,\n    productos: Vec\u003c(Producto, u32)\u003e,\n    vendedor: Vendedor,\n    cliente: Cliente,\n    medio_de_pago: MedioDePago,\n}\n\nimpl Venta {\n    fn calcular_precio_final(\n        \u0026self,\n        descuento_newsletter: f64,\n        categorias: HashMap\u003cString, f64\u003e,\n    ) -\u003e f64 {\n        let mut precio_final: f64 = 0.0;\n        self.productos.iter().for_each(|f| {\n            if let Some(descuento) = categorias.get(\u0026f.0.categoria) {\n                precio_final += (f.0.precio_base * (1.0 - (descuento / 100.00))) * (f.1 as f64); // precio base - descuento de categoria (si aplica)\n            } else {\n                precio_final += f.0.precio_base * (f.1 as f64);\n            };\n\n            if self.cliente.esta_subscripto() {\n                precio_final = precio_final * (1.0 - (descuento_newsletter / 100.00)); // precio parcial - descuento por newsletter (si aplica)\n            };\n        });\n        precio_final\n    }\n}\n\nstruct App {\n    ventas: Vec\u003cVenta\u003e,\n    categorias: HashMap\u003cString, u32\u003e, // nombre de categoria y % de descuento\n    descuento_newsletter: u32,\n}\n\nimpl App {\n    pub fn new() -\u003e Self {\n        App {\n            ventas: Vec::new(),\n            categorias: HashMap::new(),\n            descuento_newsletter: 0,\n        }\n    }\n\n    pub fn set_descuento_newsletter(\u0026mut self, descuento: u32) {\n        self.descuento_newsletter = descuento;\n    }\n\n    pub fn agregar_venta(\u0026mut self, venta: Venta) {\n        self.ventas.push(venta);\n    }\n\n    pub fn generar_reporte_categorias(\u0026self) -\u003e String {\n        if self.ventas.is_empty() {\n            return \"No hay ventas registradas.\".to_owned();\n        }\n\n        let mut totales_por_categoria: HashMap\u003cString, u32\u003e = HashMap::new();\n        for venta in \u0026self.ventas {\n            for (producto, cant) in \u0026venta.productos {\n                totales_por_categoria\n                    .entry(producto.categoria.clone())\n                    .and_modify(|c| *c += *cant)\n                    .or_insert(*cant);\n            }\n        }\n\n        let mut categorias_ordenadas: Vec\u003c(\u0026String, \u0026u32)\u003e = totales_por_categoria.iter().collect();\n        categorias_ordenadas.sort_by_key(|(cat, _)| cat.to_owned());\n\n        let mut report: String = String::new();\n        for (categoria, cant) in categorias_ordenadas {\n            report.push_str(\u0026format!(\"{}: {}; \", categoria, cant));\n        }\n        report.trim().to_owned()\n    }\n\n    pub fn generar_reporte_vendedor(\u0026self) -\u003e String {\n        if self.ventas.is_empty() {\n            return \"No hay ventas registradas.\".to_owned();\n        }\n        let mut totales_por_vendedor: HashMap\u003cString, u32\u003e = HashMap::new();\n        for venta in \u0026self.ventas {\n            totales_por_vendedor\n                .entry(venta.vendedor.legajo.clone())\n                .and_modify(|c| *c += 1)\n                .or_insert(1);\n        }\n\n        let mut legajos_ordenados: Vec\u003c(\u0026String, \u0026u32)\u003e = totales_por_vendedor.iter().collect();\n        legajos_ordenados.sort_by_key(|(cat, _)| cat.to_owned());\n\n        let mut report = String::new();\n        for (legajo, cantidad) in legajos_ordenados {\n            report.push_str(\u0026format!(\"{}: {}; \", legajo, cantidad));\n        }\n        report.trim().to_owned()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn build_fecha() -\u003e Date {\n        Date::from_julian_day(2_458_485).expect(\"deberia devolver una fecha\")\n    }\n\n    fn build_datos_personales() -\u003e DatosPersonales {\n        DatosPersonales {\n            nombre: \"name\".to_owned(),\n            apellido: \"lastname\".to_owned(),\n            direccion: \"calle falsa 123\".to_owned(),\n            dni: \"12345678910\".to_owned(),\n        }\n    }\n\n    fn build_vendendor() -\u003e Vendedor {\n        Vendedor {\n            datos_personales: build_datos_personales(),\n            legajo: \"271826/2\".to_owned(),\n            antiguedad: 12,\n            salario: 800000.00,\n        }\n    }\n\n    fn build_vendendor_con_legajo(legajo: String) -\u003e Vendedor {\n        Vendedor {\n            datos_personales: build_datos_personales(),\n            legajo,\n            antiguedad: 12,\n            salario: 800000.00,\n        }\n    }\n\n    fn build_cliente_con_sub() -\u003e Cliente {\n        Cliente {\n            datos_personales: build_datos_personales(),\n            subscripcion: Some(\"false@mail.com\".to_owned()),\n        }\n    }\n\n    fn build_cliente_sin_sub() -\u003e Cliente {\n        Cliente {\n            datos_personales: build_datos_personales(),\n            subscripcion: None,\n        }\n    }\n\n    fn build_producto_cat01() -\u003e Producto {\n        Producto {\n            nombre: \"nombre_producto\".to_owned(),\n            categoria: \"categoria01\".to_owned(),\n            precio_base: 5000.00,\n        }\n    }\n\n    fn build_producto_cat02() -\u003e Producto {\n        Producto {\n            nombre: \"nombre_producto\".to_owned(),\n            categoria: \"categoria02\".to_owned(),\n            precio_base: 5000.00,\n        }\n    }\n\n    fn build_producto_cat03() -\u003e Producto {\n        Producto {\n            nombre: \"nombre_producto\".to_owned(),\n            categoria: \"categoria03\".to_owned(),\n            precio_base: 5000.00,\n        }\n    }\n\n    fn build_lista_productos() -\u003e Vec\u003c(Producto, u32)\u003e {\n        let mut list = Vec::new();\n        list.push((build_producto_cat01(), 1));\n        list.push((build_producto_cat01(), 2));\n        list.push((build_producto_cat01(), 3));\n\n        list\n    }\n\n    fn build_venta_con_sub() -\u003e Venta {\n        Venta {\n            fecha: build_fecha(),\n            productos: Vec::from([(build_producto_cat01(), 1)]),\n            vendedor: build_vendendor(),\n            cliente: build_cliente_con_sub(),\n            medio_de_pago: MedioDePago::Efectivo,\n        }\n    }\n\n    fn build_ventas_con_sub() -\u003e Venta {\n        Venta {\n            fecha: build_fecha(),\n            productos: Vec::from([\n                (build_producto_cat01(), 1),\n                (build_producto_cat02(), 2),\n                (build_producto_cat03(), 3),\n            ]),\n            vendedor: build_vendendor(),\n            cliente: build_cliente_con_sub(),\n            medio_de_pago: MedioDePago::Efectivo,\n        }\n    }\n\n    fn build_venta_sin_sub() -\u003e Venta {\n        Venta {\n            fecha: build_fecha(),\n            productos: Vec::from([(build_producto_cat01(), 1)]),\n            vendedor: build_vendendor(),\n            cliente: build_cliente_sin_sub(),\n            medio_de_pago: MedioDePago::Efectivo,\n        }\n    }\n\n    fn build_venta_por_legajo(legajo: String) -\u003e Venta {\n        Venta {\n            fecha: build_fecha(),\n            productos: Vec::from([(build_producto_cat01(), 1)]),\n            vendedor: build_vendendor_con_legajo(legajo),\n            cliente: build_cliente_sin_sub(),\n            medio_de_pago: MedioDePago::Efectivo,\n        }\n    }\n\n    fn build_categorias() -\u003e HashMap\u003cString, f64\u003e {\n        HashMap::from([\n            (\"categoria01\".to_owned(), 0.4),\n            (\"categoria02\".to_owned(), 0.7),\n            (\"categoria03\".to_owned(), 1.0),\n        ])\n    }\n\n    #[test]\n    fn valida_agregar_una_venta() {\n        let mut app = App::new();\n        let venta = build_venta_con_sub();\n\n        assert_eq!(app.ventas.len(), 0);\n        app.agregar_venta(venta);\n        assert_eq!(app.ventas.len(), 1);\n    }\n\n    #[test]\n    fn valida_cliente_subscripto() {\n        assert!(build_cliente_con_sub().esta_subscripto());\n        assert!(!build_cliente_sin_sub().esta_subscripto());\n    }\n\n    #[test]\n    fn valida_calcular_precio_final_de_venta() {\n        let mut app = App::new();\n        app.agregar_venta(build_venta_con_sub());\n        app.set_descuento_newsletter(30);\n\n        assert!(app.ventas[0].cliente.esta_subscripto());\n        assert_eq!(\n            app.ventas[0]\n                .calcular_precio_final(app.descuento_newsletter as f64, build_categorias()),\n            3486.00,\n            \"Deberia hacer el siguiente calculo correctamente ((5000 - 0.4% ) * 1) - 30%\"\n        );\n\n        app.agregar_venta(build_venta_sin_sub());\n        assert_eq!(\n            app.ventas[1]\n                .calcular_precio_final(app.descuento_newsletter as f64, build_categorias()),\n            4980.00,\n            \"Deberia hacer el siguiente calculo correctamente ((5000 - 0.4% ) * 1)\"\n        );\n    }\n\n    #[test]\n    fn valida_reporte_categorias() {\n        let mut app = App::new();\n        app.agregar_venta(build_ventas_con_sub());\n\n        assert_eq!(\n            app.generar_reporte_categorias(),\n            \"categoria01: 1; categoria02: 2; categoria03: 3;\".to_owned()\n        );\n        app.ventas.clear();\n        assert_eq!(\n            app.generar_reporte_categorias(),\n            \"No hay ventas registradas.\".to_owned()\n        );\n    }\n\n    #[test]\n    fn valida_reporte_vendedor() {\n        let mut app = App::new();\n        app.agregar_venta(build_venta_por_legajo(\"271826/2\".to_owned()));\n        assert_eq!(app.generar_reporte_vendedor(), \"271826/2: 1;\".to_owned());\n\n        app.agregar_venta(build_venta_por_legajo(\"298671/9\".to_owned()));\n        assert_eq!(\n            app.generar_reporte_vendedor(),\n            \"271826/2: 1; 298671/9: 1;\".to_owned()\n        );\n\n        app.ventas.clear();\n        assert_eq!(\n            app.generar_reporte_vendedor(),\n            \"No hay ventas registradas.\".to_owned()\n        );\n    }\n}\n","traces":[{"line":31,"address":[998096],"length":1,"stats":{"Line":1}},{"line":32,"address":[998101],"length":1,"stats":{"Line":1}},{"line":51,"address":[998341,998128],"length":1,"stats":{"Line":1}},{"line":56,"address":[998156],"length":1,"stats":{"Line":1}},{"line":57,"address":[709712],"length":1,"stats":{"Line":3}},{"line":58,"address":[709886,709736],"length":1,"stats":{"Line":2}},{"line":59,"address":[709794],"length":1,"stats":{"Line":1}},{"line":61,"address":[709898],"length":1,"stats":{"Line":0}},{"line":64,"address":[710018,709936],"length":1,"stats":{"Line":2}},{"line":65,"address":[709966],"length":1,"stats":{"Line":1}},{"line":68,"address":[998310],"length":1,"stats":{"Line":1}},{"line":79,"address":[998368,998501],"length":1,"stats":{"Line":1}},{"line":81,"address":[998386],"length":1,"stats":{"Line":1}},{"line":82,"address":[998396],"length":1,"stats":{"Line":1}},{"line":87,"address":[998528],"length":1,"stats":{"Line":1}},{"line":88,"address":[998537],"length":1,"stats":{"Line":1}},{"line":91,"address":[998544],"length":1,"stats":{"Line":1}},{"line":92,"address":[998549],"length":1,"stats":{"Line":1}},{"line":95,"address":[1000047,999781,998576],"length":1,"stats":{"Line":1}},{"line":96,"address":[998626],"length":1,"stats":{"Line":1}},{"line":97,"address":[998692],"length":1,"stats":{"Line":1}},{"line":100,"address":[998651],"length":1,"stats":{"Line":1}},{"line":101,"address":[998868,998664,998767],"length":1,"stats":{"Line":3}},{"line":102,"address":[999818,998884],"length":1,"stats":{"Line":2}},{"line":103,"address":[1000035,999987],"length":1,"stats":{"Line":2}},{"line":104,"address":[999940],"length":1,"stats":{"Line":1}},{"line":105,"address":[710051,710032],"length":1,"stats":{"Line":0}},{"line":106,"address":[1000025],"length":1,"stats":{"Line":1}},{"line":110,"address":[998861,998920],"length":1,"stats":{"Line":2}},{"line":111,"address":[710112,710139],"length":1,"stats":{"Line":4}},{"line":113,"address":[999026],"length":1,"stats":{"Line":1}},{"line":114,"address":[999339,999033,999140,999279],"length":1,"stats":{"Line":4}},{"line":115,"address":[999546,999387],"length":1,"stats":{"Line":2}},{"line":117,"address":[999405],"length":1,"stats":{"Line":1}},{"line":120,"address":[1000064,1001251,1001357],"length":1,"stats":{"Line":1}},{"line":121,"address":[1000105],"length":1,"stats":{"Line":1}},{"line":122,"address":[1000162],"length":1,"stats":{"Line":1}},{"line":124,"address":[1000130],"length":1,"stats":{"Line":1}},{"line":125,"address":[1000234,1000335,1000140],"length":1,"stats":{"Line":3}},{"line":126,"address":[1001302],"length":1,"stats":{"Line":1}},{"line":127,"address":[1000351],"length":1,"stats":{"Line":1}},{"line":128,"address":[710160,710173],"length":1,"stats":{"Line":0}},{"line":132,"address":[1000393,1000328],"length":1,"stats":{"Line":2}},{"line":133,"address":[710224,710251],"length":1,"stats":{"Line":4}},{"line":135,"address":[1000499],"length":1,"stats":{"Line":1}},{"line":136,"address":[1000752,1000506,1000812,1000613],"length":1,"stats":{"Line":4}},{"line":137,"address":[1001016,1000860],"length":1,"stats":{"Line":2}},{"line":139,"address":[1000878],"length":1,"stats":{"Line":1}}],"covered":45,"coverable":48},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp4","ej5.rs"],"content":"use rand::Rng;\nuse std::collections::HashMap;\nuse time::OffsetDateTime;\n\nconst ERROR_COTIZACION: \u0026str = \"Error obteniendo cotizacion\";\nconst ERROR_CRIPTOMONEDA: \u0026str = \"Error obteniendo criptomoneda\";\nconst ERROR_BLOCKCHAIN: \u0026str = \"Error obteniendo blockchain\";\n\nstruct Blockchain {\n    nombre: String,\n    prefijo: String,\n}\n\nimpl Blockchain {\n    fn generar_hash(\u0026self) -\u003e String {\n        format!(\"{}{}\", self.nombre, rand::rng().random::\u003cu32\u003e())\n    }\n}\n\nstruct Criptomoneda {\n    nombre: String,\n    prefijo: String,\n    blockchains: HashMap\u003cString, Blockchain\u003e, // clave: prefijo_blockchain\n}\n\nenum MedioDePago {\n    MercadoPago,\n    Transferencia,\n}\n\nstruct Balance {\n    user_id: String,\n    balance_fiat: f64,\n    balance_cripto: HashMap\u003cString, f64\u003e, // clave: prefijo_cripto\n}\n\nimpl Balance {\n    fn vender_cripto(\u0026mut self, pref_cripto: \u0026str, monto_fiat: f64, cotizacion: f64) {\n        self.balance_fiat += monto_fiat;\n        self.balance_cripto\n            .entry(pref_cripto.to_owned())\n            .and_modify(|c| *c += monto_fiat / cotizacion)\n            .or_insert(monto_fiat / cotizacion);\n    }\n\n    fn comprar_cripto(\u0026mut self, pref_cripto: \u0026str, monto_fiat: f64, cotizacion: f64) {\n        self.balance_fiat -= monto_fiat;\n        self.balance_cripto\n            .entry(pref_cripto.to_owned())\n            .and_modify(|c| *c += monto_fiat / cotizacion)\n            .or_insert(monto_fiat / cotizacion);\n    }\n\n    fn retirar_fiat(\u0026mut self, monto_fiat: f64) {\n        self.balance_fiat -= monto_fiat;\n    }\n}\n\nstruct Usuario {\n    user_id: String,\n    nombre: String,\n    apellido: String,\n    dni: String,\n    email: String,\n    validado: bool,\n}\n\nenum TipoTransaccion {\n    IngresoDinero {\n        monto: f64,\n    },\n    CompraCripto {\n        cripto: String,\n        monto: f64,\n        cotizacion: f64,\n    },\n    VentaCripto {\n        cripto: String,\n        monto: f64,\n        cotizacion: f64,\n    },\n    RetirarFiat {\n        medio_pago: MedioDePago,\n    },\n    RetiroCripto {\n        cripto: String,\n        monto: f64,\n        hash: String,\n        cotizacion: f64,\n    },\n    RecepcionCripto {\n        cripto: String,\n        monto: f64,\n        cotizacion: f64,\n    },\n}\n\nstruct Transaccion {\n    user_id: String,\n    monto: f64,\n    tipo: TipoTransaccion,\n}\n\nimpl Transaccion {\n    fn new(tipo: TipoTransaccion, monto: f64, user_id: String) -\u003e Self {\n        Transaccion {\n            tipo,\n            monto,\n            user_id,\n        }\n    }\n}\n\nstruct Cotizacion {\n    fecha: OffsetDateTime,\n    compra: f64,\n    venta: f64,\n}\n\nimpl Cotizacion {\n    pub fn new(compra: f64, venta: f64) -\u003e Self {\n        Cotizacion {\n            fecha: OffsetDateTime::now_utc(),\n            compra,\n            venta,\n        }\n    }\n}\n\nstruct Estadisiticas {\n    cant_ventas: u32,\n    cant_compras: u32,\n    volumen_ventas: f64,\n    volumen_compras: f64,\n}\n\nstruct App {\n    usuarios: HashMap\u003cString, Usuario\u003e,             // clave: user_id\n    balances: HashMap\u003cString, Balance\u003e,             // clave: user_id\n    criptomonedas: HashMap\u003cString, Criptomoneda\u003e,   // clave: prefijo_cripto\n    cotizaciones: HashMap\u003cString, Vec\u003cCotizacion\u003e\u003e, // clave: prefijo_cripto\n    estadisticas: HashMap\u003cString, Estadisiticas\u003e,   // clave: prefijo_cripto\n    transacciones: Vec\u003cTransaccion\u003e,\n}\n\nimpl App {\n    pub fn new() -\u003e Self {\n        App {\n            usuarios: HashMap::new(),\n            balances: HashMap::new(),\n            criptomonedas: HashMap::new(),\n            cotizaciones: HashMap::new(),\n            transacciones: Vec::new(),\n            estadisticas: HashMap::new(),\n        }\n    }\n    pub fn obtener_cotizacion(\u0026self, pref_cripto: \u0026str) -\u003e \u0026Cotizacion {\n        self.cotizaciones\n            .get(pref_cripto)\n            .and_then(|f| Some(f.last().expect(ERROR_COTIZACION)))\n            .expect(\"err\")\n    }\n\n    pub fn ingresar_dinero(\u0026mut self, monto_fiat: f64, user_id: String) {\n        if self.balances.contains_key(\u0026user_id) {\n            self.balances\n                .entry(user_id.clone())\n                .and_modify(|u| u.balance_fiat += monto_fiat);\n\n            self.transacciones.push(Transaccion::new(\n                TipoTransaccion::IngresoDinero { monto: monto_fiat },\n                monto_fiat,\n                user_id,\n            ));\n        }\n    }\n\n    pub fn comprar_cripto(\u0026mut self, pref_cripto: String, monto_fiat: f64, user_id: String) {\n        // obtengo cotizacion actual\n        let cotizacion = self.obtener_cotizacion(\u0026pref_cripto).compra;\n        // verficar que usuario existe\n        if let Some(balance) = self.balances.get_mut(\u0026user_id) {\n            // verifica que el usuario esta validado\n            if self.usuarios.get(\u0026user_id).is_some_and(|u| u.validado) {\n                // verificar qeu tiene saldo para transaccion\n                if balance.balance_fiat \u003e= monto_fiat {\n                    // hago la compra\n                    balance.comprar_cripto(\u0026pref_cripto, monto_fiat, cotizacion);\n                    // y genero transaccion\n                    self.transacciones.push(Transaccion::new(\n                        TipoTransaccion::CompraCripto {\n                            cripto: pref_cripto,\n                            monto: monto_fiat / cotizacion,\n                            cotizacion,\n                        },\n                        monto_fiat,\n                        user_id,\n                    ))\n                }\n            }\n        }\n    }\n\n    pub fn vender_cripto(\u0026mut self, pref_cripto: String, monto_fiat: f64, user_id: String) {\n        // obtengo cotizacion actual\n        let cotizacion = self.obtener_cotizacion(\u0026pref_cripto).venta;\n        // verificar que el usuario existe\n        if let Some(balance) = self.balances.get_mut(\u0026user_id) {\n            // verifica que el usuario esta validado\n            if self.usuarios.get(\u0026user_id).is_some_and(|u| u.validado) {\n                // verifico que el usuario tiene saldo suficiente para la transaccion\n                if let Some(balance_actual) = balance.balance_cripto.get(\u0026pref_cripto) {\n                    if *balance_actual \u003e= monto_fiat / cotizacion {\n                        // hago la venta\n                        balance.vender_cripto(\u0026pref_cripto, monto_fiat, cotizacion);\n                        // y generop la transaccion\n                        self.transacciones.push(Transaccion::new(\n                            TipoTransaccion::VentaCripto {\n                                cripto: pref_cripto,\n                                monto: monto_fiat / cotizacion,\n                                cotizacion,\n                            },\n                            monto_fiat,\n                            user_id,\n                        ))\n                    }\n                }\n            }\n        }\n    }\n\n    pub fn retirar_fiat(\u0026mut self, user_id: String, monto_fiat: f64, medio: MedioDePago) {\n        if self.usuarios.get(\u0026user_id).is_some_and(|u| u.validado) {\n            if let Some(balance) = self.balances.get_mut(\u0026user_id) {\n                if balance.balance_fiat \u003e= monto_fiat {\n                    balance.retirar_fiat(monto_fiat);\n                    self.transacciones.push(Transaccion::new(\n                        TipoTransaccion::RetirarFiat { medio_pago: medio },\n                        monto_fiat,\n                        user_id,\n                    ));\n                }\n            }\n        }\n    }\n\n    pub fn recibir_hash(\u0026self, pref_cripto: \u0026str, blockchain: \u0026str) -\u003e String {\n        self.criptomonedas\n            .get(pref_cripto)\n            .expect(ERROR_CRIPTOMONEDA)\n            .blockchains\n            .get(blockchain)\n            .expect(ERROR_BLOCKCHAIN)\n            .generar_hash()\n    }\n\n    pub fn retirar_cripto(\n        \u0026mut self,\n        user_id: String,\n        pref_cripto: String,\n        blockchain: String,\n        monto_cripto: f64,\n    ) {\n        if self.usuarios.get(\u0026user_id).is_some_and(|u| u.validado) {\n            if let Some(balance) = self.balances.get_mut(\u0026user_id) {\n                if let Some(balance_actual) = balance.balance_cripto.get_mut(\u0026pref_cripto) {\n                    if *balance_actual \u003e= monto_cripto {\n                        *balance_actual -= monto_cripto;\n                        let cotizacion = self.obtener_cotizacion(\u0026pref_cripto).venta;\n                        self.transacciones.push(Transaccion {\n                            user_id,\n                            monto: monto_cripto / cotizacion,\n                            tipo: TipoTransaccion::RetiroCripto {\n                                hash: self.recibir_hash(\u0026pref_cripto, \u0026blockchain),\n                                cripto: pref_cripto,\n                                monto: monto_cripto,\n                                cotizacion,\n                            },\n                        })\n                    }\n                }\n            }\n        }\n    }\n\n    pub fn recibir_cripto(\n        \u0026mut self,\n        user_id: String,\n        pref_cripto: String,\n        _blockchain: String,\n        monto_cripto: f64,\n    ) {\n        if self.usuarios.get(\u0026user_id).is_some_and(|u| u.validado) {\n            if let Some(balance) = self.balances.get_mut(\u0026user_id) {\n                if let Some(balance_actual) = balance.balance_cripto.get_mut(\u0026pref_cripto) {\n                    *balance_actual += monto_cripto;\n                    let cotizacion = self.obtener_cotizacion(\u0026pref_cripto).venta;\n\n                    self.transacciones.push(Transaccion {\n                        user_id,\n                        monto: monto_cripto / cotizacion,\n                        tipo: TipoTransaccion::RecepcionCripto {\n                            cripto: pref_cripto,\n                            monto: monto_cripto,\n                            cotizacion,\n                        },\n                    })\n                }\n            }\n        }\n    }\n\n    pub fn actualizar_datos_estadisticos(\u0026mut self) {\n        self.transacciones.iter().for_each(|t| match \u0026t.tipo {\n            TipoTransaccion::CompraCripto { cripto, monto, .. } =\u003e {\n                self.estadisticas.entry(cripto.to_owned()).and_modify(|e| {\n                    e.cant_compras += 1;\n                    e.volumen_compras += monto;\n                });\n            }\n            TipoTransaccion::VentaCripto { cripto, monto, .. } =\u003e {\n                self.estadisticas.entry(cripto.to_owned()).and_modify(|e| {\n                    e.cant_ventas += 1;\n                    e.volumen_ventas += monto;\n                });\n            }\n            _ =\u003e (),\n        });\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    fn build_usuario_validado(user_id: \u0026str) -\u003e Usuario {\n        Usuario {\n            user_id: user_id.to_string(),\n            nombre: \"Agustin\".to_string(),\n            apellido: \"Mediotti\".to_string(),\n            dni: \"12345678\".to_string(),\n            email: \"agus@test.com\".to_string(),\n            validado: true,\n        }\n    }\n\n    fn build_balance_con_fiat(user_id: \u0026str, fiat: f64) -\u003e Balance {\n        Balance {\n            user_id: user_id.to_string(),\n            balance_fiat: fiat,\n            balance_cripto: HashMap::new(),\n        }\n    }\n\n    fn build_cotizaciones(compra: f64, venta: f64) -\u003e Vec\u003cCotizacion\u003e {\n        vec![Cotizacion::new(compra, venta)]\n    }\n\n    fn build_cripto_con_blockchain() -\u003e Criptomoneda {\n        let mut blockchains = HashMap::new();\n        blockchains.insert(\n            \"btc\".to_string(),\n            Blockchain {\n                nombre: \"BTCNET\".to_string(),\n                prefijo: \"btc\".to_string(),\n            },\n        );\n\n        Criptomoneda {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"btc\".to_string(),\n            blockchains,\n        }\n    }\n\n    fn setup_app(user_id: \u0026str, compra: f64, venta: f64, fiat: f64) -\u003e App {\n        let mut app = App::new();\n\n        app.usuarios\n            .insert(user_id.to_string(), build_usuario_validado(user_id));\n        app.balances\n            .insert(user_id.to_string(), build_balance_con_fiat(user_id, fiat));\n        app.cotizaciones\n            .insert(\"btc\".to_string(), build_cotizaciones(compra, venta));\n        app.criptomonedas\n            .insert(\"btc\".to_string(), build_cripto_con_blockchain());\n\n        app.estadisticas.insert(\n            \"btc\".to_string(),\n            Estadisiticas {\n                cant_compras: 0,\n                cant_ventas: 0,\n                volumen_compras: 0.0,\n                volumen_ventas: 0.0,\n            },\n        );\n\n        app\n    }\n\n    #[test]\n    fn test_ingresar_dinero() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 1000.0);\n        app.ingresar_dinero(2000.0, \"user1\".to_string());\n\n        assert_eq!(app.balances[\"user1\"].balance_fiat, 3000.0);\n        assert_eq!(app.transacciones.len(), 1);\n    }\n\n    #[test]\n    fn test_comprar_cripto() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 1000.0);\n        app.comprar_cripto(\"btc\".to_string(), 500.0, \"user1\".to_string());\n\n        assert!(app.balances[\"user1\"].balance_cripto.contains_key(\"btc\"));\n        assert!(app.balances[\"user1\"].balance_fiat \u003c 1000.0);\n        assert_eq!(app.transacciones.len(), 1);\n    }\n\n    #[test]\n    fn test_vender_cripto() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 0.0);\n\n        app.balances\n            .get_mut(\"user1\")\n            .unwrap()\n            .balance_cripto\n            .insert(\"btc\".to_string(), 0.01);\n        app.vender_cripto(\"btc\".to_string(), 520.0, \"user1\".to_string());\n\n        assert!(app.balances[\"user1\"].balance_fiat \u003e 0.0);\n        assert_eq!(app.transacciones.len(), 1);\n    }\n\n    #[test]\n    fn test_retirar_fiat() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 1000.0);\n        app.retirar_fiat(\"user1\".to_string(), 500.0, MedioDePago::Transferencia);\n\n        assert_eq!(app.balances[\"user1\"].balance_fiat, 500.0);\n        assert_eq!(app.transacciones.len(), 1);\n    }\n\n    #[test]\n    fn test_retirar_cripto() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 0.0);\n        app.balances\n            .get_mut(\"user1\")\n            .unwrap()\n            .balance_cripto\n            .insert(\"btc\".to_string(), 0.01);\n        app.retirar_cripto(\n            \"user1\".to_string(),\n            \"btc\".to_string(),\n            \"btc\".to_string(),\n            0.005,\n        );\n\n        assert!(app.balances[\"user1\"].balance_cripto[\"btc\"] \u003c 0.01);\n        assert_eq!(app.transacciones.len(), 1);\n    }\n\n    #[test]\n    fn test_recibir_cripto() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 0.0);\n        app.balances\n            .get_mut(\"user1\")\n            .unwrap()\n            .balance_cripto\n            .insert(\"btc\".to_string(), 0.0);\n        app.recibir_cripto(\n            \"user1\".to_string(),\n            \"btc\".to_string(),\n            \"btc\".to_string(),\n            0.003,\n        );\n\n        assert_eq!(app.balances[\"user1\"].balance_cripto[\"btc\"], 0.003);\n        assert_eq!(app.transacciones.len(), 1);\n    }\n\n    #[test]\n    fn test_actualizar_datos_estadisticos() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 1000.0);\n        app.comprar_cripto(\"btc\".to_string(), 500.0, \"user1\".to_string());\n        app.vender_cripto(\"btc\".to_string(), 200.0, \"user1\".to_string());\n\n        app.actualizar_datos_estadisticos();\n\n        let stats = \u0026app.estadisticas[\"btc\"];\n        assert_eq!(stats.cant_compras, 1);\n        assert_eq!(stats.cant_ventas, 1);\n        assert!(stats.volumen_compras \u003e 0.0);\n        assert!(stats.volumen_ventas \u003e 0.0);\n    }\n}\n","traces":[{"line":15,"address":[1150447,1150096],"length":1,"stats":{"Line":1}},{"line":16,"address":[1150129],"length":1,"stats":{"Line":1}},{"line":38,"address":[1150480],"length":1,"stats":{"Line":1}},{"line":39,"address":[1150523],"length":1,"stats":{"Line":1}},{"line":40,"address":[1150613,1150539,1150561],"length":1,"stats":{"Line":3}},{"line":41,"address":[1150547],"length":1,"stats":{"Line":1}},{"line":42,"address":[572224,572239],"length":1,"stats":{"Line":2}},{"line":43,"address":[1150601],"length":1,"stats":{"Line":1}},{"line":46,"address":[1150640],"length":1,"stats":{"Line":2}},{"line":47,"address":[1150683],"length":1,"stats":{"Line":2}},{"line":48,"address":[1150721,1150699,1150773],"length":1,"stats":{"Line":6}},{"line":49,"address":[1150707],"length":1,"stats":{"Line":2}},{"line":50,"address":[572287,572272],"length":1,"stats":{"Line":0}},{"line":51,"address":[1150761],"length":1,"stats":{"Line":2}},{"line":54,"address":[1150800],"length":1,"stats":{"Line":1}},{"line":55,"address":[1150814],"length":1,"stats":{"Line":1}},{"line":105,"address":[1150832],"length":1,"stats":{"Line":2}},{"line":121,"address":[1150912],"length":1,"stats":{"Line":2}},{"line":123,"address":[1150950],"length":1,"stats":{"Line":2}},{"line":147,"address":[1151477,1151024],"length":1,"stats":{"Line":1}},{"line":149,"address":[1151045],"length":1,"stats":{"Line":1}},{"line":150,"address":[1151055],"length":1,"stats":{"Line":1}},{"line":151,"address":[1151104],"length":1,"stats":{"Line":1}},{"line":152,"address":[1151153],"length":1,"stats":{"Line":1}},{"line":153,"address":[1151202],"length":1,"stats":{"Line":2}},{"line":154,"address":[1151254],"length":1,"stats":{"Line":2}},{"line":157,"address":[1151504],"length":1,"stats":{"Line":2}},{"line":158,"address":[1151522],"length":1,"stats":{"Line":2}},{"line":160,"address":[572320,572329],"length":1,"stats":{"Line":4}},{"line":164,"address":[1151993,1151584,1151964],"length":1,"stats":{"Line":1}},{"line":165,"address":[1151691,1151615],"length":1,"stats":{"Line":2}},{"line":166,"address":[1151726,1151764],"length":1,"stats":{"Line":2}},{"line":167,"address":[1151734],"length":1,"stats":{"Line":1}},{"line":168,"address":[572400,572410],"length":1,"stats":{"Line":3}},{"line":170,"address":[1151874],"length":1,"stats":{"Line":1}},{"line":171,"address":[1151810],"length":1,"stats":{"Line":1}},{"line":173,"address":[1151843],"length":1,"stats":{"Line":1}},{"line":178,"address":[1152016,1152763],"length":1,"stats":{"Line":2}},{"line":180,"address":[1152074,1152179],"length":1,"stats":{"Line":4}},{"line":182,"address":[1152225],"length":1,"stats":{"Line":2}},{"line":184,"address":[572437,572432],"length":1,"stats":{"Line":8}},{"line":186,"address":[1152377],"length":1,"stats":{"Line":2}},{"line":188,"address":[1152393],"length":1,"stats":{"Line":2}},{"line":190,"address":[1152625],"length":1,"stats":{"Line":2}},{"line":191,"address":[1152502],"length":1,"stats":{"Line":2}},{"line":192,"address":[1152464],"length":1,"stats":{"Line":2}},{"line":193,"address":[1152495],"length":1,"stats":{"Line":2}},{"line":197,"address":[1152570],"length":1,"stats":{"Line":2}},{"line":204,"address":[1152816,1153665],"length":1,"stats":{"Line":1}},{"line":206,"address":[1152874,1152979],"length":1,"stats":{"Line":2}},{"line":208,"address":[1153026],"length":1,"stats":{"Line":1}},{"line":210,"address":[1153115,1153155],"length":1,"stats":{"Line":4}},{"line":212,"address":[1153186],"length":1,"stats":{"Line":1}},{"line":213,"address":[1153272],"length":1,"stats":{"Line":1}},{"line":215,"address":[1153295],"length":1,"stats":{"Line":1}},{"line":217,"address":[1153527],"length":1,"stats":{"Line":1}},{"line":218,"address":[1153404],"length":1,"stats":{"Line":1}},{"line":219,"address":[1153366],"length":1,"stats":{"Line":1}},{"line":220,"address":[1153397],"length":1,"stats":{"Line":1}},{"line":224,"address":[1153472],"length":1,"stats":{"Line":1}},{"line":232,"address":[1153712,1154152,1154181],"length":1,"stats":{"Line":1}},{"line":233,"address":[572469,572464],"length":1,"stats":{"Line":4}},{"line":234,"address":[1153895],"length":1,"stats":{"Line":1}},{"line":235,"address":[1153971],"length":1,"stats":{"Line":1}},{"line":236,"address":[1153993],"length":1,"stats":{"Line":1}},{"line":237,"address":[1154095],"length":1,"stats":{"Line":1}},{"line":238,"address":[1154015],"length":1,"stats":{"Line":1}},{"line":240,"address":[1154043],"length":1,"stats":{"Line":1}},{"line":247,"address":[1154192],"length":1,"stats":{"Line":1}},{"line":248,"address":[1154280],"length":1,"stats":{"Line":1}},{"line":257,"address":[1155579,1154400,1155418],"length":1,"stats":{"Line":1}},{"line":264,"address":[572480,572485],"length":1,"stats":{"Line":4}},{"line":265,"address":[1154627],"length":1,"stats":{"Line":1}},{"line":266,"address":[1154709],"length":1,"stats":{"Line":1}},{"line":267,"address":[1154801],"length":1,"stats":{"Line":1}},{"line":268,"address":[1154837],"length":1,"stats":{"Line":1}},{"line":269,"address":[1154849],"length":1,"stats":{"Line":1}},{"line":270,"address":[1155286],"length":1,"stats":{"Line":1}},{"line":271,"address":[1154946],"length":1,"stats":{"Line":1}},{"line":272,"address":[1154977],"length":1,"stats":{"Line":1}},{"line":273,"address":[1155204],"length":1,"stats":{"Line":1}},{"line":274,"address":[1155076,1154987],"length":1,"stats":{"Line":2}},{"line":275,"address":[1155173],"length":1,"stats":{"Line":1}},{"line":286,"address":[1155616,1156444,1156469],"length":1,"stats":{"Line":1}},{"line":293,"address":[572501,572496],"length":1,"stats":{"Line":4}},{"line":294,"address":[1155810],"length":1,"stats":{"Line":1}},{"line":295,"address":[1155880],"length":1,"stats":{"Line":1}},{"line":296,"address":[1155960],"length":1,"stats":{"Line":1}},{"line":297,"address":[1155972],"length":1,"stats":{"Line":1}},{"line":299,"address":[1156191],"length":1,"stats":{"Line":1}},{"line":300,"address":[1156054],"length":1,"stats":{"Line":1}},{"line":301,"address":[1156085],"length":1,"stats":{"Line":1}},{"line":302,"address":[1156123],"length":1,"stats":{"Line":1}},{"line":303,"address":[1156092],"length":1,"stats":{"Line":1}},{"line":313,"address":[1156512],"length":1,"stats":{"Line":1}},{"line":314,"address":[572540,572512],"length":1,"stats":{"Line":3}},{"line":315,"address":[572629],"length":1,"stats":{"Line":1}},{"line":316,"address":[572653,572864],"length":1,"stats":{"Line":2}},{"line":317,"address":[572883,572939],"length":1,"stats":{"Line":1}},{"line":318,"address":[572910],"length":1,"stats":{"Line":1}},{"line":321,"address":[572739],"length":1,"stats":{"Line":1}},{"line":322,"address":[572766,572960],"length":1,"stats":{"Line":2}},{"line":323,"address":[573031,572979],"length":1,"stats":{"Line":1}},{"line":324,"address":[573006],"length":1,"stats":{"Line":1}}],"covered":103,"coverable":104},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp4","mod.rs"],"content":"pub mod ej1;\npub mod ej2;\npub mod ej3;\npub mod ej4;\npub mod ej5;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp5","ej1.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt::Display;\nuse std::fs::File;\nuse std::io::Write;\n\nconst FILE_NAME: \u0026str = \"src/tp5/archivo_autos.json\";\n\n#[derive(PartialEq, Debug, Clone, Serialize, Deserialize)]\npub enum ColorAuto {\n    Rojo,\n    Verde,\n    Azul,\n    Amarillo,\n    Blanco,\n    Negro,\n}\n\n#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\npub struct Auto {\n    pub marca: String,\n    pub modelo: String,\n    pub anio: u32,\n    pub precio_bruto: f64,\n    pub color: ColorAuto,\n}\n\nimpl Auto {\n    fn new(marca: String, modelo: String, anio: u32, precio_bruto: f64, color: ColorAuto) -\u003e Self {\n        Auto {\n            marca,\n            modelo,\n            anio,\n            precio_bruto,\n            color,\n        }\n    }\n\n    pub fn calcular_precio(\u0026self) -\u003e f64 {\n        let mut total: f64 = self.precio_bruto;\n        match self.color {\n            ColorAuto::Rojo | ColorAuto::Verde | ColorAuto::Amarillo =\u003e {\n                total += self.precio_bruto * 25.0 / 100.0\n            }\n            _ =\u003e total -= self.precio_bruto * 10.0 / 100.0,\n        };\n        if self.marca == \"BMW\" {\n            total += self.precio_bruto * 15.0 / 100.0;\n        }\n        if self.anio \u003c 2000 {\n            total -= self.precio_bruto * 5.0 / 100.0;\n        }\n        total\n    }\n}\n\n#[derive(Debug, PartialEq)]\npub enum ErrorConcecionaria {\n    ErrorCapacidadMaxima(String),\n    ErrorConcecionarioVacio,\n    ErrorAutoNoEncontrado,\n    ErrorEscritura(String),\n}\n\nimpl From\u003cstd::io::Error\u003e for ErrorConcecionaria {\n    fn from(e: std::io::Error) -\u003e Self {\n        ErrorConcecionaria::ErrorEscritura(e.to_string())\n    }\n}\n\nimpl Display for ErrorConcecionaria {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            ErrorConcecionaria::ErrorCapacidadMaxima(e) =\u003e write!(f, \"{e}\"),\n            ErrorConcecionaria::ErrorConcecionarioVacio =\u003e {\n                write!(f, \"No se puede eliminar un auto de una concecionaria vacía\")\n            }\n            ErrorConcecionaria::ErrorAutoNoEncontrado =\u003e {\n                write!(f, \"El auto no se encontró en la concecionaria\")\n            }\n            ErrorConcecionaria::ErrorEscritura(e) =\u003e write!(f, \"{e}\"),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize)]\npub struct ConcesionarioAuto {\n    pub nombre: String,\n    pub direccion: String,\n    pub capacidad_max: usize,\n    pub autos: Vec\u003cAuto\u003e,\n}\n\nimpl ConcesionarioAuto {\n    pub fn new(nombre: String, direccion: String, capacidad_max: usize, autos: Vec\u003cAuto\u003e) -\u003e Self {\n        let mut file = File::create(FILE_NAME).unwrap();\n        let concecionaria = ConcesionarioAuto {\n            nombre,\n            direccion,\n            capacidad_max,\n            autos,\n        };\n        let buf = serde_json::to_string(\u0026concecionaria).unwrap();\n        file.write_all(\u0026buf.as_bytes())\n            .expect(\"error escribiendo el archivo\");\n        concecionaria\n    }\n\n    pub fn escribir_json(\u0026self) -\u003e Result\u003c(), std::io::Error\u003e {\n        let mut file = File::create(FILE_NAME)?;\n        let buf = serde_json::to_string(\u0026self)?;\n        file.write_all(\u0026buf.as_bytes())?;\n        Ok(())\n    }\n\n    pub fn agregar_auto(\u0026mut self, auto: Auto) -\u003e Result\u003c(), ErrorConcecionaria\u003e {\n        if self.autos.len() \u003c self.capacidad_max {\n            self.autos.push(auto);\n            self.escribir_json()?;\n            Ok(())\n        } else {\n            Err(ErrorConcecionaria::ErrorCapacidadMaxima(\n                self.capacidad_max.to_string(),\n            ))\n        }\n    }\n\n    pub fn eliminar_auto(\u0026mut self, auto: Auto) -\u003e Result\u003c(), ErrorConcecionaria\u003e {\n        if self.autos.is_empty() {\n            return Err(ErrorConcecionaria::ErrorConcecionarioVacio);\n        }\n        if let Some(pos) = self.autos.iter().position(|f| *f == auto) {\n            self.autos.remove(pos);\n            self.escribir_json()?;\n            return Ok(());\n        } else {\n            Err(ErrorConcecionaria::ErrorAutoNoEncontrado)\n        }\n    }\n\n    pub fn buscar_auto(\u0026self, auto: Auto) -\u003e Option\u003cAuto\u003e {\n        if let Some(pos) = self.autos.iter().position(|f| *f == auto) {\n            Some(self.autos[pos].clone())\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_nuevo_concesionario_auto_correctamente() {\n        assert_eq!(\n            ConcesionarioAuto::new(\n                \"Concesionario 44\".to_owned(),\n                \"44 13 y 14\".to_owned(),\n                5,\n                Vec::new()\n            ),\n            ConcesionarioAuto {\n                nombre: \"Concesionario 44\".to_owned(),\n                direccion: \"44 13 y 14\".to_owned(),\n                capacidad_max: 5,\n                autos: Vec::new()\n            },\n            \"No se creo el objeto como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn crea_auto_nuevo_correctamente() {\n        let auto = Auto::new(\n            \"Toyota\".to_string(),\n            \"Corolla\".to_string(),\n            2010,\n            15000.0,\n            ColorAuto::Negro,\n        );\n\n        assert_eq!(auto.marca, \"Toyota\");\n        assert_eq!(auto.modelo, \"Corolla\");\n        assert_eq!(auto.anio, 2010);\n        assert_eq!(auto.precio_bruto, 15000.0);\n        assert_eq!(auto.color, ColorAuto::Negro);\n    }\n\n    #[test]\n    fn calcular_precio_auto_color_azul_sin_descuento_marca() {\n        let auto = Auto {\n            marca: \"Toyota\".to_owned(),\n            modelo: \"Corolla\".to_owned(),\n            anio: 2020,\n            precio_bruto: 20000.0,\n            color: ColorAuto::Azul,\n        };\n\n        assert_eq!(auto.calcular_precio(), 18000.0);\n    }\n\n    #[test]\n    fn agregar_auto_a_concesionario_correctamente() {\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            5,\n            Vec::new(),\n        );\n\n        conce\n            .agregar_auto(Auto {\n                marca: \"BMW\".to_owned(),\n                modelo: \"M3\".to_owned(),\n                anio: 1995,\n                precio_bruto: 30_000.0,\n                color: ColorAuto::Rojo,\n            })\n            .unwrap();\n\n        assert_eq!(\n            conce.autos.len(),\n            1,\n            \"No se agrego el auto al concesionario como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn agregar_auto_concecionaria_llena() {\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            1,\n            Vec::new(),\n        );\n\n        conce\n            .agregar_auto(Auto {\n                marca: \"BMW\".to_owned(),\n                modelo: \"M3\".to_owned(),\n                anio: 1995,\n                precio_bruto: 30_000.0,\n                color: ColorAuto::Rojo,\n            })\n            .unwrap();\n\n        assert_eq!(\n            conce.agregar_auto(Auto {\n                marca: \"BMW\".to_owned(),\n                modelo: \"M3\".to_owned(),\n                anio: 1995,\n                precio_bruto: 30_000.0,\n                color: ColorAuto::Rojo,\n            }),\n            Err(ErrorConcecionaria::ErrorCapacidadMaxima(\"1\".to_string())),\n            \"Se esperaba un error de capacidad 1\"\n        );\n    }\n\n    #[test]\n    fn eliminar_auto_de_concesionario_correctamente() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            5,\n            Vec::new(),\n        );\n        conce.agregar_auto(auto.clone()).unwrap();\n        assert_eq!(conce.autos.len(), 1,);\n        conce.eliminar_auto(auto).unwrap();\n        assert_eq!(\n            conce.autos.len(),\n            0,\n            \"No se elimino el auto al concesionario como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn eliminar_auto_no_existente_devuelve_error() {\n        let auto = Auto::new(\n            \"Ford\".to_string(),\n            \"Fiesta\".to_string(),\n            2015,\n            10000.0,\n            ColorAuto::Blanco,\n        );\n\n        let otro_auto = Auto::new(\n            \"Toyota\".to_string(),\n            \"Corolla\".to_string(),\n            2020,\n            20000.0,\n            ColorAuto::Azul,\n        );\n\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario Test\".to_string(),\n            \"Calle Falsa 123\".to_string(),\n            2,\n            vec![otro_auto],\n        );\n\n        assert_eq!(\n            conce.eliminar_auto(auto),\n            Err(ErrorConcecionaria::ErrorAutoNoEncontrado),\n            \"Se esperaba error al intentar eliminar un auto inexistente\"\n        );\n    }\n\n    #[test]\n    fn eliminar_auto_de_concesionario_vacio() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            1,\n            Vec::new(),\n        );\n        assert_eq!(\n            conce.eliminar_auto(auto),\n            Err(ErrorConcecionaria::ErrorConcecionarioVacio),\n            \"Se esperaba un error al eliminar un auto de una concecionaria vacia\"\n        );\n    }\n\n    #[test]\n    fn buscar_auto_en_concesionario_correctamente() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            5,\n            Vec::new(),\n        );\n        conce.agregar_auto(auto.clone()).unwrap();\n\n        assert_eq!(\n            conce.buscar_auto(auto.clone()),\n            Some(auto),\n            \"No se encontro el auto en el concesionario como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn calcular_precio_de_auto_correctamente() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n\n        assert_eq!(\n            auto.calcular_precio(),\n            40_500.0,\n            \"No se calculo el precio del auto como se esperaba\"\n        );\n    }\n}\n","traces":[{"line":28,"address":[627984],"length":1,"stats":{"Line":1}},{"line":38,"address":[628096],"length":1,"stats":{"Line":1}},{"line":39,"address":[628110],"length":1,"stats":{"Line":1}},{"line":40,"address":[628121],"length":1,"stats":{"Line":1}},{"line":42,"address":[628204],"length":1,"stats":{"Line":1}},{"line":44,"address":[628156],"length":1,"stats":{"Line":1}},{"line":46,"address":[628320,628246],"length":1,"stats":{"Line":2}},{"line":47,"address":[628283],"length":1,"stats":{"Line":1}},{"line":49,"address":[628379,628267],"length":1,"stats":{"Line":2}},{"line":50,"address":[628338],"length":1,"stats":{"Line":1}},{"line":52,"address":[628322],"length":1,"stats":{"Line":1}},{"line":65,"address":[628512,628384],"length":1,"stats":{"Line":0}},{"line":66,"address":[628457,628413],"length":1,"stats":{"Line":0}},{"line":71,"address":[628544],"length":1,"stats":{"Line":0}},{"line":72,"address":[628577],"length":1,"stats":{"Line":0}},{"line":73,"address":[628613],"length":1,"stats":{"Line":0}},{"line":75,"address":[628706],"length":1,"stats":{"Line":0}},{"line":78,"address":[628756],"length":1,"stats":{"Line":0}},{"line":80,"address":[628808],"length":1,"stats":{"Line":0}},{"line":94,"address":[629731,628944,629819],"length":1,"stats":{"Line":1}},{"line":95,"address":[629110,628989],"length":1,"stats":{"Line":2}},{"line":102,"address":[629376,629424],"length":1,"stats":{"Line":2}},{"line":103,"address":[629462,629530],"length":1,"stats":{"Line":2}},{"line":105,"address":[629615],"length":1,"stats":{"Line":1}},{"line":108,"address":[630481,629856,630502],"length":1,"stats":{"Line":1}},{"line":109,"address":[629868,629950],"length":1,"stats":{"Line":1}},{"line":110,"address":[630038,630163,629943,630495],"length":1,"stats":{"Line":2}},{"line":111,"address":[630146,630385,630252,630448],"length":1,"stats":{"Line":2}},{"line":112,"address":[630360],"length":1,"stats":{"Line":1}},{"line":115,"address":[631068,630528,631043],"length":1,"stats":{"Line":1}},{"line":116,"address":[630571,630979,630654],"length":1,"stats":{"Line":3}},{"line":117,"address":[630694],"length":1,"stats":{"Line":1}},{"line":118,"address":[631041,630896,630986],"length":1,"stats":{"Line":1}},{"line":119,"address":[630972],"length":1,"stats":{"Line":1}},{"line":121,"address":[630768],"length":1,"stats":{"Line":1}},{"line":122,"address":[630665],"length":1,"stats":{"Line":1}},{"line":127,"address":[631692,631088],"length":1,"stats":{"Line":1}},{"line":128,"address":[631187,631131],"length":1,"stats":{"Line":2}},{"line":129,"address":[631224],"length":1,"stats":{"Line":1}},{"line":131,"address":[631198,631289],"length":1,"stats":{"Line":4}},{"line":132,"address":[631420,631533],"length":1,"stats":{"Line":2}},{"line":133,"address":[631635,631677,631545],"length":1,"stats":{"Line":1}},{"line":134,"address":[631621],"length":1,"stats":{"Line":1}},{"line":136,"address":[631456],"length":1,"stats":{"Line":1}},{"line":140,"address":[631728,632050],"length":1,"stats":{"Line":1}},{"line":141,"address":[631771,631839,631989],"length":1,"stats":{"Line":4}},{"line":142,"address":[631949,632000],"length":1,"stats":{"Line":2}},{"line":144,"address":[631976],"length":1,"stats":{"Line":0}}],"covered":39,"coverable":48},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp5","ej2.rs"],"content":"use serde::Serialize;\nuse std::fs::File;\nuse std::io::Write;\n\nconst FILE_NAME: \u0026str = \"src/tp5/archivo_canciones.json\";\n\n#[derive(Debug, PartialEq, Clone, Serialize)]\npub enum Genero {\n    Rock,\n    Pop,\n    Rap,\n    Jazz,\n    Otros,\n}\n\n#[derive(Debug, PartialEq, Clone, Serialize)]\npub struct Cancion {\n    pub titulo: String,\n    pub artista: String,\n    pub genero: Genero,\n}\n\n#[derive(Serialize)]\npub struct Playlist {\n    pub canciones: Vec\u003cCancion\u003e,\n    pub nombre: String,\n}\n\n#[derive(Debug)]\npub enum PlaylistError {\n    JsonFileError(std::io::Error),\n    SongNotFound,\n}\n\nimpl From\u003cstd::io::Error\u003e for PlaylistError {\n    fn from(e: std::io::Error) -\u003e Self {\n        PlaylistError::JsonFileError(e)\n    }\n}\n\nimpl Playlist {\n    pub fn new(nombre: String) -\u003e Self {\n        let mut file = File::create(FILE_NAME).unwrap();\n        let playlist = Playlist {\n            canciones: Vec::new(),\n            nombre,\n        };\n        let buf = serde_json::to_string(\u0026playlist).unwrap();\n        file.write_all(\u0026buf.as_bytes())\n            .expect(\"error escribiendo el archivo\");\n        playlist\n    }\n\n    pub fn escribir_json(\u0026self) -\u003e Result\u003c(), std::io::Error\u003e {\n        let mut file = File::create(FILE_NAME)?;\n        let buf = serde_json::to_string(\u0026self)?;\n        file.write_all(\u0026buf.as_bytes())?;\n        Ok(())\n    }\n\n    pub fn agregar_cancion(\u0026mut self, cancion: Cancion) -\u003e Result\u003c(), PlaylistError\u003e {\n        self.canciones.push(cancion);\n        self.escribir_json()?;\n        Ok(())\n    }\n\n    pub fn eliminar_cancion(\u0026mut self, cancion: Cancion) -\u003e Result\u003c(), PlaylistError\u003e {\n        if let Some(pos) = self.canciones.iter().position(|f| *f == cancion) {\n            self.canciones.remove(pos);\n            self.escribir_json()?;\n            Ok(())\n        } else {\n            Err(PlaylistError::SongNotFound)\n        }\n    }\n\n    pub fn mover_cancion(\n        \u0026mut self,\n        cancion: Cancion,\n        posicion: usize,\n    ) -\u003e Result\u003c(), PlaylistError\u003e {\n        if let Some(pos) = self.canciones.iter().position(|f| *f == cancion) {\n            let cancion = self.canciones.remove(pos);\n\n            let nueva_posicion = if posicion \u003e self.canciones.len() {\n                self.canciones.len()\n            } else {\n                posicion // Si la posicion está fuera de rango, la nueva posicion sera la última del vector.\n            };\n\n            self.canciones.insert(nueva_posicion, cancion);\n            self.escribir_json()?;\n            Ok(())\n        } else {\n            Err(PlaylistError::SongNotFound)\n        }\n    }\n\n    pub fn buscar_cancion_por_nombre(\u0026self, cancion: Cancion) -\u003e Option\u003c\u0026Cancion\u003e {\n        self.canciones.iter().find(|f| **f == cancion)\n    }\n\n    pub fn obtener_canciones_por_genero(\u0026self, genero: Genero) -\u003e Vec\u003c\u0026Cancion\u003e {\n        self.canciones\n            .iter()\n            .filter(|f| f.genero == genero)\n            .collect()\n    }\n\n    pub fn obtener_canciones_por_artista(\u0026self, artista: String) -\u003e Vec\u003c\u0026Cancion\u003e {\n        self.canciones\n            .iter()\n            .filter(|f| f.artista == artista)\n            .collect()\n    }\n\n    pub fn modificar_titulo(\u0026mut self, titulo: String) {\n        self.nombre = titulo;\n    }\n\n    pub fn limpiar_playlist(\u0026mut self) {\n        self.canciones.clear();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn build_cancion_01() -\u003e Cancion {\n        Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        }\n    }\n\n    fn build_cancion_02() -\u003e Cancion {\n        Cancion {\n            titulo: \"Trance Awake\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Lacuna Coil\".to_owned(),\n        }\n    }\n\n    fn build_cancion_from(titulo: String, artista: String) -\u003e Cancion {\n        Cancion {\n            titulo,\n            genero: Genero::Otros,\n            artista,\n        }\n    }\n\n    fn build_set_canciones() -\u003e (Cancion, Cancion) {\n        (build_cancion_01(), build_cancion_02())\n    }\n\n    fn build_playlist() -\u003e Playlist {\n        Playlist::new(\"Mi Playlist\".to_owned())\n    }\n\n    #[test]\n    fn agrega_cancion_a_playlist_correctamente() {\n        let mut playlist = build_playlist();\n        let cancion = build_cancion_01();\n\n        playlist.agregar_cancion(cancion.clone()).unwrap();\n\n        assert_eq!(\n            playlist.canciones[0], cancion,\n            \"No se agrego la cancion a la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn elimina_cancion_de_playlist_correctamente() {\n        let mut playlist = build_playlist();\n        let cancion = build_cancion_01();\n\n        playlist.agregar_cancion(cancion.clone()).unwrap();\n        playlist.eliminar_cancion(cancion).unwrap();\n\n        assert_eq!(\n            playlist.canciones.len(),\n            0,\n            \"No se elimino la cancion de la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn mueve_cancion_a_una_determinada_posicion_de_la_playlist() {\n        let mut playlist = build_playlist();\n\n        let (cancion_1, cancion_2) = build_set_canciones();\n\n        playlist.agregar_cancion(cancion_1.clone()).unwrap();\n        playlist.agregar_cancion(cancion_2).unwrap();\n\n        playlist.mover_cancion(cancion_1.clone(), 1).unwrap();\n\n        assert_eq!(\n            playlist.canciones[1], cancion_1,\n            \"No se movio la cancion de la playlist a la posicion que se esperaba\"\n        );\n    }\n\n    #[test]\n    fn mueve_cancion_a_una_posicion_fuera_de_rango_de_la_playlist() {\n        let mut playlist = build_playlist();\n\n        let (cancion_1, cancion_2) = build_set_canciones();\n\n        playlist.agregar_cancion(cancion_1.clone()).unwrap();\n        playlist.agregar_cancion(cancion_2).unwrap();\n\n        playlist.mover_cancion(cancion_1.clone(), 3).unwrap();\n\n        assert_eq!(\n            playlist.canciones[1], cancion_1,\n            \"Se esperaba que la cancion de la playlist se mueva a la última posicion del vector\"\n        );\n    }\n\n    #[test]\n    fn busca_cancion_por_nombre_en_playlist() {\n        let mut playlist = build_playlist();\n        let cancion = build_cancion_01();\n\n        playlist.agregar_cancion(cancion.clone()).unwrap();\n\n        assert_eq!(\n            playlist\n                .buscar_cancion_por_nombre(cancion.clone())\n                .unwrap()\n                .to_owned(),\n            cancion,\n            \"No se encontro la cancion en la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn obtener_canciones_por_genero_en_playlist() {\n        let mut playlist = build_playlist();\n        let (cancion_1, cancion_2) = build_set_canciones();\n\n        playlist.agregar_cancion(cancion_1.clone()).unwrap();\n        playlist.agregar_cancion(cancion_2.clone()).unwrap();\n\n        let mut expected = Vec::\u003c\u0026Cancion\u003e::new();\n        expected.push(\u0026cancion_1);\n        expected.push(\u0026cancion_2);\n\n        assert_eq!(\n            playlist.obtener_canciones_por_genero(Genero::Otros),\n            expected,\n            \"No se obtuvieron las canciones de la playlist por genero como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn obtener_canciones_por_artista_en_playlist() {\n        let mut playlist = build_playlist();\n        let (cancion_1, cancion_2) = build_set_canciones();\n\n        playlist.agregar_cancion(cancion_1.clone()).unwrap();\n        playlist.agregar_cancion(cancion_2.clone()).unwrap();\n\n        let mut expected = Vec::\u003c\u0026Cancion\u003e::new();\n        expected.push(\u0026cancion_2);\n\n        assert_eq!(\n            playlist.obtener_canciones_por_artista(\"Lacuna Coil\".to_owned()),\n            expected,\n            \"No se obtuvieron las canciones de la playlist por artista como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn modificar_titulo_de_playlist() {\n        let mut playlist = build_playlist();\n        playlist.modificar_titulo(\"Metal only\".to_owned());\n\n        assert_eq!(\n            playlist.nombre,\n            \"Metal only\".to_owned(),\n            \"No se cambio el título de la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn eliminar_canciones_de_playlist() {\n        let mut playlist = build_playlist();\n        let (cancion_1, cancion_2) = build_set_canciones();\n\n        playlist.agregar_cancion(cancion_1.clone()).unwrap();\n        playlist.agregar_cancion(cancion_2.clone()).unwrap();\n\n        playlist.limpiar_playlist();\n\n        assert_eq!(\n            playlist.canciones,\n            Vec::\u003cCancion\u003e::new(),\n            \"No se eliminaron todas las canciones de la playlist como se esperaba\"\n        );\n    }\n}\n","traces":[{"line":36,"address":[608384],"length":1,"stats":{"Line":0}},{"line":37,"address":[608389],"length":1,"stats":{"Line":0}},{"line":42,"address":[608400,609023,609047],"length":1,"stats":{"Line":1}},{"line":43,"address":[608511,608422],"length":1,"stats":{"Line":2}},{"line":45,"address":[608550],"length":1,"stats":{"Line":1}},{"line":48,"address":[608700,608748],"length":1,"stats":{"Line":2}},{"line":49,"address":[608786,608854],"length":1,"stats":{"Line":2}},{"line":51,"address":[608937],"length":1,"stats":{"Line":1}},{"line":54,"address":[609088,609734,609713],"length":1,"stats":{"Line":1}},{"line":55,"address":[609100,609182],"length":1,"stats":{"Line":1}},{"line":56,"address":[609175,609727,609395,609270],"length":1,"stats":{"Line":2}},{"line":57,"address":[609680,609484,609617,609378],"length":1,"stats":{"Line":2}},{"line":58,"address":[609592],"length":1,"stats":{"Line":1}},{"line":61,"address":[609760],"length":1,"stats":{"Line":1}},{"line":62,"address":[609773],"length":1,"stats":{"Line":1}},{"line":63,"address":[609789,609844],"length":1,"stats":{"Line":1}},{"line":64,"address":[609833],"length":1,"stats":{"Line":1}},{"line":67,"address":[609904,610373],"length":1,"stats":{"Line":1}},{"line":68,"address":[609993,610168,610273,609929],"length":1,"stats":{"Line":5}},{"line":69,"address":[610181,610112],"length":1,"stats":{"Line":2}},{"line":70,"address":[610275,610193,610340],"length":1,"stats":{"Line":1}},{"line":71,"address":[610264],"length":1,"stats":{"Line":1}},{"line":73,"address":[610134],"length":1,"stats":{"Line":0}},{"line":77,"address":[610400,611179],"length":1,"stats":{"Line":2}},{"line":82,"address":[1065929,1065904],"length":1,"stats":{"Line":10}},{"line":83,"address":[610641,610713],"length":1,"stats":{"Line":4}},{"line":85,"address":[610802,610784,610721],"length":1,"stats":{"Line":5}},{"line":86,"address":[610809,610933],"length":1,"stats":{"Line":2}},{"line":88,"address":[610794],"length":1,"stats":{"Line":1}},{"line":91,"address":[610826],"length":1,"stats":{"Line":2}},{"line":92,"address":[611108,611041,610948],"length":1,"stats":{"Line":2}},{"line":93,"address":[611019],"length":1,"stats":{"Line":2}},{"line":95,"address":[610663],"length":1,"stats":{"Line":0}},{"line":99,"address":[611362,611216],"length":1,"stats":{"Line":1}},{"line":100,"address":[611230,611285],"length":1,"stats":{"Line":4}},{"line":103,"address":[611392],"length":1,"stats":{"Line":1}},{"line":104,"address":[611430],"length":1,"stats":{"Line":1}},{"line":106,"address":[1066017,1066000],"length":1,"stats":{"Line":2}},{"line":110,"address":[611504,611682],"length":1,"stats":{"Line":1}},{"line":111,"address":[611600,611541],"length":1,"stats":{"Line":2}},{"line":113,"address":[1066065,1066048],"length":1,"stats":{"Line":2}},{"line":117,"address":[611712,611769],"length":1,"stats":{"Line":1}},{"line":118,"address":[611730,611804],"length":1,"stats":{"Line":2}},{"line":121,"address":[611840],"length":1,"stats":{"Line":1}},{"line":122,"address":[611845],"length":1,"stats":{"Line":1}}],"covered":41,"coverable":45},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp5","mod.rs"],"content":"pub mod ej1;\npub mod ej2;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","lib.rs"],"content":"#![allow(dead_code)]\n\nmod tp1;\nmod tp2;\nmod tp3;\nmod tp4;\nmod tp5;\n\n// Gerenar Reporte de Coverage:\n// $ cargo tarpaulin --out Lcov \u0026\u0026 genhtml lcov.info -o coverage-report\n// $ cargo tarpaulin --target-dir src/coverage --skip-clean --out html\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej1.rs"],"content":"use std::io;\n\nfn main() -\u003e io::Result\u003c()\u003e {\n    let mut buf = String::new();\n    let pi: f32 = 3.14;\n\n    println!(\"enter a number: \");\n\n    io::stdin()\n        .read_line(\u0026mut buf)\n        .expect(\"failed to read line!\");\n    let num: u32 = buf.trim().parse().expect(\"not an integer!\");\n\n    println!(\"{num} * {pi} = {}\", num as f32 * pi);\n    println!(\"{num} / {pi} = {}\", num as f32 / pi);\n    println!(\"{num} + {pi} = {}\", num as f32 + pi);\n    println!(\"{num} - {pi} = {}\", num as f32 - pi);\n\n    Ok(())\n}\n","traces":[{"line":3,"address":[742592,743994],"length":1,"stats":{"Line":0}},{"line":4,"address":[742604],"length":1,"stats":{"Line":0}},{"line":5,"address":[742609],"length":1,"stats":{"Line":0}},{"line":7,"address":[742617,742681],"length":1,"stats":{"Line":0}},{"line":9,"address":[742697],"length":1,"stats":{"Line":0}},{"line":12,"address":[742801],"length":1,"stats":{"Line":0}},{"line":14,"address":[742961],"length":1,"stats":{"Line":0}},{"line":15,"address":[743211],"length":1,"stats":{"Line":0}},{"line":16,"address":[743461],"length":1,"stats":{"Line":0}},{"line":17,"address":[743711],"length":1,"stats":{"Line":0}},{"line":19,"address":[743961],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej10.rs"],"content":"fn main() {\n    let arr_01: Vec\u003cu32\u003e = vec![2, 4, 8, 16, 32];\n    let arr_02: Vec\u003cu32\u003e = vec![64, 128, 256, 512, 1024];\n    let arr_03: Vec\u003cu32\u003e = arr_01\n        .iter()\n        .zip(arr_02.iter())\n        .map(|(a, b)| a + b)\n        .collect();\n    println!(\"{:?}\", arr_03);\n}\n","traces":[{"line":1,"address":[727232,728043],"length":1,"stats":{"Line":0}},{"line":2,"address":[727393,727239],"length":1,"stats":{"Line":0}},{"line":3,"address":[727381,727455],"length":1,"stats":{"Line":0}},{"line":4,"address":[727668,727797,727588],"length":1,"stats":{"Line":0}},{"line":6,"address":[727709],"length":1,"stats":{"Line":0}},{"line":7,"address":[996464,996507],"length":1,"stats":{"Line":0}},{"line":9,"address":[727917,727866],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej11.rs"],"content":"use std::io;\n\nfn main() {\n    let text_vec = vec![\n        \"Hello World\",\n        \"UNLP Informatica\",\n        \"Seminario 2025\",\n        \"Rust is awesome\",\n        \"Lateralus\",\n    ];\n    let mut input = String::new();\n    io::stdin().read_line(\u0026mut input).expect(\"failed to read\");\n\n    if text_vec.contains(\u0026input.trim()) {\n        println!(\"I know that one\");\n    } else {\n        println!(\"A new spell?\");\n    }\n}\n","traces":[{"line":3,"address":[941664,942371],"length":1,"stats":{"Line":0}},{"line":4,"address":[941671,941881],"length":1,"stats":{"Line":0}},{"line":11,"address":[941874],"length":1,"stats":{"Line":0}},{"line":12,"address":[941996,941934],"length":1,"stats":{"Line":0}},{"line":14,"address":[942082],"length":1,"stats":{"Line":0}},{"line":15,"address":[942332,942266],"length":1,"stats":{"Line":0}},{"line":17,"address":[942240,942292],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej12.rs"],"content":"fn main() {\n    let t: (\u0026str, Vec\u003cu16\u003e) = (\"Powers of Two\", vec![2, 4, 8, 16, 32, 64, 128]);\n    println!(\"{}, {}\", t.0, t.1.iter().sum::\u003cu16\u003e());\n}\n","traces":[{"line":1,"address":[1127520,1127991],"length":1,"stats":{"Line":0}},{"line":2,"address":[1127734,1127527],"length":1,"stats":{"Line":0}},{"line":3,"address":[1127710,1127787],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej2.rs"],"content":"fn main() {\n    let int: u8 = 127;\n    println!(\"{int} =\u003e {}\", format!(\"{:X}\", int));\n}\n","traces":[{"line":1,"address":[573056,573402],"length":1,"stats":{"Line":0}},{"line":2,"address":[573063],"length":1,"stats":{"Line":0}},{"line":3,"address":[573086],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej3.rs"],"content":"use std::io;\n\nfn main() {\n    let boolean: bool = false;\n    let mut input = String::new();\n\n    println!(\"enter true or false: \");\n    io::stdin()\n        .read_line(\u0026mut input)\n        .expect(\"failed to read line!\");\n\n    match input.trim() {\n        \"true\" | \"t\" =\u003e {\n            println!(\"{boolean} \u0026 true = {}\", boolean \u0026 true);\n            println!(\"{boolean} | true = {}\", boolean | true);\n        }\n        \"false\" | \"f\" =\u003e {\n            println!(\"{boolean} \u0026 false = {}\", boolean \u0026 false);\n            println!(\"{boolean} | false = {}\", boolean | false);\n        }\n        _ =\u003e println!(\"{} is not a boolean\", input.trim()),\n    }\n}\n","traces":[{"line":3,"address":[838528,839910],"length":1,"stats":{"Line":0}},{"line":4,"address":[838535],"length":1,"stats":{"Line":0}},{"line":5,"address":[838548],"length":1,"stats":{"Line":0}},{"line":7,"address":[838553,838623],"length":1,"stats":{"Line":0}},{"line":8,"address":[838642],"length":1,"stats":{"Line":0}},{"line":12,"address":[838752],"length":1,"stats":{"Line":0}},{"line":13,"address":[838964,838822],"length":1,"stats":{"Line":0}},{"line":14,"address":[839617,838888],"length":1,"stats":{"Line":0}},{"line":15,"address":[839729],"length":1,"stats":{"Line":0}},{"line":17,"address":[839117,838980],"length":1,"stats":{"Line":0}},{"line":18,"address":[839319,839046],"length":1,"stats":{"Line":0}},{"line":19,"address":[839431],"length":1,"stats":{"Line":0}},{"line":21,"address":[839131],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej4.rs"],"content":"fn main() {\n    let t: (String, i32, bool) = (\"Rust 2025\".to_string(), -15, false);\n\n    println!(\"{}, {}, {}\", t.0, t.1, t.2);\n}\n","traces":[{"line":1,"address":[757728,757995],"length":1,"stats":{"Line":0}},{"line":2,"address":[757735],"length":1,"stats":{"Line":0}},{"line":4,"address":[757842,757800],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej5.rs"],"content":"use std::io;\n\nfn main() {\n    let text = String::from(\"I'm not screaming, \");\n    let mut input = String::new();\n\n    io::stdin().read_line(\u0026mut input).expect(\"bad input\");\n\n    println!(\"{}\", (text + \u0026input).to_uppercase());\n}\n","traces":[{"line":3,"address":[742524,742555,741840],"length":1,"stats":{"Line":0}},{"line":4,"address":[741847],"length":1,"stats":{"Line":0}},{"line":5,"address":[741898],"length":1,"stats":{"Line":0}},{"line":7,"address":[742005,741946],"length":1,"stats":{"Line":0}},{"line":9,"address":[742533,742077],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej6.rs"],"content":"use std::io;\n\nfn main() {\n    let a: u32 = 30;\n    let mut input = String::new();\n\n    io::stdin()\n        .read_line(\u0026mut input)\n        .expect(\"error reading input\");\n    let input: u32 = input.trim().parse().unwrap();\n\n    println!(\"({a} + {input})^2 = {}\", (a + input) * 2);\n}\n","traces":[{"line":3,"address":[806745,806096],"length":1,"stats":{"Line":0}},{"line":4,"address":[806103],"length":1,"stats":{"Line":0}},{"line":5,"address":[806116],"length":1,"stats":{"Line":0}},{"line":7,"address":[806183,806121],"length":1,"stats":{"Line":0}},{"line":10,"address":[806260],"length":1,"stats":{"Line":0}},{"line":12,"address":[806408],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej7.rs"],"content":"fn main() {\n    const PI: f32 = 6.28;\n\n    let arr = [2, 4, 8, 16, 32, 64]\n        .iter()\n        .map(|x| (*x as f32 * PI) as u32)\n        .collect::\u003cVec\u003cu32\u003e\u003e();\n\n    println!(\"{:?}\", arr);\n}\n","traces":[{"line":1,"address":[782000,782176],"length":1,"stats":{"Line":0}},{"line":4,"address":[782007],"length":1,"stats":{"Line":0}},{"line":6,"address":[575338,575328],"length":1,"stats":{"Line":0}},{"line":9,"address":[782103,782061],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej8.rs"],"content":"use std::io;\n\nfn main() {\n    const TEXT: \u0026str = \"Seminario de Lenguajes 2025: Rust\";\n\n    let mut input = String::new();\n    io::stdin().read_line(\u0026mut input).expect(\"failed to read\");\n    let input: char = input.chars().collect::\u003cVec\u003c_\u003e\u003e()[0];\n\n    let t = TEXT.chars().filter(|c| *c == input).count();\n\n    println!(\"{t}\");\n}\n","traces":[{"line":3,"address":[1140375,1139840],"length":1,"stats":{"Line":0}},{"line":6,"address":[1139852],"length":1,"stats":{"Line":0}},{"line":7,"address":[1139857,1139919],"length":1,"stats":{"Line":0}},{"line":8,"address":[1139996],"length":1,"stats":{"Line":0}},{"line":10,"address":[975210,975200],"length":1,"stats":{"Line":0}},{"line":12,"address":[1140260],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","ej9.rs"],"content":"fn main() {\n    let arr: Vec\u003cu8\u003e = vec![2, 4, 8, 16, 32];\n    println!(\"{}\", arr.iter().sum::\u003cu8\u003e());\n}\n","traces":[{"line":1,"address":[1084096,1084439],"length":1,"stats":{"Line":0}},{"line":2,"address":[1084103,1084210],"length":1,"stats":{"Line":0}},{"line":3,"address":[1084189,1084277],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp1","mod.rs"],"content":"pub mod ej1;\npub mod ej10;\npub mod ej11;\npub mod ej12;\npub mod ej2;\npub mod ej3;\npub mod ej4;\npub mod ej5;\npub mod ej6;\npub mod ej7;\npub mod ej8;\npub mod ej9;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej1.rs"],"content":"pub fn es_par(num: u64) -\u003e bool {\n    num % 2 == 0\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn numeros_pares_son_identificados_correctamente() {\n        assert!(es_par(4), \"4 debería ser par\");\n        assert!(es_par(0), \"0 debería ser par\");\n        assert!(!es_par(15), \"15 no debería ser par\");\n        assert!(!es_par(7), \"7 no debería ser par\");\n        assert!(!es_par(u64::MAX), \"u64::MAX no debería ser par\");\n    }\n}\n","traces":[{"line":1,"address":[592768],"length":1,"stats":{"Line":1}},{"line":2,"address":[592773],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej10.rs"],"content":"pub fn cantidad_de_cadenas_mayor_a(list: \u0026[\u0026str], limite: u32) -\u003e u32 {\n    list.iter()\n        .filter(|f| f.chars().count() as u32 \u003e limite)\n        .count() as u32\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn cuenta_cadenas_con_mas_caracteres_que_el_limite() {\n        let lista = [\n            \"String Corto\",\n            \"Cadena de string medianamente larga\",\n            \"Cadena de string relativamente mas largo\",\n            \"Una cadena de string considerablemente mas larga que las anteriores\",\n        ];\n        let limite = 12;\n        assert_eq!(\n            cantidad_de_cadenas_mayor_a(\u0026lista, limite),\n            3,\n            \"Debería haber 3 cadenas con más de {limite} caracteres\"\n        );\n        assert_eq!(\n            cantidad_de_cadenas_mayor_a(\u0026[], 5),\n            0,\n            \"No hay elementos en la lista, el resultado debería ser 0\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[990832],"length":1,"stats":{"Line":1}},{"line":2,"address":[990850],"length":1,"stats":{"Line":1}},{"line":3,"address":[956434,956416],"length":1,"stats":{"Line":2}}],"covered":3,"coverable":3},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej11.rs"],"content":"pub fn multiplicar_valores(lista: \u0026mut [i32], factor: i32) {\n    lista.iter_mut().for_each(|x| *x *= factor);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn multiplica_los_elementos_por_un_factor() {\n        let mut lista = [35, 23, 45, 18];\n        let factor = 2;\n        multiplicar_valores(\u0026mut lista, factor);\n        assert_eq!(\n            lista,\n            [70, 46, 90, 36],\n            \"Los elementos no fueron multiplicados correctamente por el factor\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[717440],"length":1,"stats":{"Line":1}},{"line":2,"address":[659459,659440],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej12.rs"],"content":"pub fn reemplazar_pares(lista: \u0026mut [i32]) {\n    lista\n        .iter_mut()\n        .filter(|e| **e % 2 == 0)\n        .for_each(|e| *e = -1);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn reemplaza_pares_con_menos_uno() {\n        let mut lista = [2, 5, 8, 11, 12, 16];\n        reemplazar_pares(\u0026mut lista);\n        assert_eq!(\n            lista,\n            [-1, 5, -1, 11, -1, -1],\n            \"Los números pares no fueron reemplazados correctamente\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[707936],"length":1,"stats":{"Line":1}},{"line":2,"address":[707950],"length":1,"stats":{"Line":1}},{"line":4,"address":[831248,831262],"length":1,"stats":{"Line":2}},{"line":5,"address":[831328,831338],"length":1,"stats":{"Line":2}}],"covered":4,"coverable":4},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej13.rs"],"content":"pub fn ordenar_nombres(list: \u0026mut [\u0026str]) {\n    list.sort();\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ordena_nombres_alfabeticamente() {\n        let mut lista = [\"ale\", \"Kim\", \"92\", \"Guillermo\", \"Juan Manuel\", \"\", \"Z\"];\n        ordenar_nombres(\u0026mut lista);\n        assert_eq!(\n            lista,\n            [\"\", \"92\", \"Guillermo\", \"Juan Manuel\", \"Kim\", \"Z\", \"ale\"],\n            \"Los nombres no fueron ordenados alfabéticamente como se esperaba\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[661808],"length":1,"stats":{"Line":1}},{"line":2,"address":[661822],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej14.rs"],"content":"pub fn incrementar(num: \u0026mut f32) {\n    *num += 1.0;\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn incrementa_variable_de_punto_flotante() {\n        let mut num: f32 = 2.0;\n        incrementar(\u0026mut num);\n        assert_eq!(\n            num, 3.0,\n            \"La variable {num} debería haber sido incrementada a 3.0\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[717488],"length":1,"stats":{"Line":1}},{"line":2,"address":[717493],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej2.rs"],"content":"pub fn es_primo(num: u64) -\u003e bool {\n    match num {\n        0 | 1 =\u003e false,\n        2 | 3 =\u003e true,\n        _ =\u003e !(2..=((num as f64).sqrt() as u64)).any(|i| num % i == 0),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn retorna_true_para_numeros_primos() {\n        let primos = [2, 3, 5, 7, 11, 13, 17, 19];\n        assert!(\n            primos.iter().all(|\u0026n| es_primo(n)),\n            \"Todos los números en la lista deberían ser primos\"\n        );\n        let no_primos = [0, 1, 4, 6, 8, 9, 10, 12, 15];\n        assert!(\n            no_primos.iter().all(|\u0026n| !es_primo(n)),\n            \"Ninguno de los números en la lista debería ser primo\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[1139600],"length":1,"stats":{"Line":1}},{"line":2,"address":[1139609],"length":1,"stats":{"Line":1}},{"line":3,"address":[1139814],"length":1,"stats":{"Line":1}},{"line":4,"address":[1139821],"length":1,"stats":{"Line":1}},{"line":5,"address":[990736,990755],"length":1,"stats":{"Line":3}}],"covered":5,"coverable":5},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej3.rs"],"content":"pub fn suma_pares(list: \u0026[i32]) -\u003e i32 {\n    list.iter().filter(|\u0026\u0026n| n % 2 == 0).sum()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn calcula_correctamente_la_suma_de_pares() {\n        let enteros_pares = [2, 4, 8, 16];\n        let enteros_impares = [1, 3, 5, 11];\n        assert_eq!(\n            suma_pares(\u0026enteros_pares),\n            30,\n            \"La suma de los pares [2, 4, 8, 16] debería ser 30\"\n        );\n        assert_eq!(\n            suma_pares(\u0026enteros_impares),\n            0,\n            \"No hay pares, el resultado debería ser 0\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[760368],"length":1,"stats":{"Line":1}},{"line":2,"address":[760382],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej4.rs"],"content":"pub fn cantidad_impares(list: \u0026[i32]) -\u003e i32 {\n    list.iter().filter(|\u0026\u0026e| e % 2 != 0).count() as i32\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn cuenta_la_cantidad_de_impares_correctamente() {\n        let enteros = [1, 2, 3, 5, 8, 11];\n        let sin_impares = [0, 2, 4, 8, 12, 18];\n        assert_eq!(\n            cantidad_impares(\u0026enteros),\n            4,\n            \"Debería haber 4 impares en la lista [1, 2, 3, 5, 8, 11]\"\n        );\n        assert_eq!(\n            cantidad_impares(\u0026sin_impares),\n            0,\n            \"No hay impares en la lista, el resultado debería ser 0\"\n        );\n        assert_eq!(\n            cantidad_impares(\u0026[]),\n            0,\n            \"No hay elementos en la lista, el resultado debería ser 0\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[717056],"length":1,"stats":{"Line":1}},{"line":2,"address":[717070],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej5.rs"],"content":"pub fn duplicar_valores(lista: \u0026[f32]) -\u003e Vec\u003cf32\u003e {\n    lista.iter().map(|\u0026e| e * 2.0).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn duplica_los_valores_correctamente() {\n        let lista = [1.0, 2.2, 4.8, 5.0, 0.0];\n        assert_eq!(\n            duplicar_valores(\u0026lista),\n            [2.0, 4.4, 9.6, 10.0, 0.0],\n            \"Los valores duplicados no coinciden con lo esperado\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[975232],"length":1,"stats":{"Line":1}},{"line":2,"address":[610768,610778],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej6.rs"],"content":"pub fn longitud_de_cadenas(lista: \u0026[\u0026str]) -\u003e Vec\u003cu32\u003e {\n    lista.iter().map(|e| e.chars().count() as u32).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn calcula_la_longitud_de_cada_string() {\n        let lista = [\n            \"Hola\",\n            \"UNLP\",\n            \"Informatica\",\n            \"A Don Cangrejo le gusta Rust\",\n        ];\n        assert_eq!(\n            longitud_de_cadenas(\u0026lista),\n            [4, 4, 11, 28],\n            \"Las longitudes de las cadenas no coinciden con lo esperado\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[1063488],"length":1,"stats":{"Line":1}},{"line":2,"address":[1063538],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej7.rs"],"content":"pub fn cantidad_de_mayores(lista: \u0026[u32], limite: \u0026u32) -\u003e u32 {\n    lista.iter().filter(|e| e \u003e \u0026limite).count() as u32\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn cuenta_cuantos_elementos_superan_el_limite() {\n        let lista = [2, 4, 8, 16, 32, 64];\n        let limite = 8;\n        assert_eq!(\n            cantidad_de_mayores(\u0026lista, \u0026limite),\n            3,\n            \"Debería haber 3 elementos mayores que {limite}\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[991632],"length":1,"stats":{"Line":1}},{"line":2,"address":[593085,593072],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej8.rs"],"content":"pub fn sumar_arreglos(left: \u0026[f32], right: \u0026[f32]) -\u003e Vec\u003cf32\u003e {\n    left.iter().zip(right.iter()).map(|(x, y)| x + y).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn suma_elemento_a_elemento_dos_arreglos() {\n        let a = [2.0, 4.2, 8.4, 1.1];\n        let b = [2.0, 4.2, 8.4, 1.1];\n        assert_eq!(\n            sumar_arreglos(\u0026a, \u0026b),\n            [4.0, 8.4, 16.8, 2.2],\n            \"La suma de los arreglos no coincide con lo esperado\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[952224],"length":1,"stats":{"Line":1}},{"line":2,"address":[858555,858512],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","ej9.rs"],"content":"pub fn cantidad_en_rango(lista: \u0026[i32], inferior: \u0026i32, superior: \u0026i32) -\u003e u32 {\n    lista\n        .iter()\n        .filter(|x| x \u003e= \u0026inferior \u0026\u0026 x \u003c= \u0026superior)\n        .count() as u32\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn cuenta_elementos_en_rango_inclusivo() {\n        let lista = [2, 4, 8, 16, 32, 64, 128];\n        let inferior = 16;\n        let superior = 64;\n        assert_eq!(\n            cantidad_en_rango(\u0026lista, \u0026inferior, \u0026superior),\n            3,\n            \"Debería haber 3 elementos dentro del rango {inferior}..{superior}\"\n        );\n    }\n}\n","traces":[{"line":1,"address":[634048],"length":1,"stats":{"Line":1}},{"line":2,"address":[634072],"length":1,"stats":{"Line":1}},{"line":4,"address":[990624,990643],"length":1,"stats":{"Line":2}}],"covered":3,"coverable":3},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp2","mod.rs"],"content":"pub mod ej1;\npub mod ej10;\npub mod ej11;\npub mod ej12;\npub mod ej13;\npub mod ej14;\npub mod ej2;\npub mod ej3;\npub mod ej4;\npub mod ej5;\npub mod ej6;\npub mod ej7;\npub mod ej8;\npub mod ej9;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej1.rs"],"content":"pub struct Persona {\n    pub nombre: String,\n    pub edad: u8,\n    pub dir: Option\u003cString\u003e,\n}\n\nimpl Persona {\n    pub fn new(nombre: String, edad: u8, dir: Option\u003cString\u003e) -\u003e Persona {\n        Persona { nombre, edad, dir }\n    }\n\n    pub fn to_string(\u0026self) -\u003e String {\n        let direccion = match \u0026self.dir {\n            Some(dir) =\u003e dir.clone(),\n            None =\u003e \"Sin dirección\".to_string(),\n        };\n\n        format!(\"{}, {}, {}\", self.nombre, self.edad, direccion)\n    }\n\n    pub fn obtener_edad(\u0026self) -\u003e u8 {\n        self.edad\n    }\n\n    pub fn actualizar_direccion(\u0026mut self, nue_dir: String) {\n        self.dir = Some(nue_dir);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_nueva_persona_sin_direccion() {\n        let persona = Persona::new(\"Fausto\".to_string(), 11, None);\n        assert_eq!(persona.nombre, \"Fausto\");\n        assert_eq!(persona.edad, 11);\n        assert_eq!(persona.dir, None);\n    }\n\n    #[test]\n    fn crea_nueva_persona_con_direccion() {\n        let persona = Persona::new(\n            \"Fausto\".to_string(),\n            11,\n            Some(\"Calle Falsa 123\".to_string()),\n        );\n        assert_eq!(persona.nombre, \"Fausto\");\n        assert_eq!(persona.edad, 11);\n        assert_eq!(persona.dir, Some(\"Calle Falsa 123\".to_string()));\n    }\n\n    #[test]\n    fn persona_to_string_con_direccion() {\n        let persona_to_string = Persona::new(\n            \"Fausto\".to_string(),\n            11,\n            Some(\"Calle Falsa 123\".to_string()),\n        )\n        .to_string();\n\n        assert_eq!(persona_to_string, \"Fausto, 11, Calle Falsa 123\")\n    }\n\n    #[test]\n    fn obtener_edad_de_persona() {\n        let persona = Persona::new(\n            \"Fausto\".to_string(),\n            11,\n            Some(\"Calle Falsa 123\".to_string()),\n        );\n\n        assert_eq!(persona.obtener_edad(), 11);\n    }\n\n    #[test]\n    fn actualizar_direccion_de_persona() {\n        let mut persona = Persona::new(\"Fausto\".to_string(), 11, None);\n        persona.actualizar_direccion(\"Fausto, 11, Calle Falsa 123\".to_string());\n\n        assert_eq!(persona.dir, Some(\"Fausto, 11, Calle Falsa 123\".to_string()));\n    }\n}\n","traces":[{"line":8,"address":[684640],"length":1,"stats":{"Line":1}},{"line":12,"address":[684704,685068],"length":1,"stats":{"Line":1}},{"line":13,"address":[684733],"length":1,"stats":{"Line":1}},{"line":14,"address":[684805],"length":1,"stats":{"Line":1}},{"line":15,"address":[684776],"length":1,"stats":{"Line":0}},{"line":18,"address":[684836,684888],"length":1,"stats":{"Line":2}},{"line":21,"address":[685104],"length":1,"stats":{"Line":1}},{"line":22,"address":[685109],"length":1,"stats":{"Line":1}},{"line":25,"address":[685189,685120],"length":1,"stats":{"Line":1}},{"line":26,"address":[685220,685134],"length":1,"stats":{"Line":2}}],"covered":9,"coverable":10},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej10.rs"],"content":"use super::ej3::Fecha;\nuse std::collections::HashMap;\n\n#[derive(PartialEq, Clone, Debug)]\npub enum EstadoPrestamo {\n    Devuelto,\n    Prestamo,\n}\n\n#[derive(PartialEq, Eq, Hash, Clone)]\npub enum GeneroLibro {\n    Novela,\n    Infantil,\n    Tecnico,\n    Otros,\n}\n\npub struct Biblioteca {\n    pub mombre: String,\n    pub direccion: String,\n    pub prestamos_efectuados: Vec\u003cPrestamo\u003e,\n    pub libros_a_disposicion: HashMap\u003cLibro, u8\u003e,\n}\n\n#[derive(PartialEq, Eq, Hash, Clone)]\npub struct Libro {\n    pub isbn: u32,\n    pub titulo: String,\n    pub autor: String,\n    pub numero_de_paginas: u32,\n    pub genero: GeneroLibro,\n}\n\n#[derive(PartialEq, Clone)]\npub struct Cliente {\n    pub nombre: String,\n    pub telefono: u32,\n    pub email: String,\n}\n\n#[derive(Clone)]\npub struct Prestamo {\n    pub libro: Libro,\n    pub fecha_vencimiento: Fecha,\n    pub fecha_devolucion: Fecha,\n    pub cliente: Cliente,\n    pub estado: EstadoPrestamo,\n}\n\nimpl Biblioteca {\n    pub fn obtener_cantidad_de_copias(\u0026self, libro: Libro) -\u003e u8 {\n        if let Some(copias) = self.libros_a_disposicion.get(\u0026libro) {\n            *copias\n        } else {\n            0\n        }\n    }\n\n    pub fn decrementar_copias_a_disposicion(\u0026mut self, libro: Libro) {\n        if let Some(copias) = self.libros_a_disposicion.get_mut(\u0026libro) {\n            if *copias \u003e 0 {\n                *copias -= 1;\n            }\n        }\n    }\n\n    pub fn incrementar_copias_a_disposicion(\u0026mut self, libro: Libro) {\n        if let Some(copias) = self.libros_a_disposicion.get_mut(\u0026libro) {\n            if *copias \u003c u8::max_value() {\n                *copias += 1;\n            }\n        }\n    }\n\n    pub fn contar_prestamos_de_cliente(\u0026self, cliente: Cliente) -\u003e usize {\n        self.prestamos_efectuados\n            .iter()\n            .filter(|f| f.cliente == cliente \u0026\u0026 f.estado == EstadoPrestamo::Prestamo)\n            .count()\n    }\n\n    pub fn realizar_prestamo_a_cliente(\u0026mut self, cliente: Cliente, libro: Libro) -\u003e bool {\n        if self\n            .prestamos_efectuados\n            .iter()\n            .filter(|f| f.cliente == cliente \u0026\u0026 f.estado == EstadoPrestamo::Prestamo)\n            .count()\n            \u003c 5\n        {\n            self.incrementar_copias_a_disposicion(libro);\n            true\n        } else {\n            false\n        }\n    }\n\n    pub fn ver_prestamos_a_vencer(\u0026self, dias: u8, fecha_actual: Fecha) -\u003e Vec\u003cPrestamo\u003e {\n        self.prestamos_efectuados\n            .iter()\n            .filter(|f| f.estado == EstadoPrestamo::Prestamo)\n            .filter(|f| {\n                let mut fecha_limite = fecha_actual;\n                fecha_limite.sumar_dias(dias as i64);\n                f.fecha_vencimiento \u003c= fecha_limite\n            })\n            .cloned()\n            .collect()\n    }\n\n    pub fn ver_prestamos_vencidos(\u0026self, fecha_actual: Fecha) -\u003e Vec\u003cPrestamo\u003e {\n        self.prestamos_efectuados\n            .iter()\n            .filter(|f| f.estado == EstadoPrestamo::Prestamo)\n            .filter(|f| f.fecha_vencimiento \u003c= fecha_actual)\n            .cloned()\n            .collect()\n    }\n\n    pub fn buscar_prestamo(\u0026self, cliente: Cliente, libro: Libro) -\u003e Option\u003cPrestamo\u003e {\n        if let Some(prestamo) = self\n            .prestamos_efectuados\n            .iter()\n            .find(|f| f.libro == libro \u0026\u0026 f.cliente == cliente)\n            .cloned()\n        {\n            Some(prestamo)\n        } else {\n            None\n        }\n    }\n\n    pub fn devolver_libro(\u0026mut self, cliente: Cliente, libro: Libro) {\n        if let Some(prestamo) = self\n            .prestamos_efectuados\n            .iter_mut()\n            .find(|f| f.cliente == cliente \u0026\u0026 f.libro == libro)\n        {\n            prestamo.estado = EstadoPrestamo::Devuelto;\n            self.incrementar_copias_a_disposicion(libro);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn obtener_cantidad_de_copias_correctamente() {\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let mut map = HashMap::new();\n        map.insert(libro.clone(), 3);\n        let biblio = Biblioteca {\n            mombre: \"Biblio\".to_string(),\n            direccion: \"Calle 1\".to_string(),\n            prestamos_efectuados: vec![],\n            libros_a_disposicion: map,\n        };\n        assert_eq!(biblio.obtener_cantidad_de_copias(libro), 3);\n    }\n\n    #[test]\n    fn incrementar_y_decrementar_copias_correctamente() {\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let mut map = HashMap::new();\n        map.insert(libro.clone(), 1);\n        let mut biblio = Biblioteca {\n            mombre: \"B\".to_string(),\n            direccion: \"X\".to_string(),\n            prestamos_efectuados: vec![],\n            libros_a_disposicion: map,\n        };\n        biblio.incrementar_copias_a_disposicion(libro.clone());\n        assert_eq!(biblio.obtener_cantidad_de_copias(libro.clone()), 2);\n        biblio.decrementar_copias_a_disposicion(libro.clone());\n        assert_eq!(biblio.obtener_cantidad_de_copias(libro.clone()), 1);\n    }\n\n    #[test]\n    fn contar_prestamos_cliente_correctamente() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            email: \"juan@email.com\".to_string(),\n        };\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let biblio = Biblioteca {\n            mombre: \"B\".to_string(),\n            direccion: \"X\".to_string(),\n            prestamos_efectuados: vec![Prestamo {\n                libro,\n                fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                cliente: cliente.clone(),\n                estado: EstadoPrestamo::Prestamo,\n            }],\n            libros_a_disposicion: HashMap::new(),\n        };\n        assert_eq!(biblio.contar_prestamos_de_cliente(cliente), 1);\n    }\n\n    #[test]\n    fn realizar_prestamo_a_cliente_correctamente() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            email: \"juan@email.com\".to_string(),\n        };\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let mut biblio = Biblioteca {\n            mombre: \"B\".to_string(),\n            direccion: \"X\".to_string(),\n            prestamos_efectuados: vec![Prestamo {\n                libro: libro.clone(),\n                fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                cliente: cliente.clone(),\n                estado: EstadoPrestamo::Prestamo,\n            }],\n            libros_a_disposicion: HashMap::new(),\n        };\n        biblio.realizar_prestamo_a_cliente(cliente, libro);\n        assert_eq!(biblio.prestamos_efectuados.len(), 1);\n    }\n\n    #[test]\n    fn ver_prestamos_vencidos_correctamente() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            email: \"juan@email.com\".to_string(),\n        };\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let biblio = Biblioteca {\n            mombre: \"B\".to_string(),\n            direccion: \"X\".to_string(),\n            prestamos_efectuados: vec![\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Prestamo,\n                },\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Devuelto,\n                },\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Prestamo,\n                },\n            ],\n            libros_a_disposicion: HashMap::new(),\n        };\n        let vencidos = biblio.ver_prestamos_vencidos(Fecha::new(02, 05, 2025).unwrap());\n        assert_eq!(vencidos.len(), 2);\n    }\n\n    #[test]\n    fn buscar_prestamo_correctamente() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            email: \"juan@email.com\".to_string(),\n        };\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let biblio = Biblioteca {\n            mombre: \"B\".to_string(),\n            direccion: \"X\".to_string(),\n            prestamos_efectuados: vec![\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Prestamo,\n                },\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Devuelto,\n                },\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Prestamo,\n                },\n            ],\n            libros_a_disposicion: HashMap::new(),\n        };\n        let found = biblio.buscar_prestamo(cliente, libro);\n        assert!(found.is_some());\n    }\n\n    #[test]\n    fn devolver_libro_correctamente() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            email: \"juan@email.com\".to_string(),\n        };\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"El libro\".to_string(),\n            autor: \"Autor\".to_string(),\n            numero_de_paginas: 100,\n            genero: GeneroLibro::Novela,\n        };\n        let mut biblio = Biblioteca {\n            mombre: \"B\".to_string(),\n            direccion: \"X\".to_string(),\n            prestamos_efectuados: vec![\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Prestamo,\n                },\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Devuelto,\n                },\n                Prestamo {\n                    libro: libro.clone(),\n                    fecha_vencimiento: Fecha::new(02, 05, 2025).unwrap(),\n                    fecha_devolucion: Fecha::new(01, 05, 2025).unwrap(),\n                    cliente: cliente.clone(),\n                    estado: EstadoPrestamo::Prestamo,\n                },\n            ],\n            libros_a_disposicion: HashMap::from([(libro.clone(), 0)]),\n        };\n        biblio.devolver_libro(cliente.clone(), libro.clone());\n        assert_eq!(biblio.obtener_cantidad_de_copias(libro.clone()), 1);\n        assert_eq!(\n            biblio.prestamos_efectuados[0].estado,\n            EstadoPrestamo::Devuelto\n        );\n    }\n}\n","traces":[{"line":51,"address":[959760,959896],"length":1,"stats":{"Line":1}},{"line":52,"address":[959823,959870,959774],"length":1,"stats":{"Line":3}},{"line":53,"address":[959864],"length":1,"stats":{"Line":1}},{"line":55,"address":[959872],"length":1,"stats":{"Line":0}},{"line":59,"address":[960105,959920],"length":1,"stats":{"Line":1}},{"line":60,"address":[959934,959986],"length":1,"stats":{"Line":2}},{"line":61,"address":[960083,960032],"length":1,"stats":{"Line":2}},{"line":62,"address":[960085,960057],"length":1,"stats":{"Line":1}},{"line":67,"address":[960337,960128],"length":1,"stats":{"Line":1}},{"line":68,"address":[960142,960194],"length":1,"stats":{"Line":2}},{"line":69,"address":[960240,960315,960280],"length":1,"stats":{"Line":3}},{"line":70,"address":[960317,960289],"length":1,"stats":{"Line":1}},{"line":75,"address":[960522,960368],"length":1,"stats":{"Line":1}},{"line":76,"address":[960441,960382],"length":1,"stats":{"Line":2}},{"line":78,"address":[726486,726464],"length":1,"stats":{"Line":2}},{"line":82,"address":[960544,960911],"length":1,"stats":{"Line":1}},{"line":83,"address":[960574,960737,960827,960662],"length":1,"stats":{"Line":3}},{"line":86,"address":[726560,726582],"length":1,"stats":{"Line":2}},{"line":90,"address":[960749],"length":1,"stats":{"Line":1}},{"line":91,"address":[960822],"length":1,"stats":{"Line":1}},{"line":93,"address":[960732],"length":1,"stats":{"Line":0}},{"line":97,"address":[960944],"length":1,"stats":{"Line":0}},{"line":98,"address":[960984],"length":1,"stats":{"Line":0}},{"line":100,"address":[726656,726670],"length":1,"stats":{"Line":0}},{"line":101,"address":[726704],"length":1,"stats":{"Line":0}},{"line":102,"address":[726723],"length":1,"stats":{"Line":0}},{"line":103,"address":[726732],"length":1,"stats":{"Line":0}},{"line":104,"address":[726756],"length":1,"stats":{"Line":0}},{"line":110,"address":[961088],"length":1,"stats":{"Line":1}},{"line":111,"address":[961122],"length":1,"stats":{"Line":1}},{"line":113,"address":[726798,726784],"length":1,"stats":{"Line":2}},{"line":114,"address":[726832,726849],"length":1,"stats":{"Line":2}},{"line":119,"address":[961216,961601],"length":1,"stats":{"Line":1}},{"line":120,"address":[961542,961498,961332,961264],"length":1,"stats":{"Line":3}},{"line":123,"address":[726906,726880],"length":1,"stats":{"Line":2}},{"line":126,"address":[961480],"length":1,"stats":{"Line":1}},{"line":128,"address":[961529],"length":1,"stats":{"Line":0}},{"line":132,"address":[962040,961632],"length":1,"stats":{"Line":1}},{"line":133,"address":[961750,961662],"length":1,"stats":{"Line":2}},{"line":136,"address":[727002,726976],"length":1,"stats":{"Line":2}},{"line":138,"address":[961871],"length":1,"stats":{"Line":1}},{"line":139,"address":[961889,961962],"length":1,"stats":{"Line":2}}],"covered":32,"coverable":42},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej2.rs"],"content":"pub struct Rectangulo {\n    pub longitud: u32,\n    pub ancho: u32,\n}\n\nimpl Rectangulo {\n    pub fn new(longitud: u32, ancho: u32) -\u003e Rectangulo {\n        Rectangulo { longitud, ancho }\n    }\n\n    pub fn calcular_area(\u0026self) -\u003e u64 {\n        self.longitud as u64 * self.ancho as u64\n    }\n\n    pub fn calcular_perimetro(\u0026self) -\u003e u64 {\n        (self.longitud as u64 * self.ancho as u64) * 2\n    }\n\n    pub fn es_cuadrado(\u0026self) -\u003e bool {\n        self.longitud == self.ancho\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_rectangulo_con_parametros_correctos() {\n        let rect = Rectangulo::new(5, 5);\n\n        assert_eq!(rect.ancho, 5);\n        assert_eq!(rect.longitud, 5);\n    }\n\n    #[test]\n    fn calcular_correctamente_area_de_rectangulo() {\n        assert_eq!(Rectangulo::new(2, 0).calcular_area(), 0);\n        assert_eq!(Rectangulo::new(1, 1).calcular_area(), 1);\n        assert_eq!(Rectangulo::new(5, 6).calcular_area(), 30);\n    }\n\n    #[test]\n    fn calcular_correctamente_perimetro_de_rectangulo() {\n        assert_eq!(Rectangulo::new(2, 0).calcular_perimetro(), 0);\n        assert_eq!(Rectangulo::new(1, 1).calcular_perimetro(), 2);\n        assert_eq!(Rectangulo::new(5, 6).calcular_perimetro(), 60);\n    }\n\n    #[test]\n    fn identifica_cuadrado_correctamente() {\n        assert!(!Rectangulo::new(2, 0).es_cuadrado());\n        assert!(Rectangulo::new(1, 1).es_cuadrado());\n        assert!(!Rectangulo::new(5, 6).es_cuadrado());\n        assert!(Rectangulo::new(u32::max_value(), u32::max_value()).es_cuadrado());\n    }\n}\n","traces":[{"line":7,"address":[823232],"length":1,"stats":{"Line":1}},{"line":11,"address":[823248],"length":1,"stats":{"Line":1}},{"line":12,"address":[823285,823257],"length":1,"stats":{"Line":1}},{"line":15,"address":[823312],"length":1,"stats":{"Line":1}},{"line":16,"address":[823388,823321],"length":1,"stats":{"Line":1}},{"line":19,"address":[823408],"length":1,"stats":{"Line":1}},{"line":20,"address":[823413],"length":1,"stats":{"Line":1}}],"covered":7,"coverable":7},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej3.rs"],"content":"use time::{\n    Duration, {Date, Month},\n};\n\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\npub struct Fecha {\n    fecha: Date,\n}\n\nimpl Fecha {\n    pub fn new(dia: u8, mes: u8, anio: i32) -\u003e Option\u003cSelf\u003e {\n        if Self::es_fecha_valida(dia, mes, anio) {\n            Some(Self {\n                fecha: Date::from_calendar_date(anio, Month::try_from(mes).unwrap(), dia).unwrap(),\n            })\n        } else {\n            None\n        }\n    }\n\n    pub fn es_fecha_valida(dia: u8, mes: u8, anio: i32) -\u003e bool {\n        if let Ok(month) = Month::try_from(mes) {\n            Date::from_calendar_date(anio, month, dia).is_ok()\n        } else {\n            false\n        }\n    }\n\n    pub fn es_bisiesto(\u0026self) -\u003e bool {\n        /*\n            https://es.wikipedia.org/wiki/A%C3%B1o_bisiesto\n\n           p: Es divisible por 4\n           q: Es divisible por 100\n           r: Es divisible por 400\n\n           (p ∧ ~q) ∨ r\n        */\n        (self.fecha.year() % 4 == 0 \u0026\u0026 self.fecha.year() \u0026 100 != 0) || self.fecha.year() \u0026 400 == 0\n    }\n\n    pub fn sumar_dias(\u0026mut self, dias: i64) {\n        self.fecha = self.fecha + Duration::days(dias);\n    }\n\n    pub fn restar_dias(\u0026mut self, dias: i64) {\n        self.fecha = self.fecha - Duration::days(dias);\n    }\n\n    pub fn es_mayor(\u0026self, una_fecha: \u0026Fecha) -\u003e bool {\n        self.fecha \u003e una_fecha.fecha\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_una_fecha_con_correctamente() {\n        assert!(Fecha::new(11, 09, 2001).is_some());\n        assert!(Fecha::new(31, 11, 2025).is_none());\n        assert!(Fecha::new(29, 2, 2023).is_none());\n    }\n\n    #[test]\n    fn verifica_fecha_valida() {\n        assert!(!Fecha::es_fecha_valida(29, 2, 2023));\n        assert!(!Fecha::es_fecha_valida(31, 11, 2025));\n        assert!(Fecha::es_fecha_valida(31, 12, 2025));\n    }\n\n    #[test]\n    fn verifica_fecha_bisiesto() {\n        assert!(\n            Fecha::new(29, 3, 2024)\n                .expect(\"Fecha incorrecta\")\n                .es_bisiesto()\n        );\n        assert!(\n            !Fecha::new(19, 5, 2023)\n                .expect(\"Fecha incorrecta\")\n                .es_bisiesto()\n        );\n    }\n\n    #[test]\n    fn verifica_sumar_dias_a_fecha() {\n        let mut fecha = Fecha::new(11, 09, 2001).unwrap();\n        fecha.sumar_dias(15);\n\n        assert_eq!(fecha, Fecha::new(26, 09, 2001).unwrap());\n    }\n\n    #[test]\n    fn verifica_restar_dias_a_fecha() {\n        let mut fecha = Fecha::new(11, 09, 2001).unwrap();\n        fecha.restar_dias(2);\n\n        assert_eq!(fecha, Fecha::new(09, 09, 2001).unwrap());\n    }\n}\n","traces":[{"line":11,"address":[776816],"length":1,"stats":{"Line":1}},{"line":12,"address":[776862,776885],"length":1,"stats":{"Line":2}},{"line":13,"address":[776966],"length":1,"stats":{"Line":1}},{"line":14,"address":[776891],"length":1,"stats":{"Line":1}},{"line":17,"address":[776877],"length":1,"stats":{"Line":1}},{"line":21,"address":[776992],"length":1,"stats":{"Line":1}},{"line":22,"address":[777027],"length":1,"stats":{"Line":1}},{"line":23,"address":[777085],"length":1,"stats":{"Line":1}},{"line":25,"address":[777120],"length":1,"stats":{"Line":0}},{"line":29,"address":[777152],"length":1,"stats":{"Line":1}},{"line":39,"address":[777165],"length":1,"stats":{"Line":1}},{"line":42,"address":[777296],"length":1,"stats":{"Line":1}},{"line":43,"address":[777315],"length":1,"stats":{"Line":1}},{"line":46,"address":[777360],"length":1,"stats":{"Line":1}},{"line":47,"address":[777379],"length":1,"stats":{"Line":1}},{"line":50,"address":[777424],"length":1,"stats":{"Line":0}},{"line":51,"address":[777438],"length":1,"stats":{"Line":0}}],"covered":14,"coverable":17},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej4.rs"],"content":"#[derive(Debug, PartialEq)]\npub enum TrianguloTipo {\n    Equilatero,\n    Isosceles,\n    Escaleno,\n}\n\n#[derive(Debug, PartialEq)]\npub struct Triangulo {\n    pub x: i64,\n    pub y: i64,\n    pub z: i64,\n}\n\nimpl Triangulo {\n    pub fn new(x: i64, y: i64, z: i64) -\u003e Self {\n        Triangulo { x, y, z }\n    }\n\n    pub fn determinar_tipo(\u0026self) -\u003e Option\u003cTrianguloTipo\u003e {\n        if self.x == self.y \u0026\u0026 self.y == self.z {\n            Some(TrianguloTipo::Equilatero)\n        } else if (self.x == self.y) || (self.x == self.z) || (self.z == self.y) {\n            Some(TrianguloTipo::Isosceles)\n        } else if (self.x != self.y) \u0026\u0026 (self.x != self.z) \u0026\u0026 (self.z != self.y) {\n            Some(TrianguloTipo::Escaleno)\n        } else {\n            None\n        }\n    }\n\n    pub fn calcular_area(\u0026self) -\u003e f64 {\n        (f64::sqrt(3.0) / 4.0) * (self.y * self.y) as f64\n    }\n\n    pub fn calcular_perimetro(\u0026self) -\u003e i64 {\n        self.x + self.y + self.z\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_nuevo_triangulo_correctamente() {\n        assert_eq!(Triangulo::new(5, 5, 5), Triangulo { x: 5, y: 5, z: 5 });\n        assert_ne!(Triangulo::new(2, 7, 3), Triangulo { x: 1, y: 1, z: 1 });\n    }\n\n    #[test]\n    fn determinar_tipo_triangulo_correctamente() {\n        assert_eq!(\n            Triangulo::new(5, 5, 5).determinar_tipo().unwrap(),\n            TrianguloTipo::Equilatero\n        );\n        assert_eq!(\n            Triangulo::new(2, 7, 1).determinar_tipo().unwrap(),\n            TrianguloTipo::Escaleno\n        );\n\n        assert_eq!(\n            Triangulo::new(2, 2, 1).determinar_tipo().unwrap(),\n            TrianguloTipo::Isosceles\n        );\n    }\n\n    #[test]\n    fn calcula_correctamente_el_area_del_rectangulo() {\n        assert_eq!(\n            Triangulo::new(5, 5, 5).calcular_area(),\n            (f64::sqrt(3.0) / 4.0) * (5.0_f64.powf(2.0))\n        );\n        assert_eq!(\n            Triangulo::new(7, 2, 6).calcular_area(),\n            (f64::sqrt(3.0) / 4.0) * (2.0_f64.powf(2.0))\n        );\n    }\n\n    #[test]\n    fn calcular_correctamente_perimetro_del_triangulo() {\n        assert_eq!(Triangulo::new(5, 5, 5).calcular_perimetro(), 15);\n        assert_eq!(Triangulo::new(2, 7, 9).calcular_perimetro(), 18);\n        assert_eq!(Triangulo::new(2, 3, 5).calcular_perimetro(), 10);\n    }\n}\n","traces":[{"line":16,"address":[1059232],"length":1,"stats":{"Line":1}},{"line":20,"address":[1059264],"length":1,"stats":{"Line":1}},{"line":21,"address":[1059274,1059304,1059327],"length":1,"stats":{"Line":3}},{"line":22,"address":[1059314],"length":1,"stats":{"Line":1}},{"line":23,"address":[1059356,1059334,1059288],"length":1,"stats":{"Line":3}},{"line":24,"address":[1059343],"length":1,"stats":{"Line":1}},{"line":25,"address":[1059392,1059378],"length":1,"stats":{"Line":1}},{"line":26,"address":[1059423],"length":1,"stats":{"Line":1}},{"line":28,"address":[1059387],"length":1,"stats":{"Line":0}},{"line":32,"address":[1059456],"length":1,"stats":{"Line":1}},{"line":33,"address":[1059470,1059550],"length":1,"stats":{"Line":1}},{"line":36,"address":[1059568],"length":1,"stats":{"Line":1}},{"line":37,"address":[1059582,1059651],"length":1,"stats":{"Line":1}}],"covered":12,"coverable":13},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej5.rs"],"content":"#[derive(Debug, PartialEq)]\npub struct Producto {\n    pub nombre: String,\n    pub precio_bruto: f32,\n    pub numero_ident: u64,\n}\n\nimpl Producto {\n    pub fn new(nombre: String, precio_bruto: f32, numero_ident: u64) -\u003e Self {\n        Producto {\n            nombre,\n            precio_bruto,\n            numero_ident,\n        }\n    }\n\n    pub fn calcular_impuestos(\u0026self, porcentaje_de_impuestos: f32) -\u003e f32 {\n        self.precio_bruto * (porcentaje_de_impuestos / 100.0)\n    }\n\n    pub fn aplicar_descuento(\u0026self, porcentaje_de_descuento: f32) -\u003e f32 {\n        self.precio_bruto * (porcentaje_de_descuento / 100.0)\n    }\n\n    pub fn calcular_precio_total(\n        \u0026self,\n        porcentaje_de_impuestos: Option\u003cf32\u003e,\n        porcentaje_de_descuento: Option\u003cf32\u003e,\n    ) -\u003e f32 {\n        if let Some(descuento) = porcentaje_de_descuento {\n            if let Some(impuesto) = porcentaje_de_impuestos {\n                return self.precio_bruto + self.calcular_impuestos(impuesto)\n                    - self.aplicar_descuento(descuento);\n            } else {\n                return self.precio_bruto - self.aplicar_descuento(descuento);\n            }\n        } else if let Some(impuesto) = porcentaje_de_impuestos {\n            return self.precio_bruto + self.calcular_impuestos(impuesto);\n        } else {\n            self.precio_bruto\n        }\n\n        /*\n           Lo mismo pero mas aburrido ._.\n\n           let mut total = self.precio_bruto;\n           if porcentaje_de_descuento.is_some() {\n               total = -self.aplicar_descuento(porcentaje_de_descuento.unwrap());\n           }\n           if porcentaje_de_impuestos.is_some() {\n               total += self.calcular_impuestos(porcentaje_de_impuestos.unwrap())\n           }\n           total\n        */\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_nuevo_producto_correctamente() {\n        assert_eq!(\n            Producto::new(\"Nodemcu Esp32\".to_string(), 14990.00, 3032192),\n            Producto {\n                nombre: \"Nodemcu Esp32\".to_string(),\n                precio_bruto: 14990.00,\n                numero_ident: 3032192\n            }\n        );\n    }\n\n    #[test]\n    fn calcula_impuestos_de_producto_correctamente() {\n        assert_eq!(\n            Producto::new(\"Nodemcu Esp32\".to_string(), 14990.00, 3032192).calcular_impuestos(20.00),\n            14990.00 * (20.00 / 100.0)\n        );\n    }\n\n    #[test]\n    fn calcula_descuento_de_producto_correctamente() {\n        assert_eq!(\n            Producto::new(\"Nodemcu Esp32\".to_string(), 14990.00, 3032192).aplicar_descuento(35.00),\n            14990.00 * (35.00 / 100.0)\n        );\n    }\n\n    #[test]\n    fn calcula_correctamente_precio_total_de_producto() {\n        assert_eq!(\n            Producto::new(\"Nodemcu Esp32\".to_string(), 14990.00, 3032192)\n                .calcular_precio_total(Some(20.00), None),\n            14990.00 + (14990.00 * (20.00 / 100.0)),\n            \"El precio total no se calculo como se esperaba (20% impuestos y 0% descuento)\"\n        );\n\n        assert_eq!(\n            Producto::new(\"Nodemcu Esp32\".to_string(), 14990.00, 3032192)\n                .calcular_precio_total(None, Some(35.00)),\n            14990.00 - (14990.00 * (35.00 / 100.0)),\n            \"El precio total no se calculo como se esperaba (0% impuestos y 35% descuento)\"\n        );\n\n        assert_eq!(\n            Producto::new(\"Nodemcu Esp32\".to_string(), 14990.00, 3032192)\n                .calcular_precio_total(Some(20.00), Some(35.00)),\n            14990.00 - (14990.00 * (35.00 / 100.0)) + (14990.00 * (20.00 / 100.0)),\n            \"El precio total no se calculo como se esperaba (20% impuestos y 35% descuento)\"\n        );\n    }\n}\n","traces":[{"line":9,"address":[593472],"length":1,"stats":{"Line":1}},{"line":17,"address":[593520],"length":1,"stats":{"Line":1}},{"line":18,"address":[593534],"length":1,"stats":{"Line":1}},{"line":21,"address":[593568],"length":1,"stats":{"Line":2}},{"line":22,"address":[593582],"length":1,"stats":{"Line":2}},{"line":25,"address":[593616],"length":1,"stats":{"Line":1}},{"line":30,"address":[593650],"length":1,"stats":{"Line":1}},{"line":31,"address":[593714,593678],"length":1,"stats":{"Line":2}},{"line":32,"address":[593726,593786],"length":1,"stats":{"Line":2}},{"line":33,"address":[593772],"length":1,"stats":{"Line":1}},{"line":35,"address":[593809],"length":1,"stats":{"Line":1}},{"line":37,"address":[593860,593690,593925],"length":1,"stats":{"Line":2}},{"line":38,"address":[593872],"length":1,"stats":{"Line":1}},{"line":40,"address":[593914],"length":1,"stats":{"Line":0}}],"covered":13,"coverable":14},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej6.rs"],"content":"#[derive(Debug, PartialEq)]\npub struct Examen {\n    pub nombre_materia: String,\n    pub nota: u8,\n}\n\npub struct Informe {\n    nombre: String,\n    numero_ident: u64,\n    total_examenes_rendidos: usize,\n    promedio_general_notas: f64,\n    nota_mas_alta: (u8, String),\n    nota_mas_baja: (u8, String),\n}\n\n#[derive(Debug, PartialEq)]\npub struct Estudiante {\n    pub nombre: String,\n    pub numero_ident: u64,\n    pub calificaciones: Vec\u003cExamen\u003e,\n}\n\nimpl Examen {\n    pub fn new(nombre_materia: String, nota: u8) -\u003e Self {\n        Examen {\n            nombre_materia,\n            nota,\n        }\n    }\n}\n\nimpl Estudiante {\n    pub fn new(nombre: String, numero_ident: u64, calificaciones: Vec\u003cExamen\u003e) -\u003e Estudiante {\n        Estudiante {\n            nombre,\n            numero_ident,\n            calificaciones,\n        }\n    }\n\n    pub fn obtener_promedio(\u0026self) -\u003e f64 {\n        let total: u32 = self.calificaciones.iter().map(|f| f.nota as u32).sum();\n        let cantidad = self.calificaciones.len() as f64;\n\n        if cantidad == 0.0 {\n            0.0\n        } else {\n            total as f64 / cantidad\n        }\n    }\n\n    pub fn obtener_calificacion_mas_alta(\u0026self) -\u003e u8 {\n        self.calificaciones\n            .iter()\n            .map(|f| f.nota)\n            .max()\n            .unwrap_or(0)\n    }\n\n    pub fn obtener_calificacion_mas_baja(\u0026self) -\u003e u8 {\n        self.calificaciones\n            .iter()\n            .map(|f| f.nota)\n            .min()\n            .unwrap_or(0)\n    }\n\n    pub fn generar_informe(\u0026self) -\u003e Option\u003cInforme\u003e {\n        if self.calificaciones.is_empty() {\n            None\n        } else {\n            Some(Informe {\n                nombre: self.nombre.clone(),\n                numero_ident: self.numero_ident,\n                total_examenes_rendidos: self.calificaciones.iter().count(),\n                promedio_general_notas: self.calificaciones.iter().count() as f64\n                    / self.calificaciones.iter().fold(0, |acc, x| acc + x.nota) as f64,\n                nota_mas_alta: (0, \"todo\".to_owned()),\n                nota_mas_baja: (0, \"todo\".to_owned()),\n            })\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn obtiene_promedio_correctamente() {\n        let mut calificaciones: Vec\u003cExamen\u003e = Vec::new();\n        calificaciones.push(Examen::new(\"Matemática\".to_owned(), 8));\n        calificaciones.push(Examen::new(\"Historia\".to_owned(), 10));\n        let estudiante = Estudiante::new(\"Calamardo\".to_owned(), 42, calificaciones);\n\n        assert_eq!(\n            estudiante.obtener_promedio(),\n            9.0,\n            \"El promedio no se calculo como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn obtiene_calificacion_mas_alta_correctamente() {\n        let mut calificaciones: Vec\u003cExamen\u003e = Vec::new();\n        calificaciones.push(Examen::new(\"Matemática\".to_owned(), 8));\n        calificaciones.push(Examen::new(\"Historia\".to_owned(), 10));\n        let estudiante = Estudiante::new(\"Calamardo\".to_owned(), 42, calificaciones);\n\n        assert_eq!(\n            estudiante.obtener_calificacion_mas_alta(),\n            10,\n            \"No se obtubo el elemento esperado\"\n        );\n    }\n\n    #[test]\n    fn obtiene_calificacion_mas_baja_correctamente() {\n        let mut calificaciones: Vec\u003cExamen\u003e = Vec::new();\n        calificaciones.push(Examen::new(\"Matemática\".to_owned(), 8));\n        calificaciones.push(Examen::new(\"Historia\".to_owned(), 10));\n        let estudiante = Estudiante::new(\"Calamardo\".to_owned(), 42, calificaciones);\n\n        assert_eq!(\n            estudiante.obtener_calificacion_mas_baja(),\n            8,\n            \"No se obtubo el elemento esperado\"\n        );\n    }\n}\n","traces":[{"line":24,"address":[632096],"length":1,"stats":{"Line":1}},{"line":33,"address":[632144],"length":1,"stats":{"Line":1}},{"line":41,"address":[632208],"length":1,"stats":{"Line":1}},{"line":42,"address":[632217],"length":1,"stats":{"Line":3}},{"line":43,"address":[632277],"length":1,"stats":{"Line":1}},{"line":45,"address":[632333,632373],"length":1,"stats":{"Line":2}},{"line":46,"address":[632375],"length":1,"stats":{"Line":0}},{"line":48,"address":[632356],"length":1,"stats":{"Line":1}},{"line":52,"address":[632400],"length":1,"stats":{"Line":1}},{"line":53,"address":[632405],"length":1,"stats":{"Line":1}},{"line":55,"address":[1069792,1069802],"length":1,"stats":{"Line":2}},{"line":60,"address":[632480],"length":1,"stats":{"Line":1}},{"line":61,"address":[632485],"length":1,"stats":{"Line":1}},{"line":63,"address":[1069808,1069818],"length":1,"stats":{"Line":2}},{"line":68,"address":[632560,633498],"length":1,"stats":{"Line":0}},{"line":69,"address":[632713,632610],"length":1,"stats":{"Line":0}},{"line":70,"address":[632700],"length":1,"stats":{"Line":0}},{"line":72,"address":[633263],"length":1,"stats":{"Line":0}},{"line":73,"address":[632631],"length":1,"stats":{"Line":0}},{"line":74,"address":[632656],"length":1,"stats":{"Line":0}},{"line":75,"address":[632778,632665],"length":1,"stats":{"Line":0}},{"line":76,"address":[633041,632825],"length":1,"stats":{"Line":0}},{"line":77,"address":[632953],"length":1,"stats":{"Line":0}},{"line":78,"address":[633050],"length":1,"stats":{"Line":0}},{"line":79,"address":[633207,633117],"length":1,"stats":{"Line":0}}],"covered":13,"coverable":25},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej7.rs"],"content":"#[derive(PartialEq, Debug, Clone)]\npub enum ColorAuto {\n    Rojo,\n    Verde,\n    Azul,\n    Amarillo,\n    Blanco,\n    Negro,\n}\n\n#[derive(PartialEq, Debug, Clone)]\npub struct Auto {\n    pub marca: String,\n    pub modelo: String,\n    pub anio: u32,\n    pub precio_bruto: f64,\n    pub color: ColorAuto,\n}\n\nimpl Auto {\n    pub fn new(\n        marca: String,\n        modelo: String,\n        anio: u32,\n        precio_bruto: f64,\n        color: ColorAuto,\n    ) -\u003e Self {\n        Auto {\n            marca,\n            modelo,\n            anio,\n            precio_bruto,\n            color,\n        }\n    }\n\n    pub fn calcular_precio(\u0026self) -\u003e f64 {\n        let mut total: f64 = self.precio_bruto;\n        match self.color {\n            ColorAuto::Rojo | ColorAuto::Verde | ColorAuto::Amarillo =\u003e {\n                total += self.precio_bruto * 25.0 / 100.0\n            }\n            _ =\u003e total -= self.precio_bruto * 10.0 / 100.0,\n        };\n        if self.marca == \"BMW\" {\n            total += self.precio_bruto * 15.0 / 100.0;\n        }\n        if self.anio \u003c 2000 {\n            total -= self.precio_bruto * 5.0 / 100.0;\n        }\n        total\n    }\n}\n\n#[derive(Debug, PartialEq)]\npub struct ConcesionarioAuto {\n    pub nombre: String,\n    pub direccion: String,\n    pub capacidad_max: usize,\n    pub autos: Vec\u003cAuto\u003e,\n}\n\nimpl ConcesionarioAuto {\n    pub fn new(nombre: String, direccion: String, capacidad_max: usize, autos: Vec\u003cAuto\u003e) -\u003e Self {\n        ConcesionarioAuto {\n            nombre,\n            direccion,\n            capacidad_max,\n            autos,\n        }\n    }\n\n    pub fn agregar_auto(\u0026mut self, auto: Auto) {\n        if self.autos.len() \u003c self.capacidad_max {\n            self.autos.push(auto);\n        }\n    }\n\n    pub fn eliminar_auto(\u0026mut self, auto: Auto) {\n        if let Some(pos) = self.autos.iter().position(|f| *f == auto) {\n            self.autos.remove(pos);\n        }\n    }\n\n    pub fn buscar_auto(\u0026self, auto: Auto) -\u003e Option\u003cAuto\u003e {\n        if let Some(pos) = self.autos.iter().position(|f| *f == auto) {\n            Some(self.autos[pos].clone())\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_nuevo_concesionario_auto_correctamente() {\n        assert_eq!(\n            ConcesionarioAuto::new(\n                \"Concesionario 44\".to_owned(),\n                \"44 13 y 14\".to_owned(),\n                5,\n                Vec::new()\n            ),\n            ConcesionarioAuto {\n                nombre: \"Concesionario 44\".to_owned(),\n                direccion: \"44 13 y 14\".to_owned(),\n                capacidad_max: 5,\n                autos: Vec::new()\n            },\n            \"No se creo el objeto como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn agregar_auto_a_concesionario_correctamente() {\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            5,\n            Vec::new(),\n        );\n        conce.agregar_auto(Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        });\n        assert_eq!(\n            conce.autos.len(),\n            1,\n            \"No se agrego el auto al concesionario como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn eliminar_auto_de_concesionario_correctamente() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            5,\n            Vec::new(),\n        );\n        conce.agregar_auto(auto.clone());\n        assert_eq!(conce.autos.len(), 1,);\n        conce.eliminar_auto(auto);\n        assert_eq!(\n            conce.autos.len(),\n            0,\n            \"No se elimino el auto al concesionario como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn buscar_auto_en_concesionario_correctamente() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            5,\n            Vec::new(),\n        );\n        conce.agregar_auto(auto.clone());\n\n        assert_eq!(\n            conce.buscar_auto(auto.clone()),\n            Some(auto),\n            \"No se encontro el auto en el concesionario como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn calcular_precio_de_auto_correctamente() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n\n        assert_eq!(\n            auto.calcular_precio(),\n            40_500.0,\n            \"No se calculo el precio del auto como se esperaba\"\n        );\n    }\n}\n","traces":[{"line":21,"address":[653328],"length":1,"stats":{"Line":0}},{"line":37,"address":[653440],"length":1,"stats":{"Line":1}},{"line":38,"address":[653454],"length":1,"stats":{"Line":1}},{"line":39,"address":[653465],"length":1,"stats":{"Line":1}},{"line":41,"address":[653548],"length":1,"stats":{"Line":1}},{"line":43,"address":[653500],"length":1,"stats":{"Line":0}},{"line":45,"address":[653664,653590],"length":1,"stats":{"Line":2}},{"line":46,"address":[653627],"length":1,"stats":{"Line":1}},{"line":48,"address":[653723,653611],"length":1,"stats":{"Line":2}},{"line":49,"address":[653682],"length":1,"stats":{"Line":1}},{"line":51,"address":[653666],"length":1,"stats":{"Line":1}},{"line":64,"address":[653728],"length":1,"stats":{"Line":1}},{"line":73,"address":[654049,653824,654027],"length":1,"stats":{"Line":1}},{"line":74,"address":[653846,653917],"length":1,"stats":{"Line":2}},{"line":75,"address":[653942],"length":1,"stats":{"Line":1}},{"line":79,"address":[654320,654064],"length":1,"stats":{"Line":1}},{"line":80,"address":[654157,654089],"length":1,"stats":{"Line":4}},{"line":81,"address":[654313,654267],"length":1,"stats":{"Line":2}},{"line":85,"address":[654674,654352],"length":1,"stats":{"Line":1}},{"line":86,"address":[654395,654463,654613],"length":1,"stats":{"Line":4}},{"line":87,"address":[654624,654573],"length":1,"stats":{"Line":2}},{"line":89,"address":[654600],"length":1,"stats":{"Line":0}}],"covered":19,"coverable":22},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej8.rs"],"content":"#[derive(Debug, PartialEq, Clone)]\npub enum Genero {\n    Rock,\n    Pop,\n    Rap,\n    Jazz,\n    Otros,\n}\n\n#[derive(Debug, PartialEq, Clone)]\npub struct Cancion {\n    pub titulo: String,\n    pub artista: String,\n    pub genero: Genero,\n}\n\npub struct Playlist {\n    pub canciones: Vec\u003cCancion\u003e,\n    pub nombre: String,\n}\n\nimpl Playlist {\n    pub fn agregar_cancion(\u0026mut self, cancion: Cancion) {\n        self.canciones.push(cancion);\n    }\n\n    pub fn eliminar_cancion(\u0026mut self, cancion: Cancion) {\n        if let Some(pos) = self.canciones.iter().position(|f| *f == cancion) {\n            self.canciones.remove(pos);\n        }\n    }\n\n    pub fn mover_cancion(\u0026mut self, cancion: Cancion, posicion: usize) {\n        if let Some(pos) = self.canciones.iter().position(|f| *f == cancion) {\n            let cancion = self.canciones.remove(pos);\n            let nueva_posicion = if posicion \u003e self.canciones.len() {\n                self.canciones.len()\n            } else {\n                posicion\n            };\n\n            self.canciones.insert(nueva_posicion, cancion);\n        }\n    }\n\n    pub fn buscar_cancion_por_nombre(\u0026self, cancion: Cancion) -\u003e Option\u003c\u0026Cancion\u003e {\n        self.canciones.iter().find(|f| **f == cancion)\n    }\n\n    pub fn obtener_canciones_por_genero(\u0026self, genero: Genero) -\u003e Vec\u003c\u0026Cancion\u003e {\n        self.canciones\n            .iter()\n            .filter(|f| f.genero == genero)\n            .collect()\n    }\n\n    pub fn obtener_canciones_por_artista(\u0026self, artista: String) -\u003e Vec\u003c\u0026Cancion\u003e {\n        self.canciones\n            .iter()\n            .filter(|f| f.artista == artista)\n            .collect()\n    }\n\n    pub fn modificar_titulo(\u0026mut self, titulo: String) {\n        self.nombre = titulo;\n    }\n\n    pub fn limpiar_playlist(\u0026mut self) {\n        self.canciones.clear();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn agrega_cancion_a_playlist_correctamente() {\n        let cancion = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion.clone());\n\n        assert_eq!(\n            playlist.canciones[0], cancion,\n            \"No se agrego la cancion a la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn elimina_cancion_de_playlist_correctamente() {\n        let cancion = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion.clone());\n        playlist.eliminar_cancion(cancion);\n\n        assert_eq!(\n            playlist.canciones.len(),\n            0,\n            \"No se elimino la cancion de la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn mueve_cancion_a_una_determinada_posicion_de_la_playlist() {\n        let cancion_1 = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n        let cancion_2 = Cancion {\n            titulo: \"Trance Awake\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Lacuna Coil\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion_1.clone());\n        playlist.agregar_cancion(cancion_2);\n\n        playlist.mover_cancion(cancion_1.clone(), 1);\n\n        assert_eq!(\n            playlist.canciones[1], cancion_1,\n            \"No se movio la cancion de la playlist a la posicion que se esperaba\"\n        );\n    }\n\n    #[test]\n    fn busca_cancion_por_nombre_en_playlist() {\n        let cancion = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion.clone());\n\n        assert_eq!(\n            playlist\n                .buscar_cancion_por_nombre(cancion.clone())\n                .unwrap()\n                .to_owned(),\n            cancion,\n            \"No se encontro la cancion en la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn obtener_canciones_por_genero_en_playlist() {\n        let cancion_1 = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n        let cancion_2 = Cancion {\n            titulo: \"Trance Awake\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Lacuna Coil\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion_1.clone());\n        playlist.agregar_cancion(cancion_2.clone());\n\n        let mut expected = Vec::\u003c\u0026Cancion\u003e::new();\n        expected.push(\u0026cancion_1);\n        expected.push(\u0026cancion_2);\n\n        assert_eq!(\n            playlist.obtener_canciones_por_genero(Genero::Otros),\n            expected,\n            \"No se obtuvieron las canciones de la playlist por genero como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn obtener_canciones_por_artista_en_playlist() {\n        let cancion_1 = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n        let cancion_2 = Cancion {\n            titulo: \"Trance Awake\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Lacuna Coil\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion_1.clone());\n        playlist.agregar_cancion(cancion_2.clone());\n\n        let mut expected = Vec::\u003c\u0026Cancion\u003e::new();\n        expected.push(\u0026cancion_2);\n\n        assert_eq!(\n            playlist.obtener_canciones_por_artista(\"Lacuna Coil\".to_owned()),\n            expected,\n            \"No se obtuvieron las canciones de la playlist por artista como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn modificar_titulo_de_playlist() {\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.modificar_titulo(\"Metal only\".to_owned());\n\n        assert_eq!(\n            playlist.nombre,\n            \"Metal only\".to_owned(),\n            \"No se cambio el título de la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn eliminar_canciones_de_playlist() {\n        let cancion_1 = Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        };\n        let cancion_2 = Cancion {\n            titulo: \"Trance Awake\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Lacuna Coil\".to_owned(),\n        };\n\n        let mut playlist = Playlist {\n            nombre: \"Mi Playlist\".to_owned(),\n            canciones: Vec::new(),\n        };\n        playlist.agregar_cancion(cancion_1.clone());\n        playlist.agregar_cancion(cancion_2.clone());\n\n        playlist.limpiar_playlist();\n\n        assert_eq!(\n            playlist.canciones,\n            Vec::\u003cCancion\u003e::new(),\n            \"No se eliminaron todas las canciones de la playlist como se esperaba\"\n        );\n    }\n}\n","traces":[{"line":23,"address":[942400],"length":1,"stats":{"Line":1}},{"line":24,"address":[942405],"length":1,"stats":{"Line":1}},{"line":27,"address":[942432,942678],"length":1,"stats":{"Line":1}},{"line":28,"address":[661577,661552],"length":1,"stats":{"Line":4}},{"line":29,"address":[942671,942629],"length":1,"stats":{"Line":2}},{"line":33,"address":[943230,942704],"length":1,"stats":{"Line":1}},{"line":34,"address":[942814,943207,942742],"length":1,"stats":{"Line":5}},{"line":35,"address":[942924,942969],"length":1,"stats":{"Line":2}},{"line":36,"address":[942977,943040,943058],"length":1,"stats":{"Line":3}},{"line":37,"address":[943189,943065],"length":1,"stats":{"Line":0}},{"line":39,"address":[943050],"length":1,"stats":{"Line":1}},{"line":42,"address":[943082],"length":1,"stats":{"Line":1}},{"line":46,"address":[943264,943410],"length":1,"stats":{"Line":1}},{"line":47,"address":[661648,661665],"length":1,"stats":{"Line":4}},{"line":50,"address":[943440],"length":1,"stats":{"Line":1}},{"line":51,"address":[943478],"length":1,"stats":{"Line":1}},{"line":53,"address":[661713,661696],"length":1,"stats":{"Line":2}},{"line":57,"address":[943730,943552],"length":1,"stats":{"Line":1}},{"line":58,"address":[943589,943648],"length":1,"stats":{"Line":2}},{"line":60,"address":[661761,661744],"length":1,"stats":{"Line":2}},{"line":64,"address":[943817,943760],"length":1,"stats":{"Line":1}},{"line":65,"address":[943852,943778],"length":1,"stats":{"Line":2}},{"line":68,"address":[943888],"length":1,"stats":{"Line":1}},{"line":69,"address":[943893],"length":1,"stats":{"Line":1}}],"covered":23,"coverable":24},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","ej9.rs"],"content":"use super::ej3::Fecha;\nuse std::collections::VecDeque;\n\n#[derive(Debug, Eq, Ord, PartialEq, PartialOrd, Clone)]\npub enum TipoAnimal {\n    Perro,\n    Gato,\n    Caballo,\n    Otros,\n}\n\n#[derive(Debug, Eq, Ord, PartialEq, PartialOrd, Clone)]\npub struct Atencion {\n    pub mascota: Mascota,\n    pub diagnostico_final: String,\n    pub tratamiento: String,\n    pub fecha_proxima_visita: Option\u003cFecha\u003e,\n}\n\n#[derive(Debug, Eq, Ord, PartialEq, PartialOrd, Clone)]\npub struct Propietario {\n    pub nombre: String,\n    pub direccion: String,\n    pub telefono: u32,\n}\n\n#[derive(Debug, PartialEq)]\npub struct Veterinaria {\n    pub nombre: String,\n    pub direccion: String,\n    pub id: u32,\n    pub registro_atenciones: Vec\u003cAtencion\u003e,\n    pub cola_atencion: VecDeque\u003cMascota\u003e,\n    pub mascota_actual: Option\u003cMascota\u003e,\n}\n\n#[derive(Debug, Eq, Ord, PartialEq, PartialOrd, Clone)]\npub struct Mascota {\n    pub nombre: String,\n    pub edad: u8,\n    pub tipo_animal: TipoAnimal,\n    pub propietario: Propietario,\n}\n\nimpl Veterinaria {\n    pub fn new(nombre: String, direccion: String, id: u32) -\u003e Self {\n        Veterinaria {\n            nombre,\n            direccion,\n            id,\n            registro_atenciones: Vec::\u003cAtencion\u003e::new(),\n            cola_atencion: VecDeque::\u003cMascota\u003e::new(),\n            mascota_actual: None,\n        }\n    }\n\n    pub fn agregar_a_cola_de_atencion(\u0026mut self, mascota: Mascota) {\n        self.cola_atencion.push_back(mascota);\n    }\n\n    pub fn agregar_a_cola_de_atencion_prioridad(\u0026mut self, mascota: Mascota) {\n        self.cola_atencion.push_front(mascota);\n    }\n\n    pub fn atender_siguiente_mascota(\u0026mut self) {\n        self.mascota_actual = self.cola_atencion.pop_front();\n    }\n\n    pub fn eliminar_mascota_de_cola(\u0026mut self, mascota: Mascota) {\n        if let Some(pos) = self.cola_atencion.iter().position(|f| *f == mascota) {\n            self.cola_atencion.remove(pos);\n        }\n    }\n\n    pub fn registrar_atencion(\n        \u0026mut self,\n        diagnostico_final: String,\n        tratamiento: String,\n        fecha_proxima_visita: Option\u003cFecha\u003e,\n    ) {\n        if let Some(mascota) = \u0026self.mascota_actual {\n            self.registro_atenciones.push(Atencion {\n                mascota: mascota.to_owned(),\n                diagnostico_final,\n                tratamiento,\n                fecha_proxima_visita,\n            });\n        }\n    }\n\n    pub fn buscar_atencion(\n        \u0026self,\n        nombre_mascota: String,\n        nombre_propietario: String,\n        telefono: u32,\n    ) -\u003e Option\u003cAtencion\u003e {\n        if let Some(pos) = self.registro_atenciones.iter().position(|f| {\n            *f.mascota.nombre == nombre_mascota\n                \u0026\u0026 *f.mascota.propietario.nombre == nombre_propietario\n                \u0026\u0026 f.mascota.propietario.telefono == telefono\n        }) {\n            Some(self.registro_atenciones[pos].to_owned())\n        } else {\n            None\n        }\n    }\n\n    pub fn modificar_diagnostico(\u0026mut self, indice_atencion: usize, diagnostico_final: String) {\n        if let Some(atencion) = self.registro_atenciones.get_mut(indice_atencion) {\n            atencion.diagnostico_final = diagnostico_final;\n        }\n    }\n\n    pub fn modificar_fecha_proxima_visita(\u0026mut self, indice_atencion: usize, fecha: Option\u003cFecha\u003e) {\n        if let Some(atencion) = self.registro_atenciones.get_mut(indice_atencion) {\n            atencion.fecha_proxima_visita = fecha;\n        }\n    }\n\n    pub fn eliminar_atencion(\u0026mut self, indice_atencion: usize) {\n        if self.registro_atenciones.get(indice_atencion).is_some() {\n            self.registro_atenciones.remove(indice_atencion);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_nueva_veterinaria_correctamente() {\n        let vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        assert_eq!(\n            vete,\n            Veterinaria {\n                nombre: \"Vet01\".to_owned(),\n                direccion: \"44 n552\".to_owned(),\n                id: 32,\n                registro_atenciones: Vec::\u003cAtencion\u003e::new(),\n                cola_atencion: VecDeque::\u003cMascota\u003e::new(),\n                mascota_actual: None,\n            },\n            \"No se creo el objeto veterinaria como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn agregar_a_cola_de_atencion_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        assert!(\n            vete.cola_atencion.contains(\u0026mascota),\n            \"No se agrego la mascota a la cola de atencion como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn agregar_a_cola_de_atencion_prioridad_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        assert!(\n            vete.cola_atencion[0] == mascota_2,\n            \"No se agrego la mascota a la cola de atencion con prioridad como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn atender_siguiente_mascota_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.atender_siguiente_mascota();\n\n        assert!(\n            vete.cola_atencion[0] == mascota.clone(),\n            \"No se quito la mascota a la cola de atencion como se esperaba\"\n        );\n        assert!(\n            vete.mascota_actual == Some(mascota_2),\n            \"No se agrego la mascota como mascota actual como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn eliminar_mascota_de_cola_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.eliminar_mascota_de_cola(mascota);\n        assert!(\n            vete.cola_atencion.len() == 1,\n            \"No se elimino la mascota de la cola de atencion como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn registrar_atencion_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.atender_siguiente_mascota();\n        vete.registrar_atencion(\n            \"Mala alimentacion\".to_owned(),\n            \"Mejor alimento\".to_owned(),\n            Fecha::new(20, 06, 2025),\n        );\n        assert!(\n            vete.registro_atenciones.len() == 1,\n            \"No se registro una nueva atencion como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn buscar_atencion_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.atender_siguiente_mascota();\n        vete.registrar_atencion(\n            \"Mala alimentacion\".to_owned(),\n            \"Mejor alimento\".to_owned(),\n            Fecha::new(20, 06, 2025),\n        );\n        assert!(\n            vete.buscar_atencion(\"Picudo\".to_owned(), \"Pedro\".to_owned(), 726123)\n                .is_some(),\n            \"No se encontro la atencion guardada en el registro como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn modificar_diagnostico_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.atender_siguiente_mascota();\n        vete.registrar_atencion(\n            \"Mala alimentacion\".to_owned(),\n            \"Mejor alimento\".to_owned(),\n            Fecha::new(20, 06, 2025),\n        );\n        vete.modificar_diagnostico(0, \"Mal aliento\".to_owned());\n        assert!(\n            vete.buscar_atencion(\"Picudo\".to_owned(), \"Pedro\".to_owned(), 726123)\n                .unwrap()\n                .diagnostico_final\n                == \"Mal aliento\".to_owned(),\n            \"No se modifico el diagnostico en la atencion registrada como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn modificar_fecha_proxima_visita_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.atender_siguiente_mascota();\n        vete.registrar_atencion(\n            \"Mala alimentacion\".to_owned(),\n            \"Mejor alimento\".to_owned(),\n            Fecha::new(20, 06, 2025),\n        );\n        vete.modificar_fecha_proxima_visita(0, Fecha::new(20, 05, 2025));\n        assert!(\n            vete.buscar_atencion(\"Picudo\".to_owned(), \"Pedro\".to_owned(), 726123)\n                .unwrap()\n                .fecha_proxima_visita\n                == Fecha::new(20, 05, 2025),\n            \"No se modifico la fecha de proxima visita en la atencion registrada como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn eliminar_atencion_correctamente() {\n        let mut vete = Veterinaria::new(\"Vet01\".to_owned(), \"44 n552\".to_owned(), 32);\n        let mascota = Mascota {\n            nombre: \"Rodolfo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Perro,\n            propietario: Propietario {\n                nombre: \"Fabian\".to_owned(),\n                direccion: \"127bis y 22\".to_owned(),\n                telefono: 6271254,\n            },\n        };\n        let mascota_2 = Mascota {\n            nombre: \"Picudo\".to_owned(),\n            edad: 15,\n            tipo_animal: TipoAnimal::Gato,\n            propietario: Propietario {\n                nombre: \"Pedro\".to_owned(),\n                direccion: \"17 y 52\".to_owned(),\n                telefono: 726123,\n            },\n        };\n        vete.agregar_a_cola_de_atencion(mascota.clone());\n        vete.agregar_a_cola_de_atencion_prioridad(mascota_2.clone());\n        vete.atender_siguiente_mascota();\n        vete.registrar_atencion(\n            \"Mala alimentacion\".to_owned(),\n            \"Mejor alimento\".to_owned(),\n            Fecha::new(20, 06, 2025),\n        );\n        vete.eliminar_atencion(0);\n        assert!(\n            vete.registro_atenciones.len() == 0,\n            \"No se elimino la atencion registrada como se esperaba\"\n        );\n    }\n}\n","traces":[{"line":46,"address":[840315,839936,840290],"length":1,"stats":{"Line":1}},{"line":51,"address":[840003],"length":1,"stats":{"Line":1}},{"line":52,"address":[840056],"length":1,"stats":{"Line":2}},{"line":57,"address":[840336],"length":1,"stats":{"Line":2}},{"line":58,"address":[840341],"length":1,"stats":{"Line":2}},{"line":61,"address":[840368],"length":1,"stats":{"Line":1}},{"line":62,"address":[840373],"length":1,"stats":{"Line":2}},{"line":65,"address":[840400,840515],"length":1,"stats":{"Line":1}},{"line":66,"address":[840545,840416],"length":1,"stats":{"Line":4}},{"line":69,"address":[840777,840576],"length":1,"stats":{"Line":1}},{"line":70,"address":[737040,737065],"length":1,"stats":{"Line":4}},{"line":71,"address":[840770,840731],"length":1,"stats":{"Line":2}},{"line":75,"address":[841301,841381,840800],"length":1,"stats":{"Line":1}},{"line":81,"address":[840841],"length":1,"stats":{"Line":1}},{"line":82,"address":[841097,840934],"length":1,"stats":{"Line":2}},{"line":83,"address":[840950],"length":1,"stats":{"Line":1}},{"line":84,"address":[841035],"length":1,"stats":{"Line":1}},{"line":85,"address":[841066],"length":1,"stats":{"Line":1}},{"line":91,"address":[841424,841874],"length":1,"stats":{"Line":1}},{"line":97,"address":[737088],"length":1,"stats":{"Line":3}},{"line":98,"address":[737125],"length":1,"stats":{"Line":1}},{"line":99,"address":[737165],"length":1,"stats":{"Line":1}},{"line":100,"address":[737210],"length":1,"stats":{"Line":1}},{"line":102,"address":[841766,841710],"length":1,"stats":{"Line":2}},{"line":104,"address":[841738],"length":1,"stats":{"Line":0}},{"line":108,"address":[841904,842234,842260],"length":1,"stats":{"Line":1}},{"line":109,"address":[842009,842211,841931],"length":1,"stats":{"Line":3}},{"line":110,"address":[842131,842080],"length":1,"stats":{"Line":1}},{"line":114,"address":[842272],"length":1,"stats":{"Line":1}},{"line":115,"address":[842299],"length":1,"stats":{"Line":1}},{"line":116,"address":[842369],"length":1,"stats":{"Line":1}},{"line":120,"address":[842384],"length":1,"stats":{"Line":1}},{"line":121,"address":[842416],"length":1,"stats":{"Line":1}},{"line":122,"address":[842477],"length":1,"stats":{"Line":1}}],"covered":33,"coverable":34},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp3","mod.rs"],"content":"pub mod ej1;\npub mod ej10;\npub mod ej2;\npub mod ej3;\npub mod ej4;\npub mod ej5;\npub mod ej6;\npub mod ej7;\npub mod ej8;\npub mod ej9;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp4","ej1.rs"],"content":"pub trait I32Primos {\n    fn es_primo(\u0026self) -\u003e bool;\n}\nimpl I32Primos for i32 {\n    fn es_primo(\u0026self) -\u003e bool {\n        if *self \u003c 2 {\n            return false;\n        }\n        if *self == 2 {\n            return true;\n        }\n        if *self % 2 == 0 {\n            return false;\n        }\n        let limite = (*self as f64).sqrt() as i32 + 1;\n        for i in (3..limite).step_by(2) {\n            if *self % i == 0 {\n                return false;\n            }\n        }\n        true\n    }\n}\n\npub fn cant_primos(vec: \u0026[i32]) -\u003e i32 {\n    vec.iter().filter(|\u0026\u0026e| e.es_primo()).count() as i32\n}\n\n#[test]\nfn verifica_cantidad_primos_correctamente() {\n    assert_eq!(cant_primos(\u0026[2, 3, 4, 5, 6, 7]), 4);\n}\n","traces":[{"line":5,"address":[636800],"length":1,"stats":{"Line":1}},{"line":6,"address":[636817],"length":1,"stats":{"Line":1}},{"line":7,"address":[636834],"length":1,"stats":{"Line":0}},{"line":9,"address":[636827],"length":1,"stats":{"Line":1}},{"line":10,"address":[636841],"length":1,"stats":{"Line":1}},{"line":12,"address":[636893,636853],"length":1,"stats":{"Line":2}},{"line":13,"address":[636924],"length":1,"stats":{"Line":1}},{"line":15,"address":[636936,637074],"length":1,"stats":{"Line":1}},{"line":16,"address":[637090,637007,637133],"length":1,"stats":{"Line":2}},{"line":17,"address":[637148],"length":1,"stats":{"Line":0}},{"line":18,"address":[637243],"length":1,"stats":{"Line":0}},{"line":21,"address":[637118],"length":1,"stats":{"Line":1}},{"line":25,"address":[637264],"length":1,"stats":{"Line":1}},{"line":26,"address":[637278],"length":1,"stats":{"Line":3}}],"covered":11,"coverable":14},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp4","ej2.rs"],"content":"#[derive(Debug, Clone)]\npub struct Persona\u003c'a\u003e {\n    nombre: \u0026'a str,\n    apellido: \u0026'a str,\n    direccion: \u0026'a str,\n    ciudad: \u0026'a str,\n    salario: f64,\n    edad: u8,\n}\n\nimpl\u003c'a\u003e PartialEq for Persona\u003c'a\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.nombre == other.nombre\n            \u0026\u0026 self.apellido == other.apellido\n            \u0026\u0026 self.ciudad == other.ciudad\n            \u0026\u0026 self.edad == other.edad\n            \u0026\u0026 self.direccion == other.direccion\n            \u0026\u0026 self.salario == other.salario\n    }\n}\n\npub fn con_salario_mayor\u003c'a\u003e(lista: Vec\u003cPersona\u003c'a\u003e\u003e, min: f64) -\u003e Vec\u003cPersona\u003c'a\u003e\u003e {\n    lista.into_iter().filter(|x| x.salario \u003e min).collect()\n}\n\npub fn edad_mayor_ciudad_igual\u003c'a\u003e(\n    lista: Vec\u003cPersona\u003c'a\u003e\u003e,\n    edad: u8,\n    ciudad: \u0026str,\n) -\u003e Vec\u003cPersona\u003c'a\u003e\u003e {\n    lista\n        .into_iter()\n        .filter(|e| (e.edad \u003e edad) \u0026\u0026 (e.ciudad == ciudad))\n        .collect()\n}\n\npub fn pertenecen_a_ciudad\u003c'a\u003e(lista: Vec\u003cPersona\u003c'a\u003e\u003e, ciudad: \u0026str) -\u003e bool {\n    lista.into_iter().all(|f| f.ciudad == ciudad)\n}\n\npub fn almenos_uno_pertenece\u003c'a\u003e(lista: Vec\u003cPersona\u003c'a\u003e\u003e, ciudad: \u0026str) -\u003e bool {\n    lista.into_iter().any(|f| f.ciudad == ciudad)\n}\n\npub fn existe_en_arreglo\u003c'a\u003e(lista: Vec\u003cPersona\u003c'a\u003e\u003e, persona: Persona\u003c'a\u003e) -\u003e bool {\n    lista.into_iter().find(|e| *e == persona).is_some()\n}\n\npub fn edades\u003c'a\u003e(lista: Vec\u003cPersona\u003c'a\u003e\u003e) -\u003e Vec\u003cu8\u003e {\n    let mut edades: Vec\u003cu8\u003e = Vec::new();\n    lista.into_iter().for_each(|f| edades.push(f.edad));\n    edades\n}\n\npub fn menor_mayor_salario\u003c'a\u003e(lista: Vec\u003cPersona\u003c'a\u003e\u003e) -\u003e Option\u003c(Persona\u003c'a\u003e, Persona\u003c'a\u003e)\u003e {\n    if lista.is_empty() {\n        return None;\n    }\n\n    let menor = lista\n        .iter()\n        .min_by(|a, b| {\n            a.salario\n                .partial_cmp(\u0026b.salario)\n                .unwrap_or(std::cmp::Ordering::Equal)\n                .then_with(|| b.edad.cmp(\u0026a.edad))\n        })\n        .map(|p| p.clone())?;\n\n    let mayor = lista\n        .iter()\n        .max_by(|a, b| {\n            a.salario\n                .partial_cmp(\u0026b.salario)\n                .unwrap_or(std::cmp::Ordering::Equal)\n                .then_with(|| a.edad.cmp(\u0026b.edad)) // mayor edad preferida\n        })\n        .map(|p| p.clone())?;\n\n    Some((menor, mayor))\n}\n\n#[test]\nfn verifica_salario_mayor() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"santiago del estero\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01, persona02.clone()]);\n    let lista_vacia = Vec::new();\n    assert_eq!(\n        con_salario_mayor(lista.clone(), 750_000.00),\n        [persona02.clone()],\n        \"Debería devolver la persona con salario superior al parámetro\"\n    );\n    assert_eq!(\n        con_salario_mayor(lista_vacia, 500_000.00),\n        [],\n        \"Debería devolver una lista vacía\"\n    );\n    assert_eq!(\n        con_salario_mayor(lista, 560_000.00),\n        [persona02],\n        \"Debería devolver solo la pesona con salario superior al parámetro\"\n    );\n}\n\n#[test]\nfn verifica_edad_mayor_ciudad_igual() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"santiago del estero\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01.clone(), persona02]);\n    let lista_vacia = Vec::new();\n    assert_eq!(\n        edad_mayor_ciudad_igual(lista, 21, \"twin peaks\"),\n        [persona01],\n        \"Debería devolver la persona con edad superior al parámetro y ciudad igual al parámetro\"\n    );\n    assert_eq!(\n        edad_mayor_ciudad_igual(lista_vacia, 35, \"Calle falsa 123\"),\n        [],\n        \"Debería devolver una lista vacía\"\n    );\n}\n\n#[test]\nfn verifica_pertenecen_a_ciudad() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"twin peaks\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01.clone(), persona02]);\n    let lista_vacia = Vec::new();\n    assert!(\n        pertenecen_a_ciudad(lista, \"twin peaks\"),\n        \"Debería devolver verdadero una lista con personas de la misma ciudad\"\n    );\n    assert!(\n        pertenecen_a_ciudad(lista_vacia, \"twin peaks\"),\n        \"Debería devolver falso a una lista vacía\"\n    );\n}\n\n#[test]\nfn verifica_almenos_uno_pertenece() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"santiago del estero\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01.clone(), persona02]);\n    let lista_vacia = Vec::new();\n    assert!(\n        almenos_uno_pertenece(lista, \"twin peaks\"),\n        \"Debería devolver verdadero una lista con una persona de la ciudad pasada por parámetro\"\n    );\n    assert!(\n        !almenos_uno_pertenece(lista_vacia, \"twin peaks\"),\n        \"Debería devolver falso a una lista vacía\"\n    );\n}\n\n#[test]\nfn verifica_existe_en_arreglo() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"santiago del estero\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01.clone(), persona02.clone()]);\n    let lista_vacia = Vec::new();\n    assert!(\n        existe_en_arreglo(lista, persona02),\n        \"Debería devolver verdadero una lista que contiene la persona pasada por parámetro\"\n    );\n    assert!(\n        !existe_en_arreglo(lista_vacia, persona01),\n        \"Debería devolver falso a una lista vacía\"\n    );\n}\n\n#[test]\nfn verifica_edades() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"santiago del estero\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01.clone(), persona02.clone()]);\n    let lista_vacia = Vec::new();\n    assert_eq!(\n        edades(lista),\n        [25, 35],\n        \"Debería devolver una lista con las edades de las personas en la lista\"\n    );\n    assert_eq!(\n        edades(lista_vacia),\n        Vec::\u003cu8\u003e::new(),\n        \"Debería devolver una lista vacía\"\n    );\n}\n\n#[test]\nfn verifica_mayor_menor_salario() {\n    let persona01 = Persona {\n        nombre: \"laura\",\n        apellido: \"palmer\",\n        direccion: \"44st \u0026 Washington\",\n        ciudad: \"twin peaks\",\n        salario: 560_000.00,\n        edad: 25,\n    };\n    let persona02 = Persona {\n        nombre: \"karen\",\n        apellido: \"pensiones\",\n        direccion: \"calle falsa 123\",\n        ciudad: \"santiago del estero\",\n        salario: 1_250_000.00,\n        edad: 35,\n    };\n    let lista = Vec::from([persona01.clone(), persona02.clone()]);\n    let lista_vacia = Vec::new();\n    assert_eq!(\n        menor_mayor_salario(lista),\n        Some((persona01.clone(), persona02.clone())),\n        \"Debería devolver Some de una tupla con las personas de menor y mayor salario\"\n    );\n    assert_eq!(\n        menor_mayor_salario(lista_vacia),\n        None,\n        \"Debería devolver None\"\n    );\n}\n","traces":[{"line":12,"address":[576432],"length":1,"stats":{"Line":1}},{"line":13,"address":[576455],"length":1,"stats":{"Line":1}},{"line":14,"address":[576484],"length":1,"stats":{"Line":1}},{"line":15,"address":[576513],"length":1,"stats":{"Line":1}},{"line":16,"address":[576542],"length":1,"stats":{"Line":1}},{"line":17,"address":[576559],"length":1,"stats":{"Line":1}},{"line":18,"address":[576588],"length":1,"stats":{"Line":1}},{"line":22,"address":[576624],"length":1,"stats":{"Line":1}},{"line":23,"address":[576644],"length":1,"stats":{"Line":3}},{"line":26,"address":[576704],"length":1,"stats":{"Line":1}},{"line":31,"address":[576733],"length":1,"stats":{"Line":1}},{"line":33,"address":[949984,950007],"length":1,"stats":{"Line":2}},{"line":37,"address":[576905,576800],"length":1,"stats":{"Line":1}},{"line":38,"address":[576830],"length":1,"stats":{"Line":3}},{"line":41,"address":[576928,577033],"length":1,"stats":{"Line":1}},{"line":42,"address":[576958],"length":1,"stats":{"Line":3}},{"line":45,"address":[577056,577185],"length":1,"stats":{"Line":1}},{"line":46,"address":[577084],"length":1,"stats":{"Line":3}},{"line":49,"address":[577216,577437],"length":1,"stats":{"Line":1}},{"line":50,"address":[577237],"length":1,"stats":{"Line":1}},{"line":51,"address":[577302,577386],"length":1,"stats":{"Line":4}},{"line":52,"address":[577403],"length":1,"stats":{"Line":1}},{"line":55,"address":[578105,577472],"length":1,"stats":{"Line":1}},{"line":56,"address":[577554,577502],"length":1,"stats":{"Line":2}},{"line":57,"address":[577587],"length":1,"stats":{"Line":1}},{"line":60,"address":[578103,577565,577609,577818],"length":1,"stats":{"Line":2}},{"line":62,"address":[950240],"length":1,"stats":{"Line":1}},{"line":63,"address":[950322,950269,950283,950293],"length":1,"stats":{"Line":4}},{"line":64,"address":[950276],"length":1,"stats":{"Line":1}},{"line":65,"address":[950288],"length":1,"stats":{"Line":1}},{"line":66,"address":[950350,950336,950316],"length":1,"stats":{"Line":1}},{"line":68,"address":[950400,950384],"length":1,"stats":{"Line":2}},{"line":70,"address":[578069,577838,577796,578089],"length":1,"stats":{"Line":2}},{"line":72,"address":[950416],"length":1,"stats":{"Line":1}},{"line":73,"address":[950445,950498,950459,950469],"length":1,"stats":{"Line":4}},{"line":74,"address":[950452],"length":1,"stats":{"Line":1}},{"line":75,"address":[950464],"length":1,"stats":{"Line":1}},{"line":76,"address":[950512,950492,950526],"length":1,"stats":{"Line":1}},{"line":78,"address":[950560,950576],"length":1,"stats":{"Line":2}},{"line":80,"address":[577973],"length":1,"stats":{"Line":1}}],"covered":40,"coverable":40},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp4","ej3.rs"],"content":"use std::collections::HashMap;\nuse time::{Date, OffsetDateTime};\n\nstruct App {\n    usuarios: Vec\u003cUsuario\u003e,\n    estadisticas: Estadisticas,\n}\n\nimpl App {\n    pub fn new() -\u003e Self {\n        App {\n            usuarios: Vec::new(),\n            estadisticas: Estadisticas {\n                medio_de_pago_mas_utilizado_subs_activas: None,\n                subscripcion_mas_contratada_subs_activas: None,\n                medio_de_pago_mas_utilizado: None,\n                subscripcion_mas_contratada: None,\n                total_medio_de_pago: HashMap::new(),\n                total_subscripcion: HashMap::new(),\n            },\n        }\n    }\n\n    pub fn create_user(\u0026mut self, subscripcion: Subscripcion, medio_de_pago: MedioDePago) {\n        if let Some(tipo) = subscripcion.tipo {\n            *self\n                .estadisticas\n                .total_subscripcion\n                .entry(tipo)\n                .or_insert(0) += 1;\n        }\n\n        *self\n            .estadisticas\n            .total_medio_de_pago\n            .entry(TipoMedioDePago::from(\u0026medio_de_pago))\n            .or_insert(0) += 1;\n\n        let user = Usuario::new(medio_de_pago, subscripcion);\n        self.usuarios.push(user);\n    }\n\n    pub fn cancel_subscripcion(\u0026mut self, usuario: \u0026Usuario) {\n        if let Some(user) = self.usuarios.iter_mut().find(|x| **x == *usuario) {\n            user.cancel_subscripcion();\n        }\n    }\n\n    pub fn update_stats(\u0026mut self) {\n        let mut med_pago_subs_act: HashMap\u003cTipoMedioDePago, u32\u003e = HashMap::new();\n        let mut sub_mas_cont_subs_act: HashMap\u003cTipoSubscripcion, u32\u003e = HashMap::new();\n\n        for usuario in \u0026self.usuarios {\n            if usuario\n                .subscripcion\n                .last()\n                .expect(\"expected sub\")\n                .tipo\n                .is_some()\n            {\n                if let Some(tipo) = \u0026usuario.subscripcion.last().expect(\"expected sub\").tipo {\n                    *sub_mas_cont_subs_act.entry(*tipo).or_insert(0) += 1;\n                }\n                let tipo_pago = TipoMedioDePago::from(\u0026usuario.medio_de_pago);\n                *med_pago_subs_act.entry(tipo_pago).or_insert(0) += 1;\n            }\n        }\n\n        self.estadisticas.subscripcion_mas_contratada = self\n            .estadisticas\n            .total_subscripcion\n            .clone()\n            .into_iter()\n            .max_by_key(|(_, v)| *v)\n            .map(|(k, _)| k);\n\n        self.estadisticas.medio_de_pago_mas_utilizado = self\n            .estadisticas\n            .total_medio_de_pago\n            .clone()\n            .into_iter()\n            .max_by_key(|(_, v)| *v)\n            .map(|(k, _)| k);\n\n        self.estadisticas.subscripcion_mas_contratada_subs_activas = sub_mas_cont_subs_act\n            .into_iter()\n            .max_by_key(|(_, v)| *v)\n            .map(|(k, _)| k);\n\n        self.estadisticas.medio_de_pago_mas_utilizado_subs_activas = med_pago_subs_act\n            .into_iter()\n            .max_by_key(|(_, v)| *v)\n            .map(|(k, _)| k);\n    }\n}\n\nstruct Estadisticas {\n    medio_de_pago_mas_utilizado_subs_activas: Option\u003cTipoMedioDePago\u003e,\n    subscripcion_mas_contratada_subs_activas: Option\u003cTipoSubscripcion\u003e,\n    medio_de_pago_mas_utilizado: Option\u003cTipoMedioDePago\u003e,\n    subscripcion_mas_contratada: Option\u003cTipoSubscripcion\u003e,\n    total_medio_de_pago: HashMap\u003cTipoMedioDePago, u32\u003e,\n    total_subscripcion: HashMap\u003cTipoSubscripcion, u32\u003e,\n}\n\n#[derive(Eq, Hash, Copy, Clone, Debug)]\nenum TipoSubscripcion {\n    Basic,\n    Clasic,\n    Super,\n}\n\nimpl TipoSubscripcion {\n    pub fn config(\u0026self) -\u003e (f64, u8) {\n        match self {\n            TipoSubscripcion::Basic =\u003e (5.0, 3),\n            TipoSubscripcion::Clasic =\u003e (15.0, 12),\n            TipoSubscripcion::Super =\u003e (25.0, 24),\n        }\n    }\n}\n\nimpl PartialEq for TipoSubscripcion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        core::mem::discriminant(self) == core::mem::discriminant(other)\n    }\n}\n\n#[derive(Eq, PartialEq, Hash, Debug, Clone)]\nenum TipoMedioDePago {\n    Efectivo,\n    MercadoPago,\n    TarjetaCredito,\n    Transferencia,\n    Cripto,\n}\n\nimpl From\u003c\u0026MedioDePago\u003e for TipoMedioDePago {\n    fn from(m: \u0026MedioDePago) -\u003e Self {\n        match m {\n            MedioDePago::Efectivo =\u003e TipoMedioDePago::Efectivo,\n            MedioDePago::MercadoPago { .. } =\u003e TipoMedioDePago::MercadoPago,\n            MedioDePago::TarjetaCredito { .. } =\u003e TipoMedioDePago::TarjetaCredito,\n            MedioDePago::Transferencia { .. } =\u003e TipoMedioDePago::Transferencia,\n            MedioDePago::Cripto { .. } =\u003e TipoMedioDePago::Cripto,\n        }\n    }\n}\n\n#[derive(Hash, Debug)]\nenum MedioDePago {\n    Efectivo,\n    MercadoPago {\n        cuentamp: String,\n        cbu: String,\n    },\n    TarjetaCredito {\n        numero_tarjeta: u64,\n        numero_seguridad: u32,\n        nombre_titular: String,\n    },\n    Transferencia {\n        numero_cuenta: u64,\n        nombre_titular: String,\n        entidad_bancaria: String,\n    },\n    Cripto {\n        wallet: String,\n        red: String,\n        tipo_token: Option\u003cString\u003e,\n        tx_hash: Option\u003cString\u003e,\n    },\n}\n\nimpl PartialEq for MedioDePago {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (\n                Self::MercadoPago {\n                    cuentamp: l_cuentamp,\n                    cbu: l_cbu,\n                },\n                Self::MercadoPago {\n                    cuentamp: r_cuentamp,\n                    cbu: r_cbu,\n                },\n            ) =\u003e l_cuentamp == r_cuentamp \u0026\u0026 l_cbu == r_cbu,\n            (\n                Self::TarjetaCredito {\n                    numero_tarjeta: l_numero_tarjeta,\n                    numero_seguridad: l_numero_seguridad,\n                    nombre_titular: l_nombre_titular,\n                },\n                Self::TarjetaCredito {\n                    numero_tarjeta: r_numero_tarjeta,\n                    numero_seguridad: r_numero_seguridad,\n                    nombre_titular: r_nombre_titular,\n                },\n            ) =\u003e {\n                l_numero_tarjeta == r_numero_tarjeta\n                    \u0026\u0026 l_numero_seguridad == r_numero_seguridad\n                    \u0026\u0026 l_nombre_titular == r_nombre_titular\n            }\n            (\n                Self::Transferencia {\n                    numero_cuenta: l_numero_cuenta,\n                    nombre_titular: l_nombre_titular,\n                    entidad_bancaria: l_entidad_bancaria,\n                },\n                Self::Transferencia {\n                    numero_cuenta: r_numero_cuenta,\n                    nombre_titular: r_nombre_titular,\n                    entidad_bancaria: r_entidad_bancaria,\n                },\n            ) =\u003e {\n                l_numero_cuenta == r_numero_cuenta\n                    \u0026\u0026 l_nombre_titular == r_nombre_titular\n                    \u0026\u0026 l_entidad_bancaria == r_entidad_bancaria\n            }\n            (\n                Self::Cripto {\n                    wallet: l_wallet,\n                    red: l_red,\n                    tipo_token: l_tipo_token,\n                    tx_hash: l_tx_hash,\n                },\n                Self::Cripto {\n                    wallet: r_wallet,\n                    red: r_red,\n                    tipo_token: r_tipo_token,\n                    tx_hash: r_tx_hash,\n                },\n            ) =\u003e {\n                l_wallet == r_wallet\n                    \u0026\u0026 l_red == r_red\n                    \u0026\u0026 l_tipo_token == r_tipo_token\n                    \u0026\u0026 l_tx_hash == r_tx_hash\n            }\n            _ =\u003e core::mem::discriminant(self) == core::mem::discriminant(other),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct Subscripcion {\n    fecha_inicio: Date,\n    costo_mensual: f64,\n    duracion: u8,\n    tipo: Option\u003cTipoSubscripcion\u003e,\n    activa: bool,\n}\n\nimpl Subscripcion {\n    pub fn new(tipo: Option\u003cTipoSubscripcion\u003e) -\u003e Self {\n        let fecha_inicio = OffsetDateTime::now_utc().date();\n        let activa = tipo.is_some();\n        let (costo_mensual, duracion) = match \u0026tipo {\n            Some(tipo) =\u003e tipo.config(),\n            None =\u003e (0.0, 0),\n        };\n\n        Subscripcion {\n            fecha_inicio,\n            costo_mensual,\n            duracion,\n            tipo,\n            activa,\n        }\n    }\n}\n\nimpl PartialEq for Subscripcion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.fecha_inicio == other.fecha_inicio\n            \u0026\u0026 self.costo_mensual == other.costo_mensual\n            \u0026\u0026 self.duracion == other.duracion\n            \u0026\u0026 self.tipo == other.tipo\n    }\n}\n\n#[derive(Debug)]\nstruct Usuario {\n    subscripcion: Vec\u003cSubscripcion\u003e,\n    medio_de_pago: MedioDePago,\n}\n\nimpl PartialEq for Usuario {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.subscripcion == other.subscripcion \u0026\u0026 self.medio_de_pago == other.medio_de_pago\n    }\n}\n\nimpl Usuario {\n    fn new(medio_de_pago: MedioDePago, subscripcion: Subscripcion) -\u003e Self {\n        Usuario {\n            subscripcion: vec![subscripcion],\n            medio_de_pago,\n        }\n    }\n\n    fn upgrade_sub(\u0026mut self) {\n        if let Some(subscripcion) = self.subscripcion.last_mut() {\n            match subscripcion.tipo {\n                Some(TipoSubscripcion::Basic) =\u003e {\n                    subscripcion.activa = false;\n                    self.subscripcion\n                        .push(Subscripcion::new(Some(TipoSubscripcion::Clasic)));\n                }\n                Some(TipoSubscripcion::Clasic) =\u003e {\n                    subscripcion.activa = false;\n                    self.subscripcion\n                        .push(Subscripcion::new(Some(TipoSubscripcion::Super)));\n                }\n                Some(TipoSubscripcion::Super) =\u003e (),\n                None =\u003e self\n                    .subscripcion\n                    .push(Subscripcion::new(Some(TipoSubscripcion::Basic))),\n            }\n        }\n    }\n\n    fn downgrade_sub(\u0026mut self) {\n        if let Some(subscripcion) = self.subscripcion.last_mut() {\n            match subscripcion.tipo {\n                Some(TipoSubscripcion::Basic) =\u003e {\n                    self.cancel_subscripcion();\n                }\n                Some(TipoSubscripcion::Clasic) =\u003e {\n                    subscripcion.activa = false;\n                    self.subscripcion\n                        .push(Subscripcion::new(Some(TipoSubscripcion::Basic)));\n                }\n                Some(TipoSubscripcion::Super) =\u003e subscripcion.tipo = Some(TipoSubscripcion::Clasic),\n                None =\u003e (),\n            }\n        }\n    }\n\n    fn cancel_subscripcion(\u0026mut self) {\n        if let Some(sub) = self.subscripcion.last_mut() {\n            sub.activa = false;\n            self.subscripcion.push(Subscripcion::new(None));\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn build_fecha() -\u003e Date {\n        OffsetDateTime::now_utc().date()\n    }\n\n    fn build_subscripcion_basic() -\u003e Subscripcion {\n        Subscripcion::new(Some(TipoSubscripcion::Basic))\n    }\n\n    fn build_subscripcion_clasic() -\u003e Subscripcion {\n        Subscripcion::new(Some(TipoSubscripcion::Clasic))\n    }\n\n    fn build_subscripcion_super() -\u003e Subscripcion {\n        Subscripcion::new(Some(TipoSubscripcion::Super))\n    }\n\n    fn build_medio_de_pago_mp() -\u003e MedioDePago {\n        MedioDePago::MercadoPago {\n            cuentamp: \"datosfalsos123\".to_owned(),\n            cbu: \"12345678910111213\".to_owned(),\n        }\n    }\n\n    fn build_medio_de_pago_cripto() -\u003e MedioDePago {\n        MedioDePago::Cripto {\n            wallet: \"datosfalsos123\".to_owned(),\n            red: \"eth\".to_owned(),\n            tipo_token: Some(\"ethereum\".to_owned()),\n            tx_hash: None,\n        }\n    }\n\n    fn build_medio_de_pago_tarjeta() -\u003e MedioDePago {\n        MedioDePago::TarjetaCredito {\n            numero_tarjeta: 123456789101112,\n            numero_seguridad: 1234,\n            nombre_titular: \"john doe\".to_owned(),\n        }\n    }\n\n    fn build_usuario_basic() -\u003e Usuario {\n        Usuario::new(MedioDePago::Efectivo, build_subscripcion_basic())\n    }\n\n    fn build_usuario_super() -\u003e Usuario {\n        Usuario::new(MedioDePago::Efectivo, build_subscripcion_super())\n    }\n\n    #[test]\n    fn verifica_crear_usuario() {\n        let mut app = App::new();\n\n        let sub = build_subscripcion_basic();\n        let expect = build_usuario_basic();\n\n        app.create_user(build_subscripcion_basic(), MedioDePago::Efectivo);\n\n        assert_eq!(app.usuarios.len(), 1);\n        assert_eq!(app.usuarios[0], expect);\n        assert_eq!(app.usuarios[0].subscripcion.last(), Some(sub).as_ref());\n        assert_eq!(app.usuarios[0].medio_de_pago, MedioDePago::Efectivo);\n    }\n\n    #[test]\n    fn verifica_cancelar_subscripcion() {\n        let mut app = App::new();\n        let usuario = build_usuario_basic();\n\n        app.create_user(build_subscripcion_basic(), MedioDePago::Efectivo);\n        assert_eq!(app.usuarios.len(), 1);\n\n        app.cancel_subscripcion(\u0026usuario);\n        assert_eq!(\n            app.usuarios[0]\n                .subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            None\n        );\n    }\n\n    #[test]\n    fn verifica_upgrade_subscripcion() {\n        let mut user = build_usuario_basic();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            Some(TipoSubscripcion::Basic)\n        );\n        user.upgrade_sub();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            Some(TipoSubscripcion::Clasic)\n        );\n        user.upgrade_sub();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            Some(TipoSubscripcion::Super)\n        );\n    }\n\n    #[test]\n    fn verifica_downgrade_subscripcion() {\n        let mut user = build_usuario_super();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            Some(TipoSubscripcion::Super)\n        );\n        user.downgrade_sub();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            Some(TipoSubscripcion::Clasic)\n        );\n        user.downgrade_sub();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            Some(TipoSubscripcion::Basic)\n        );\n        user.downgrade_sub();\n        assert_eq!(\n            user.subscripcion\n                .last()\n                .expect(\"expected subscription\")\n                .tipo,\n            None\n        );\n    }\n\n    #[test]\n    fn verifica_datos_estadisticos() {\n        let mut app = App::new();\n\n        app.create_user(build_subscripcion_basic(), MedioDePago::Efectivo);\n        app.create_user(build_subscripcion_basic(), build_medio_de_pago_tarjeta());\n        app.create_user(build_subscripcion_basic(), build_medio_de_pago_tarjeta());\n        app.create_user(build_subscripcion_clasic(), MedioDePago::Efectivo);\n        app.create_user(build_subscripcion_basic(), build_medio_de_pago_tarjeta());\n        app.create_user(build_subscripcion_clasic(), build_medio_de_pago_mp());\n        app.create_user(build_subscripcion_clasic(), build_medio_de_pago_cripto());\n        app.usuarios[1].cancel_subscripcion();\n        app.usuarios[2].cancel_subscripcion();\n\n        app.update_stats();\n        assert_eq!(\n            app.estadisticas.medio_de_pago_mas_utilizado,\n            Some(TipoMedioDePago::TarjetaCredito)\n        );\n        assert_eq!(\n            app.estadisticas.medio_de_pago_mas_utilizado_subs_activas,\n            Some(TipoMedioDePago::Efectivo)\n        );\n        assert_eq!(\n            app.estadisticas.subscripcion_mas_contratada,\n            Some(TipoSubscripcion::Basic)\n        );\n        assert_eq!(\n            app.estadisticas.subscripcion_mas_contratada_subs_activas,\n            Some(TipoSubscripcion::Clasic)\n        );\n    }\n}\n","traces":[{"line":10,"address":[1043728,1044058],"length":1,"stats":{"Line":1}},{"line":12,"address":[1043749],"length":1,"stats":{"Line":1}},{"line":13,"address":[1043890],"length":1,"stats":{"Line":1}},{"line":24,"address":[1044563,1044588,1044080],"length":1,"stats":{"Line":1}},{"line":25,"address":[1044110,1044306,1044161],"length":1,"stats":{"Line":3}},{"line":26,"address":[1044308,1044264,1044157,1044170],"length":1,"stats":{"Line":3}},{"line":33,"address":[1044510,1044196,1044337],"length":1,"stats":{"Line":2}},{"line":36,"address":[1044205],"length":1,"stats":{"Line":1}},{"line":39,"address":[1044411],"length":1,"stats":{"Line":1}},{"line":40,"address":[1044536],"length":1,"stats":{"Line":1}},{"line":43,"address":[1044608],"length":1,"stats":{"Line":1}},{"line":44,"address":[808449,808432],"length":1,"stats":{"Line":3}},{"line":45,"address":[1044707],"length":1,"stats":{"Line":1}},{"line":49,"address":[1044720,1046094],"length":1,"stats":{"Line":1}},{"line":50,"address":[1044743],"length":1,"stats":{"Line":1}},{"line":51,"address":[1044788],"length":1,"stats":{"Line":1}},{"line":53,"address":[1044844,1045040,1044929],"length":1,"stats":{"Line":3}},{"line":54,"address":[1045626,1046053,1045064],"length":1,"stats":{"Line":3}},{"line":61,"address":[1045715,1045942],"length":1,"stats":{"Line":2}},{"line":62,"address":[1045900,1045841,1045944],"length":1,"stats":{"Line":2}},{"line":64,"address":[1045875,1045968],"length":1,"stats":{"Line":2}},{"line":65,"address":[1045975,1046058],"length":1,"stats":{"Line":1}},{"line":69,"address":[1045021,1045106],"length":1,"stats":{"Line":2}},{"line":74,"address":[808480,808490],"length":1,"stats":{"Line":2}},{"line":75,"address":[808523,808512],"length":1,"stats":{"Line":2}},{"line":77,"address":[1045206],"length":1,"stats":{"Line":1}},{"line":82,"address":[808538,808528],"length":1,"stats":{"Line":2}},{"line":83,"address":[808571,808560],"length":1,"stats":{"Line":2}},{"line":85,"address":[1045308],"length":1,"stats":{"Line":1}},{"line":87,"address":[808586,808576],"length":1,"stats":{"Line":2}},{"line":88,"address":[808619,808608],"length":1,"stats":{"Line":2}},{"line":90,"address":[1045447],"length":1,"stats":{"Line":1}},{"line":92,"address":[808624,808634],"length":1,"stats":{"Line":2}},{"line":93,"address":[808656,808667],"length":1,"stats":{"Line":2}},{"line":114,"address":[1046144],"length":1,"stats":{"Line":1}},{"line":115,"address":[1046149],"length":1,"stats":{"Line":1}},{"line":116,"address":[1046181],"length":1,"stats":{"Line":1}},{"line":117,"address":[1046202],"length":1,"stats":{"Line":1}},{"line":118,"address":[1046223],"length":1,"stats":{"Line":1}},{"line":124,"address":[1046256],"length":1,"stats":{"Line":1}},{"line":125,"address":[1046274],"length":1,"stats":{"Line":2}},{"line":139,"address":[1046320],"length":1,"stats":{"Line":1}},{"line":140,"address":[1046325],"length":1,"stats":{"Line":1}},{"line":141,"address":[1046385],"length":1,"stats":{"Line":1}},{"line":142,"address":[1046392],"length":1,"stats":{"Line":1}},{"line":143,"address":[1046399],"length":1,"stats":{"Line":1}},{"line":144,"address":[1046406],"length":1,"stats":{"Line":0}},{"line":145,"address":[1046413],"length":1,"stats":{"Line":1}},{"line":176,"address":[1046538,1046432],"length":1,"stats":{"Line":2}},{"line":177,"address":[1046465,1046540],"length":1,"stats":{"Line":2}},{"line":178,"address":[1046804],"length":1,"stats":{"Line":0}},{"line":188,"address":[1046937],"length":1,"stats":{"Line":0}},{"line":200,"address":[1046996],"length":1,"stats":{"Line":0}},{"line":201,"address":[1047023],"length":1,"stats":{"Line":0}},{"line":202,"address":[1047045],"length":1,"stats":{"Line":0}},{"line":204,"address":[1047075],"length":1,"stats":{"Line":0}},{"line":216,"address":[1047177],"length":1,"stats":{"Line":0}},{"line":217,"address":[1047213],"length":1,"stats":{"Line":0}},{"line":218,"address":[1047241],"length":1,"stats":{"Line":0}},{"line":220,"address":[1047338],"length":1,"stats":{"Line":0}},{"line":234,"address":[1047402],"length":1,"stats":{"Line":0}},{"line":235,"address":[1047438],"length":1,"stats":{"Line":0}},{"line":236,"address":[1047466],"length":1,"stats":{"Line":0}},{"line":237,"address":[1047493],"length":1,"stats":{"Line":0}},{"line":239,"address":[1046730],"length":1,"stats":{"Line":2}},{"line":254,"address":[1047536],"length":1,"stats":{"Line":1}},{"line":255,"address":[1047556],"length":1,"stats":{"Line":1}},{"line":256,"address":[1047586],"length":1,"stats":{"Line":1}},{"line":257,"address":[1047691,1047606],"length":1,"stats":{"Line":2}},{"line":258,"address":[1047644],"length":1,"stats":{"Line":1}},{"line":259,"address":[1047628],"length":1,"stats":{"Line":2}},{"line":273,"address":[1047744],"length":1,"stats":{"Line":1}},{"line":274,"address":[1047767],"length":1,"stats":{"Line":1}},{"line":275,"address":[1047800],"length":1,"stats":{"Line":1}},{"line":276,"address":[1047821],"length":1,"stats":{"Line":1}},{"line":277,"address":[1047838],"length":1,"stats":{"Line":2}},{"line":288,"address":[1047872],"length":1,"stats":{"Line":1}},{"line":289,"address":[1047895],"length":1,"stats":{"Line":1}},{"line":294,"address":[1048233,1047952],"length":1,"stats":{"Line":1}},{"line":296,"address":[1047989,1048043],"length":1,"stats":{"Line":2}},{"line":301,"address":[1048256],"length":1,"stats":{"Line":1}},{"line":302,"address":[1048270],"length":1,"stats":{"Line":1}},{"line":303,"address":[1048332,1048417],"length":1,"stats":{"Line":2}},{"line":305,"address":[1048453],"length":1,"stats":{"Line":1}},{"line":306,"address":[1048490],"length":1,"stats":{"Line":1}},{"line":307,"address":[1048457],"length":1,"stats":{"Line":1}},{"line":310,"address":[1048517],"length":1,"stats":{"Line":1}},{"line":311,"address":[1048554],"length":1,"stats":{"Line":1}},{"line":312,"address":[1048521],"length":1,"stats":{"Line":1}},{"line":315,"address":[1048393],"length":1,"stats":{"Line":0}},{"line":317,"address":[1048360],"length":1,"stats":{"Line":0}},{"line":322,"address":[1048576],"length":1,"stats":{"Line":1}},{"line":323,"address":[1048590],"length":1,"stats":{"Line":1}},{"line":324,"address":[1048683,1048652],"length":1,"stats":{"Line":2}},{"line":326,"address":[1048719],"length":1,"stats":{"Line":1}},{"line":329,"address":[1048731],"length":1,"stats":{"Line":1}},{"line":330,"address":[1048768],"length":1,"stats":{"Line":1}},{"line":331,"address":[1048735],"length":1,"stats":{"Line":1}},{"line":333,"address":[1048792],"length":1,"stats":{"Line":1}},{"line":339,"address":[1048832],"length":1,"stats":{"Line":1}},{"line":340,"address":[1048845],"length":1,"stats":{"Line":1}},{"line":341,"address":[1048902],"length":1,"stats":{"Line":1}},{"line":342,"address":[1048906],"length":1,"stats":{"Line":2}}],"covered":86,"coverable":103},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp4","ej4.rs"],"content":"use std::collections::HashMap;\nuse time::Date;\n\nenum MedioDePago {\n    TarjetaCredito,\n    TarjetaDebito,\n    Transferencia,\n    Efectivo,\n}\n\nstruct DatosPersonales {\n    nombre: String,\n    apellido: String,\n    direccion: String,\n    dni: String,\n}\n\nstruct Vendedor {\n    datos_personales: DatosPersonales,\n    legajo: String,\n    antiguedad: u32,\n    salario: f64,\n}\n\nstruct Cliente {\n    datos_personales: DatosPersonales,\n    subscripcion: Option\u003cString\u003e,\n}\n\nimpl Cliente {\n    pub fn esta_subscripto(\u0026self) -\u003e bool {\n        self.subscripcion != None\n    }\n}\n\nstruct Producto {\n    nombre: String,\n    categoria: String,\n    precio_base: f64,\n}\n\nstruct Venta {\n    fecha: Date,\n    productos: Vec\u003c(Producto, u32)\u003e,\n    vendedor: Vendedor,\n    cliente: Cliente,\n    medio_de_pago: MedioDePago,\n}\n\nimpl Venta {\n    fn calcular_precio_final(\n        \u0026self,\n        descuento_newsletter: f64,\n        categorias: HashMap\u003cString, f64\u003e,\n    ) -\u003e f64 {\n        let mut precio_final: f64 = 0.0;\n        self.productos.iter().for_each(|f| {\n            if let Some(descuento) = categorias.get(\u0026f.0.categoria) {\n                precio_final += (f.0.precio_base * (1.0 - (descuento / 100.00))) * (f.1 as f64); // precio base - descuento de categoria (si aplica)\n            } else {\n                precio_final += f.0.precio_base * (f.1 as f64);\n            };\n\n            if self.cliente.esta_subscripto() {\n                precio_final = precio_final * (1.0 - (descuento_newsletter / 100.00)); // precio parcial - descuento por newsletter (si aplica)\n            };\n        });\n        precio_final\n    }\n}\n\nstruct App {\n    ventas: Vec\u003cVenta\u003e,\n    categorias: HashMap\u003cString, u32\u003e, // nombre de categoria y % de descuento\n    descuento_newsletter: u32,\n}\n\nimpl App {\n    pub fn new() -\u003e Self {\n        App {\n            ventas: Vec::new(),\n            categorias: HashMap::new(),\n            descuento_newsletter: 0,\n        }\n    }\n\n    pub fn set_descuento_newsletter(\u0026mut self, descuento: u32) {\n        self.descuento_newsletter = descuento;\n    }\n\n    pub fn agregar_venta(\u0026mut self, venta: Venta) {\n        self.ventas.push(venta);\n    }\n\n    pub fn generar_reporte_categorias(\u0026self) -\u003e String {\n        if self.ventas.is_empty() {\n            return \"No hay ventas registradas.\".to_owned();\n        }\n\n        let mut totales_por_categoria: HashMap\u003cString, u32\u003e = HashMap::new();\n        for venta in \u0026self.ventas {\n            for (producto, cant) in \u0026venta.productos {\n                totales_por_categoria\n                    .entry(producto.categoria.clone())\n                    .and_modify(|c| *c += *cant)\n                    .or_insert(*cant);\n            }\n        }\n\n        let mut categorias_ordenadas: Vec\u003c(\u0026String, \u0026u32)\u003e = totales_por_categoria.iter().collect();\n        categorias_ordenadas.sort_by_key(|(cat, _)| cat.to_owned());\n\n        let mut report: String = String::new();\n        for (categoria, cant) in categorias_ordenadas {\n            report.push_str(\u0026format!(\"{}: {}; \", categoria, cant));\n        }\n        report.trim().to_owned()\n    }\n\n    pub fn generar_reporte_vendedor(\u0026self) -\u003e String {\n        if self.ventas.is_empty() {\n            return \"No hay ventas registradas.\".to_owned();\n        }\n        let mut totales_por_vendedor: HashMap\u003cString, u32\u003e = HashMap::new();\n        for venta in \u0026self.ventas {\n            totales_por_vendedor\n                .entry(venta.vendedor.legajo.clone())\n                .and_modify(|c| *c += 1)\n                .or_insert(1);\n        }\n\n        let mut legajos_ordenados: Vec\u003c(\u0026String, \u0026u32)\u003e = totales_por_vendedor.iter().collect();\n        legajos_ordenados.sort_by_key(|(cat, _)| cat.to_owned());\n\n        let mut report = String::new();\n        for (legajo, cantidad) in legajos_ordenados {\n            report.push_str(\u0026format!(\"{}: {}; \", legajo, cantidad));\n        }\n        report.trim().to_owned()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn build_fecha() -\u003e Date {\n        Date::from_julian_day(2_458_485).expect(\"deberia devolver una fecha\")\n    }\n\n    fn build_datos_personales() -\u003e DatosPersonales {\n        DatosPersonales {\n            nombre: \"name\".to_owned(),\n            apellido: \"lastname\".to_owned(),\n            direccion: \"calle falsa 123\".to_owned(),\n            dni: \"12345678910\".to_owned(),\n        }\n    }\n\n    fn build_vendendor() -\u003e Vendedor {\n        Vendedor {\n            datos_personales: build_datos_personales(),\n            legajo: \"271826/2\".to_owned(),\n            antiguedad: 12,\n            salario: 800000.00,\n        }\n    }\n\n    fn build_vendendor_con_legajo(legajo: String) -\u003e Vendedor {\n        Vendedor {\n            datos_personales: build_datos_personales(),\n            legajo,\n            antiguedad: 12,\n            salario: 800000.00,\n        }\n    }\n\n    fn build_cliente_con_sub() -\u003e Cliente {\n        Cliente {\n            datos_personales: build_datos_personales(),\n            subscripcion: Some(\"false@mail.com\".to_owned()),\n        }\n    }\n\n    fn build_cliente_sin_sub() -\u003e Cliente {\n        Cliente {\n            datos_personales: build_datos_personales(),\n            subscripcion: None,\n        }\n    }\n\n    fn build_producto_cat01() -\u003e Producto {\n        Producto {\n            nombre: \"nombre_producto\".to_owned(),\n            categoria: \"categoria01\".to_owned(),\n            precio_base: 5000.00,\n        }\n    }\n\n    fn build_producto_cat02() -\u003e Producto {\n        Producto {\n            nombre: \"nombre_producto\".to_owned(),\n            categoria: \"categoria02\".to_owned(),\n            precio_base: 5000.00,\n        }\n    }\n\n    fn build_producto_cat03() -\u003e Producto {\n        Producto {\n            nombre: \"nombre_producto\".to_owned(),\n            categoria: \"categoria03\".to_owned(),\n            precio_base: 5000.00,\n        }\n    }\n\n    fn build_lista_productos() -\u003e Vec\u003c(Producto, u32)\u003e {\n        let mut list = Vec::new();\n        list.push((build_producto_cat01(), 1));\n        list.push((build_producto_cat01(), 2));\n        list.push((build_producto_cat01(), 3));\n\n        list\n    }\n\n    fn build_venta_con_sub() -\u003e Venta {\n        Venta {\n            fecha: build_fecha(),\n            productos: Vec::from([(build_producto_cat01(), 1)]),\n            vendedor: build_vendendor(),\n            cliente: build_cliente_con_sub(),\n            medio_de_pago: MedioDePago::Efectivo,\n        }\n    }\n\n    fn build_ventas_con_sub() -\u003e Venta {\n        Venta {\n            fecha: build_fecha(),\n            productos: Vec::from([\n                (build_producto_cat01(), 1),\n                (build_producto_cat02(), 2),\n                (build_producto_cat03(), 3),\n            ]),\n            vendedor: build_vendendor(),\n            cliente: build_cliente_con_sub(),\n            medio_de_pago: MedioDePago::Efectivo,\n        }\n    }\n\n    fn build_venta_sin_sub() -\u003e Venta {\n        Venta {\n            fecha: build_fecha(),\n            productos: Vec::from([(build_producto_cat01(), 1)]),\n            vendedor: build_vendendor(),\n            cliente: build_cliente_sin_sub(),\n            medio_de_pago: MedioDePago::Efectivo,\n        }\n    }\n\n    fn build_venta_por_legajo(legajo: String) -\u003e Venta {\n        Venta {\n            fecha: build_fecha(),\n            productos: Vec::from([(build_producto_cat01(), 1)]),\n            vendedor: build_vendendor_con_legajo(legajo),\n            cliente: build_cliente_sin_sub(),\n            medio_de_pago: MedioDePago::Efectivo,\n        }\n    }\n\n    fn build_categorias() -\u003e HashMap\u003cString, f64\u003e {\n        HashMap::from([\n            (\"categoria01\".to_owned(), 0.4),\n            (\"categoria02\".to_owned(), 0.7),\n            (\"categoria03\".to_owned(), 1.0),\n        ])\n    }\n\n    #[test]\n    fn valida_agregar_una_venta() {\n        let mut app = App::new();\n        let venta = build_venta_con_sub();\n\n        assert_eq!(app.ventas.len(), 0);\n        app.agregar_venta(venta);\n        assert_eq!(app.ventas.len(), 1);\n    }\n\n    #[test]\n    fn valida_cliente_subscripto() {\n        assert!(build_cliente_con_sub().esta_subscripto());\n        assert!(!build_cliente_sin_sub().esta_subscripto());\n    }\n\n    #[test]\n    fn valida_calcular_precio_final_de_venta() {\n        let mut app = App::new();\n        app.agregar_venta(build_venta_con_sub());\n        app.set_descuento_newsletter(30);\n\n        assert!(app.ventas[0].cliente.esta_subscripto());\n        assert_eq!(\n            app.ventas[0]\n                .calcular_precio_final(app.descuento_newsletter as f64, build_categorias()),\n            3486.00,\n            \"Deberia hacer el siguiente calculo correctamente ((5000 - 0.4% ) * 1) - 30%\"\n        );\n\n        app.agregar_venta(build_venta_sin_sub());\n        assert_eq!(\n            app.ventas[1]\n                .calcular_precio_final(app.descuento_newsletter as f64, build_categorias()),\n            4980.00,\n            \"Deberia hacer el siguiente calculo correctamente ((5000 - 0.4% ) * 1)\"\n        );\n    }\n\n    #[test]\n    fn valida_reporte_categorias() {\n        let mut app = App::new();\n        app.agregar_venta(build_ventas_con_sub());\n\n        assert_eq!(\n            app.generar_reporte_categorias(),\n            \"categoria01: 1; categoria02: 2; categoria03: 3;\".to_owned()\n        );\n        app.ventas.clear();\n        assert_eq!(\n            app.generar_reporte_categorias(),\n            \"No hay ventas registradas.\".to_owned()\n        );\n    }\n\n    #[test]\n    fn valida_reporte_vendedor() {\n        let mut app = App::new();\n        app.agregar_venta(build_venta_por_legajo(\"271826/2\".to_owned()));\n        assert_eq!(app.generar_reporte_vendedor(), \"271826/2: 1;\".to_owned());\n\n        app.agregar_venta(build_venta_por_legajo(\"298671/9\".to_owned()));\n        assert_eq!(\n            app.generar_reporte_vendedor(),\n            \"271826/2: 1; 298671/9: 1;\".to_owned()\n        );\n\n        app.ventas.clear();\n        assert_eq!(\n            app.generar_reporte_vendedor(),\n            \"No hay ventas registradas.\".to_owned()\n        );\n    }\n}\n","traces":[{"line":31,"address":[991696],"length":1,"stats":{"Line":1}},{"line":32,"address":[991701],"length":1,"stats":{"Line":1}},{"line":51,"address":[991728,991941],"length":1,"stats":{"Line":1}},{"line":56,"address":[991756],"length":1,"stats":{"Line":1}},{"line":57,"address":[707376],"length":1,"stats":{"Line":3}},{"line":58,"address":[707550,707400],"length":1,"stats":{"Line":2}},{"line":59,"address":[707458],"length":1,"stats":{"Line":1}},{"line":61,"address":[707562],"length":1,"stats":{"Line":0}},{"line":64,"address":[707682,707600],"length":1,"stats":{"Line":2}},{"line":65,"address":[707630],"length":1,"stats":{"Line":1}},{"line":68,"address":[991910],"length":1,"stats":{"Line":1}},{"line":79,"address":[992101,991968],"length":1,"stats":{"Line":1}},{"line":81,"address":[991986],"length":1,"stats":{"Line":1}},{"line":82,"address":[991996],"length":1,"stats":{"Line":1}},{"line":87,"address":[992128],"length":1,"stats":{"Line":1}},{"line":88,"address":[992137],"length":1,"stats":{"Line":1}},{"line":91,"address":[992144],"length":1,"stats":{"Line":1}},{"line":92,"address":[992149],"length":1,"stats":{"Line":1}},{"line":95,"address":[993381,992176,993647],"length":1,"stats":{"Line":1}},{"line":96,"address":[992226],"length":1,"stats":{"Line":1}},{"line":97,"address":[992292],"length":1,"stats":{"Line":1}},{"line":100,"address":[992251],"length":1,"stats":{"Line":1}},{"line":101,"address":[992468,992367,992264],"length":1,"stats":{"Line":3}},{"line":102,"address":[992484,993418],"length":1,"stats":{"Line":2}},{"line":103,"address":[993587,993635],"length":1,"stats":{"Line":2}},{"line":104,"address":[993540],"length":1,"stats":{"Line":1}},{"line":105,"address":[707696,707715],"length":1,"stats":{"Line":0}},{"line":106,"address":[993625],"length":1,"stats":{"Line":1}},{"line":110,"address":[992461,992520],"length":1,"stats":{"Line":2}},{"line":111,"address":[707803,707776],"length":1,"stats":{"Line":4}},{"line":113,"address":[992626],"length":1,"stats":{"Line":1}},{"line":114,"address":[992939,992633,992879,992740],"length":1,"stats":{"Line":4}},{"line":115,"address":[992987,993146],"length":1,"stats":{"Line":2}},{"line":117,"address":[993005],"length":1,"stats":{"Line":1}},{"line":120,"address":[993664,994957,994851],"length":1,"stats":{"Line":1}},{"line":121,"address":[993705],"length":1,"stats":{"Line":1}},{"line":122,"address":[993762],"length":1,"stats":{"Line":1}},{"line":124,"address":[993730],"length":1,"stats":{"Line":1}},{"line":125,"address":[993740,993935,993834],"length":1,"stats":{"Line":3}},{"line":126,"address":[994902],"length":1,"stats":{"Line":1}},{"line":127,"address":[993951],"length":1,"stats":{"Line":1}},{"line":128,"address":[707824,707837],"length":1,"stats":{"Line":0}},{"line":132,"address":[993928,993993],"length":1,"stats":{"Line":2}},{"line":133,"address":[707915,707888],"length":1,"stats":{"Line":4}},{"line":135,"address":[994099],"length":1,"stats":{"Line":1}},{"line":136,"address":[994352,994412,994213,994106],"length":1,"stats":{"Line":4}},{"line":137,"address":[994616,994460],"length":1,"stats":{"Line":2}},{"line":139,"address":[994478],"length":1,"stats":{"Line":1}}],"covered":45,"coverable":48},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp4","ej5.rs"],"content":"use rand::Rng;\nuse std::collections::HashMap;\nuse time::OffsetDateTime;\n\nconst ERROR_COTIZACION: \u0026str = \"Error obteniendo cotizacion\";\nconst ERROR_CRIPTOMONEDA: \u0026str = \"Error obteniendo criptomoneda\";\nconst ERROR_BLOCKCHAIN: \u0026str = \"Error obteniendo blockchain\";\n\nstruct Blockchain {\n    nombre: String,\n    prefijo: String,\n}\n\nimpl Blockchain {\n    fn generar_hash(\u0026self) -\u003e String {\n        format!(\"{}{}\", self.nombre, rand::rng().random::\u003cu32\u003e())\n    }\n}\n\nstruct Criptomoneda {\n    nombre: String,\n    prefijo: String,\n    blockchains: HashMap\u003cString, Blockchain\u003e, // clave: prefijo_blockchain\n}\n\nenum MedioDePago {\n    MercadoPago,\n    Transferencia,\n}\n\nstruct Balance {\n    user_id: String,\n    balance_fiat: f64,\n    balance_cripto: HashMap\u003cString, f64\u003e, // clave: prefijo_cripto\n}\n\nimpl Balance {\n    fn vender_cripto(\u0026mut self, pref_cripto: \u0026str, monto_fiat: f64, cotizacion: f64) {\n        self.balance_fiat += monto_fiat;\n        self.balance_cripto\n            .entry(pref_cripto.to_owned())\n            .and_modify(|c| *c += monto_fiat / cotizacion)\n            .or_insert(monto_fiat / cotizacion);\n    }\n\n    fn comprar_cripto(\u0026mut self, pref_cripto: \u0026str, monto_fiat: f64, cotizacion: f64) {\n        self.balance_fiat -= monto_fiat;\n        self.balance_cripto\n            .entry(pref_cripto.to_owned())\n            .and_modify(|c| *c += monto_fiat / cotizacion)\n            .or_insert(monto_fiat / cotizacion);\n    }\n\n    fn retirar_fiat(\u0026mut self, monto_fiat: f64) {\n        self.balance_fiat -= monto_fiat;\n    }\n}\n\nstruct Usuario {\n    user_id: String,\n    nombre: String,\n    apellido: String,\n    dni: String,\n    email: String,\n    validado: bool,\n}\n\nenum TipoTransaccion {\n    IngresoDinero {\n        monto: f64,\n    },\n    CompraCripto {\n        cripto: String,\n        monto: f64,\n        cotizacion: f64,\n    },\n    VentaCripto {\n        cripto: String,\n        monto: f64,\n        cotizacion: f64,\n    },\n    RetirarFiat {\n        medio_pago: MedioDePago,\n    },\n    RetiroCripto {\n        cripto: String,\n        monto: f64,\n        hash: String,\n        cotizacion: f64,\n    },\n    RecepcionCripto {\n        cripto: String,\n        monto: f64,\n        cotizacion: f64,\n    },\n}\n\nstruct Transaccion {\n    user_id: String,\n    monto: f64,\n    tipo: TipoTransaccion,\n}\n\nimpl Transaccion {\n    fn new(tipo: TipoTransaccion, monto: f64, user_id: String) -\u003e Self {\n        Transaccion {\n            tipo,\n            monto,\n            user_id,\n        }\n    }\n}\n\nstruct Cotizacion {\n    fecha: OffsetDateTime,\n    compra: f64,\n    venta: f64,\n}\n\nimpl Cotizacion {\n    pub fn new(compra: f64, venta: f64) -\u003e Self {\n        Cotizacion {\n            fecha: OffsetDateTime::now_utc(),\n            compra,\n            venta,\n        }\n    }\n}\n\nstruct Estadisiticas {\n    cant_ventas: u32,\n    cant_compras: u32,\n    volumen_ventas: f64,\n    volumen_compras: f64,\n}\n\nstruct App {\n    usuarios: HashMap\u003cString, Usuario\u003e,             // clave: user_id\n    balances: HashMap\u003cString, Balance\u003e,             // clave: user_id\n    criptomonedas: HashMap\u003cString, Criptomoneda\u003e,   // clave: prefijo_cripto\n    cotizaciones: HashMap\u003cString, Vec\u003cCotizacion\u003e\u003e, // clave: prefijo_cripto\n    estadisticas: HashMap\u003cString, Estadisiticas\u003e,   // clave: prefijo_cripto\n    transacciones: Vec\u003cTransaccion\u003e,\n}\n\nimpl App {\n    pub fn new() -\u003e Self {\n        App {\n            usuarios: HashMap::new(),\n            balances: HashMap::new(),\n            criptomonedas: HashMap::new(),\n            cotizaciones: HashMap::new(),\n            transacciones: Vec::new(),\n            estadisticas: HashMap::new(),\n        }\n    }\n    pub fn obtener_cotizacion(\u0026self, pref_cripto: \u0026str) -\u003e \u0026Cotizacion {\n        self.cotizaciones\n            .get(pref_cripto)\n            .and_then(|f| Some(f.last().expect(ERROR_COTIZACION)))\n            .expect(\"err\")\n    }\n\n    pub fn ingresar_dinero(\u0026mut self, monto_fiat: f64, user_id: String) {\n        if self.balances.contains_key(\u0026user_id) {\n            self.balances\n                .entry(user_id.clone())\n                .and_modify(|u| u.balance_fiat += monto_fiat);\n\n            self.transacciones.push(Transaccion::new(\n                TipoTransaccion::IngresoDinero { monto: monto_fiat },\n                monto_fiat,\n                user_id,\n            ));\n        }\n    }\n\n    pub fn comprar_cripto(\u0026mut self, pref_cripto: String, monto_fiat: f64, user_id: String) {\n        // obtengo cotizacion actual\n        let cotizacion = self.obtener_cotizacion(\u0026pref_cripto).compra;\n        // verficar que usuario existe\n        if let Some(balance) = self.balances.get_mut(\u0026user_id) {\n            // verifica que el usuario esta validado\n            if self.usuarios.get(\u0026user_id).is_some_and(|u| u.validado) {\n                // verificar qeu tiene saldo para transaccion\n                if balance.balance_fiat \u003e= monto_fiat {\n                    // hago la compra\n                    balance.comprar_cripto(\u0026pref_cripto, monto_fiat, cotizacion);\n                    // y genero transaccion\n                    self.transacciones.push(Transaccion::new(\n                        TipoTransaccion::CompraCripto {\n                            cripto: pref_cripto,\n                            monto: monto_fiat / cotizacion,\n                            cotizacion,\n                        },\n                        monto_fiat,\n                        user_id,\n                    ))\n                }\n            }\n        }\n    }\n\n    pub fn vender_cripto(\u0026mut self, pref_cripto: String, monto_fiat: f64, user_id: String) {\n        // obtengo cotizacion actual\n        let cotizacion = self.obtener_cotizacion(\u0026pref_cripto).venta;\n        // verificar que el usuario existe\n        if let Some(balance) = self.balances.get_mut(\u0026user_id) {\n            // verifica que el usuario esta validado\n            if self.usuarios.get(\u0026user_id).is_some_and(|u| u.validado) {\n                // verifico que el usuario tiene saldo suficiente para la transaccion\n                if let Some(balance_actual) = balance.balance_cripto.get(\u0026pref_cripto) {\n                    if *balance_actual \u003e= monto_fiat / cotizacion {\n                        // hago la venta\n                        balance.vender_cripto(\u0026pref_cripto, monto_fiat, cotizacion);\n                        // y generop la transaccion\n                        self.transacciones.push(Transaccion::new(\n                            TipoTransaccion::VentaCripto {\n                                cripto: pref_cripto,\n                                monto: monto_fiat / cotizacion,\n                                cotizacion,\n                            },\n                            monto_fiat,\n                            user_id,\n                        ))\n                    }\n                }\n            }\n        }\n    }\n\n    pub fn retirar_fiat(\u0026mut self, user_id: String, monto_fiat: f64, medio: MedioDePago) {\n        if self.usuarios.get(\u0026user_id).is_some_and(|u| u.validado) {\n            if let Some(balance) = self.balances.get_mut(\u0026user_id) {\n                if balance.balance_fiat \u003e= monto_fiat {\n                    balance.retirar_fiat(monto_fiat);\n                    self.transacciones.push(Transaccion::new(\n                        TipoTransaccion::RetirarFiat { medio_pago: medio },\n                        monto_fiat,\n                        user_id,\n                    ));\n                }\n            }\n        }\n    }\n\n    pub fn recibir_hash(\u0026self, pref_cripto: \u0026str, blockchain: \u0026str) -\u003e String {\n        self.criptomonedas\n            .get(pref_cripto)\n            .expect(ERROR_CRIPTOMONEDA)\n            .blockchains\n            .get(blockchain)\n            .expect(ERROR_BLOCKCHAIN)\n            .generar_hash()\n    }\n\n    pub fn retirar_cripto(\n        \u0026mut self,\n        user_id: String,\n        pref_cripto: String,\n        blockchain: String,\n        monto_cripto: f64,\n    ) {\n        if self.usuarios.get(\u0026user_id).is_some_and(|u| u.validado) {\n            if let Some(balance) = self.balances.get_mut(\u0026user_id) {\n                if let Some(balance_actual) = balance.balance_cripto.get_mut(\u0026pref_cripto) {\n                    if *balance_actual \u003e= monto_cripto {\n                        *balance_actual -= monto_cripto;\n                        let cotizacion = self.obtener_cotizacion(\u0026pref_cripto).venta;\n                        self.transacciones.push(Transaccion {\n                            user_id,\n                            monto: monto_cripto / cotizacion,\n                            tipo: TipoTransaccion::RetiroCripto {\n                                hash: self.recibir_hash(\u0026pref_cripto, \u0026blockchain),\n                                cripto: pref_cripto,\n                                monto: monto_cripto,\n                                cotizacion,\n                            },\n                        })\n                    }\n                }\n            }\n        }\n    }\n\n    pub fn recibir_cripto(\n        \u0026mut self,\n        user_id: String,\n        pref_cripto: String,\n        _blockchain: String,\n        monto_cripto: f64,\n    ) {\n        if self.usuarios.get(\u0026user_id).is_some_and(|u| u.validado) {\n            if let Some(balance) = self.balances.get_mut(\u0026user_id) {\n                if let Some(balance_actual) = balance.balance_cripto.get_mut(\u0026pref_cripto) {\n                    *balance_actual += monto_cripto;\n                    let cotizacion = self.obtener_cotizacion(\u0026pref_cripto).venta;\n\n                    self.transacciones.push(Transaccion {\n                        user_id,\n                        monto: monto_cripto / cotizacion,\n                        tipo: TipoTransaccion::RecepcionCripto {\n                            cripto: pref_cripto,\n                            monto: monto_cripto,\n                            cotizacion,\n                        },\n                    })\n                }\n            }\n        }\n    }\n\n    pub fn actualizar_datos_estadisticos(\u0026mut self) {\n        self.transacciones.iter().for_each(|t| match \u0026t.tipo {\n            TipoTransaccion::CompraCripto { cripto, monto, .. } =\u003e {\n                self.estadisticas.entry(cripto.to_owned()).and_modify(|e| {\n                    e.cant_compras += 1;\n                    e.volumen_compras += monto;\n                });\n            }\n            TipoTransaccion::VentaCripto { cripto, monto, .. } =\u003e {\n                self.estadisticas.entry(cripto.to_owned()).and_modify(|e| {\n                    e.cant_ventas += 1;\n                    e.volumen_ventas += monto;\n                });\n            }\n            _ =\u003e (),\n        });\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    fn build_usuario_validado(user_id: \u0026str) -\u003e Usuario {\n        Usuario {\n            user_id: user_id.to_string(),\n            nombre: \"Agustin\".to_string(),\n            apellido: \"Mediotti\".to_string(),\n            dni: \"12345678\".to_string(),\n            email: \"agus@test.com\".to_string(),\n            validado: true,\n        }\n    }\n\n    fn build_balance_con_fiat(user_id: \u0026str, fiat: f64) -\u003e Balance {\n        Balance {\n            user_id: user_id.to_string(),\n            balance_fiat: fiat,\n            balance_cripto: HashMap::new(),\n        }\n    }\n\n    fn build_cotizaciones(compra: f64, venta: f64) -\u003e Vec\u003cCotizacion\u003e {\n        vec![Cotizacion::new(compra, venta)]\n    }\n\n    fn build_cripto_con_blockchain() -\u003e Criptomoneda {\n        let mut blockchains = HashMap::new();\n        blockchains.insert(\n            \"btc\".to_string(),\n            Blockchain {\n                nombre: \"BTCNET\".to_string(),\n                prefijo: \"btc\".to_string(),\n            },\n        );\n\n        Criptomoneda {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"btc\".to_string(),\n            blockchains,\n        }\n    }\n\n    fn setup_app(user_id: \u0026str, compra: f64, venta: f64, fiat: f64) -\u003e App {\n        let mut app = App::new();\n\n        app.usuarios\n            .insert(user_id.to_string(), build_usuario_validado(user_id));\n        app.balances\n            .insert(user_id.to_string(), build_balance_con_fiat(user_id, fiat));\n        app.cotizaciones\n            .insert(\"btc\".to_string(), build_cotizaciones(compra, venta));\n        app.criptomonedas\n            .insert(\"btc\".to_string(), build_cripto_con_blockchain());\n\n        app.estadisticas.insert(\n            \"btc\".to_string(),\n            Estadisiticas {\n                cant_compras: 0,\n                cant_ventas: 0,\n                volumen_compras: 0.0,\n                volumen_ventas: 0.0,\n            },\n        );\n\n        app\n    }\n\n    #[test]\n    fn test_ingresar_dinero() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 1000.0);\n        app.ingresar_dinero(2000.0, \"user1\".to_string());\n\n        assert_eq!(app.balances[\"user1\"].balance_fiat, 3000.0);\n        assert_eq!(app.transacciones.len(), 1);\n    }\n\n    #[test]\n    fn test_comprar_cripto() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 1000.0);\n        app.comprar_cripto(\"btc\".to_string(), 500.0, \"user1\".to_string());\n\n        assert!(app.balances[\"user1\"].balance_cripto.contains_key(\"btc\"));\n        assert!(app.balances[\"user1\"].balance_fiat \u003c 1000.0);\n        assert_eq!(app.transacciones.len(), 1);\n    }\n\n    #[test]\n    fn test_vender_cripto() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 0.0);\n\n        app.balances\n            .get_mut(\"user1\")\n            .unwrap()\n            .balance_cripto\n            .insert(\"btc\".to_string(), 0.01);\n        app.vender_cripto(\"btc\".to_string(), 520.0, \"user1\".to_string());\n\n        assert!(app.balances[\"user1\"].balance_fiat \u003e 0.0);\n        assert_eq!(app.transacciones.len(), 1);\n    }\n\n    #[test]\n    fn test_retirar_fiat() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 1000.0);\n        app.retirar_fiat(\"user1\".to_string(), 500.0, MedioDePago::Transferencia);\n\n        assert_eq!(app.balances[\"user1\"].balance_fiat, 500.0);\n        assert_eq!(app.transacciones.len(), 1);\n    }\n\n    #[test]\n    fn test_retirar_cripto() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 0.0);\n        app.balances\n            .get_mut(\"user1\")\n            .unwrap()\n            .balance_cripto\n            .insert(\"btc\".to_string(), 0.01);\n        app.retirar_cripto(\n            \"user1\".to_string(),\n            \"btc\".to_string(),\n            \"btc\".to_string(),\n            0.005,\n        );\n\n        assert!(app.balances[\"user1\"].balance_cripto[\"btc\"] \u003c 0.01);\n        assert_eq!(app.transacciones.len(), 1);\n    }\n\n    #[test]\n    fn test_recibir_cripto() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 0.0);\n        app.balances\n            .get_mut(\"user1\")\n            .unwrap()\n            .balance_cripto\n            .insert(\"btc\".to_string(), 0.0);\n        app.recibir_cripto(\n            \"user1\".to_string(),\n            \"btc\".to_string(),\n            \"btc\".to_string(),\n            0.003,\n        );\n\n        assert_eq!(app.balances[\"user1\"].balance_cripto[\"btc\"], 0.003);\n        assert_eq!(app.transacciones.len(), 1);\n    }\n\n    #[test]\n    fn test_actualizar_datos_estadisticos() {\n        let mut app = setup_app(\"user1\", 50000.0, 52000.0, 1000.0);\n        app.comprar_cripto(\"btc\".to_string(), 500.0, \"user1\".to_string());\n        app.vender_cripto(\"btc\".to_string(), 200.0, \"user1\".to_string());\n\n        app.actualizar_datos_estadisticos();\n\n        let stats = \u0026app.estadisticas[\"btc\"];\n        assert_eq!(stats.cant_compras, 1);\n        assert_eq!(stats.cant_ventas, 1);\n        assert!(stats.volumen_compras \u003e 0.0);\n        assert!(stats.volumen_ventas \u003e 0.0);\n    }\n}\n","traces":[{"line":15,"address":[1141407,1141056],"length":1,"stats":{"Line":1}},{"line":16,"address":[1141089],"length":1,"stats":{"Line":1}},{"line":38,"address":[1141440],"length":1,"stats":{"Line":1}},{"line":39,"address":[1141483],"length":1,"stats":{"Line":1}},{"line":40,"address":[1141573,1141521,1141499],"length":1,"stats":{"Line":3}},{"line":41,"address":[1141507],"length":1,"stats":{"Line":1}},{"line":42,"address":[572224,572239],"length":1,"stats":{"Line":2}},{"line":43,"address":[1141561],"length":1,"stats":{"Line":1}},{"line":46,"address":[1141600],"length":1,"stats":{"Line":1}},{"line":47,"address":[1141643],"length":1,"stats":{"Line":1}},{"line":48,"address":[1141681,1141659,1141733],"length":1,"stats":{"Line":3}},{"line":49,"address":[1141667],"length":1,"stats":{"Line":1}},{"line":50,"address":[572272,572287],"length":1,"stats":{"Line":0}},{"line":51,"address":[1141721],"length":1,"stats":{"Line":1}},{"line":54,"address":[1141760],"length":1,"stats":{"Line":1}},{"line":55,"address":[1141774],"length":1,"stats":{"Line":1}},{"line":105,"address":[1141792],"length":1,"stats":{"Line":1}},{"line":121,"address":[1141872],"length":1,"stats":{"Line":2}},{"line":123,"address":[1141910],"length":1,"stats":{"Line":2}},{"line":147,"address":[1142437,1141984],"length":1,"stats":{"Line":1}},{"line":149,"address":[1142005],"length":1,"stats":{"Line":2}},{"line":150,"address":[1142015],"length":1,"stats":{"Line":2}},{"line":151,"address":[1142064],"length":1,"stats":{"Line":2}},{"line":152,"address":[1142113],"length":1,"stats":{"Line":2}},{"line":153,"address":[1142162],"length":1,"stats":{"Line":2}},{"line":154,"address":[1142214],"length":1,"stats":{"Line":2}},{"line":157,"address":[1142464],"length":1,"stats":{"Line":2}},{"line":158,"address":[1142482],"length":1,"stats":{"Line":2}},{"line":160,"address":[572329,572320],"length":1,"stats":{"Line":4}},{"line":164,"address":[1142544,1142924,1142953],"length":1,"stats":{"Line":1}},{"line":165,"address":[1142651,1142575],"length":1,"stats":{"Line":2}},{"line":166,"address":[1142686,1142724],"length":1,"stats":{"Line":2}},{"line":167,"address":[1142694],"length":1,"stats":{"Line":1}},{"line":168,"address":[572410,572400],"length":1,"stats":{"Line":3}},{"line":170,"address":[1142834],"length":1,"stats":{"Line":1}},{"line":171,"address":[1142770],"length":1,"stats":{"Line":1}},{"line":173,"address":[1142803],"length":1,"stats":{"Line":1}},{"line":178,"address":[1142976,1143723],"length":1,"stats":{"Line":2}},{"line":180,"address":[1143034,1143139],"length":1,"stats":{"Line":4}},{"line":182,"address":[1143185],"length":1,"stats":{"Line":2}},{"line":184,"address":[572432,572437],"length":1,"stats":{"Line":8}},{"line":186,"address":[1143337],"length":1,"stats":{"Line":1}},{"line":188,"address":[1143353],"length":1,"stats":{"Line":1}},{"line":190,"address":[1143585],"length":1,"stats":{"Line":1}},{"line":191,"address":[1143462],"length":1,"stats":{"Line":1}},{"line":192,"address":[1143424],"length":1,"stats":{"Line":1}},{"line":193,"address":[1143455],"length":1,"stats":{"Line":1}},{"line":197,"address":[1143530],"length":1,"stats":{"Line":1}},{"line":204,"address":[1143776,1144625],"length":1,"stats":{"Line":1}},{"line":206,"address":[1143939,1143834],"length":1,"stats":{"Line":2}},{"line":208,"address":[1143986],"length":1,"stats":{"Line":1}},{"line":210,"address":[1144115,1144075],"length":1,"stats":{"Line":4}},{"line":212,"address":[1144146],"length":1,"stats":{"Line":1}},{"line":213,"address":[1144232],"length":1,"stats":{"Line":1}},{"line":215,"address":[1144255],"length":1,"stats":{"Line":1}},{"line":217,"address":[1144487],"length":1,"stats":{"Line":1}},{"line":218,"address":[1144364],"length":1,"stats":{"Line":1}},{"line":219,"address":[1144326],"length":1,"stats":{"Line":1}},{"line":220,"address":[1144357],"length":1,"stats":{"Line":1}},{"line":224,"address":[1144432],"length":1,"stats":{"Line":1}},{"line":232,"address":[1145112,1145141,1144672],"length":1,"stats":{"Line":1}},{"line":233,"address":[572469,572464],"length":1,"stats":{"Line":4}},{"line":234,"address":[1144855],"length":1,"stats":{"Line":1}},{"line":235,"address":[1144931],"length":1,"stats":{"Line":1}},{"line":236,"address":[1144953],"length":1,"stats":{"Line":1}},{"line":237,"address":[1145055],"length":1,"stats":{"Line":1}},{"line":238,"address":[1144975],"length":1,"stats":{"Line":1}},{"line":240,"address":[1145003],"length":1,"stats":{"Line":1}},{"line":247,"address":[1145152],"length":1,"stats":{"Line":1}},{"line":248,"address":[1145240],"length":1,"stats":{"Line":1}},{"line":257,"address":[1146539,1145360,1146378],"length":1,"stats":{"Line":1}},{"line":264,"address":[572485,572480],"length":1,"stats":{"Line":4}},{"line":265,"address":[1145587],"length":1,"stats":{"Line":1}},{"line":266,"address":[1145669],"length":1,"stats":{"Line":1}},{"line":267,"address":[1145761],"length":1,"stats":{"Line":1}},{"line":268,"address":[1145797],"length":1,"stats":{"Line":1}},{"line":269,"address":[1145809],"length":1,"stats":{"Line":1}},{"line":270,"address":[1146246],"length":1,"stats":{"Line":1}},{"line":271,"address":[1145906],"length":1,"stats":{"Line":1}},{"line":272,"address":[1145937],"length":1,"stats":{"Line":1}},{"line":273,"address":[1146164],"length":1,"stats":{"Line":1}},{"line":274,"address":[1145947,1146036],"length":1,"stats":{"Line":2}},{"line":275,"address":[1146133],"length":1,"stats":{"Line":1}},{"line":286,"address":[1147404,1147429,1146576],"length":1,"stats":{"Line":1}},{"line":293,"address":[572496,572501],"length":1,"stats":{"Line":4}},{"line":294,"address":[1146770],"length":1,"stats":{"Line":1}},{"line":295,"address":[1146840],"length":1,"stats":{"Line":1}},{"line":296,"address":[1146920],"length":1,"stats":{"Line":1}},{"line":297,"address":[1146932],"length":1,"stats":{"Line":1}},{"line":299,"address":[1147151],"length":1,"stats":{"Line":1}},{"line":300,"address":[1147014],"length":1,"stats":{"Line":1}},{"line":301,"address":[1147045],"length":1,"stats":{"Line":1}},{"line":302,"address":[1147083],"length":1,"stats":{"Line":1}},{"line":303,"address":[1147052],"length":1,"stats":{"Line":1}},{"line":313,"address":[1147472],"length":1,"stats":{"Line":1}},{"line":314,"address":[572540,572512],"length":1,"stats":{"Line":3}},{"line":315,"address":[572629],"length":1,"stats":{"Line":1}},{"line":316,"address":[572864,572653],"length":1,"stats":{"Line":2}},{"line":317,"address":[572883,572939],"length":1,"stats":{"Line":1}},{"line":318,"address":[572910],"length":1,"stats":{"Line":1}},{"line":321,"address":[572739],"length":1,"stats":{"Line":1}},{"line":322,"address":[572766,572960],"length":1,"stats":{"Line":2}},{"line":323,"address":[573031,572979],"length":1,"stats":{"Line":1}},{"line":324,"address":[573006],"length":1,"stats":{"Line":1}}],"covered":103,"coverable":104},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp4","mod.rs"],"content":"pub mod ej1;\npub mod ej2;\npub mod ej3;\npub mod ej4;\npub mod ej5;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp5","ej1.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt::Display;\nuse std::fs::File;\nuse std::io::Write;\n\nconst FILE_NAME: \u0026str = \"src/tp5/archivo_autos.json\";\n\n#[derive(PartialEq, Debug, Clone, Serialize, Deserialize)]\npub enum ColorAuto {\n    Rojo,\n    Verde,\n    Azul,\n    Amarillo,\n    Blanco,\n    Negro,\n}\n\n#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\npub struct Auto {\n    pub marca: String,\n    pub modelo: String,\n    pub anio: u32,\n    pub precio_bruto: f64,\n    pub color: ColorAuto,\n}\n\nimpl Auto {\n    fn new(marca: String, modelo: String, anio: u32, precio_bruto: f64, color: ColorAuto) -\u003e Self {\n        Auto {\n            marca,\n            modelo,\n            anio,\n            precio_bruto,\n            color,\n        }\n    }\n\n    pub fn calcular_precio(\u0026self) -\u003e f64 {\n        let mut total: f64 = self.precio_bruto;\n        match self.color {\n            ColorAuto::Rojo | ColorAuto::Verde | ColorAuto::Amarillo =\u003e {\n                total += self.precio_bruto * 25.0 / 100.0\n            }\n            _ =\u003e total -= self.precio_bruto * 10.0 / 100.0,\n        };\n        if self.marca == \"BMW\" {\n            total += self.precio_bruto * 15.0 / 100.0;\n        }\n        if self.anio \u003c 2000 {\n            total -= self.precio_bruto * 5.0 / 100.0;\n        }\n        total\n    }\n}\n\n#[derive(Debug, PartialEq)]\npub enum ErrorConcecionaria {\n    ErrorCapacidadMaxima(String),\n    ErrorConcecionarioVacio,\n    ErrorAutoNoEncontrado,\n    ErrorEscritura(String),\n}\n\nimpl From\u003cstd::io::Error\u003e for ErrorConcecionaria {\n    fn from(e: std::io::Error) -\u003e Self {\n        ErrorConcecionaria::ErrorEscritura(e.to_string())\n    }\n}\n\nimpl Display for ErrorConcecionaria {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            ErrorConcecionaria::ErrorCapacidadMaxima(e) =\u003e write!(f, \"{e}\"),\n            ErrorConcecionaria::ErrorConcecionarioVacio =\u003e {\n                write!(f, \"No se puede eliminar un auto de una concecionaria vacía\")\n            }\n            ErrorConcecionaria::ErrorAutoNoEncontrado =\u003e {\n                write!(f, \"El auto no se encontró en la concecionaria\")\n            }\n            ErrorConcecionaria::ErrorEscritura(e) =\u003e write!(f, \"{e}\"),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize)]\npub struct ConcesionarioAuto {\n    pub nombre: String,\n    pub direccion: String,\n    pub capacidad_max: usize,\n    pub autos: Vec\u003cAuto\u003e,\n}\n\nimpl ConcesionarioAuto {\n    pub fn new(nombre: String, direccion: String, capacidad_max: usize, autos: Vec\u003cAuto\u003e) -\u003e Self {\n        let mut file = File::create(FILE_NAME).unwrap();\n        let concecionaria = ConcesionarioAuto {\n            nombre,\n            direccion,\n            capacidad_max,\n            autos,\n        };\n        let buf = serde_json::to_string(\u0026concecionaria).unwrap();\n        file.write_all(\u0026buf.as_bytes())\n            .expect(\"error escribiendo el archivo\");\n        concecionaria\n    }\n\n    pub fn escribir_json(\u0026self) -\u003e Result\u003c(), std::io::Error\u003e {\n        let mut file = File::create(FILE_NAME)?;\n        let buf = serde_json::to_string(\u0026self)?;\n        file.write_all(\u0026buf.as_bytes())?;\n        Ok(())\n    }\n\n    pub fn agregar_auto(\u0026mut self, auto: Auto) -\u003e Result\u003c(), ErrorConcecionaria\u003e {\n        if self.autos.len() \u003c self.capacidad_max {\n            self.autos.push(auto);\n            self.escribir_json()?;\n            Ok(())\n        } else {\n            Err(ErrorConcecionaria::ErrorCapacidadMaxima(\n                self.capacidad_max.to_string(),\n            ))\n        }\n    }\n\n    pub fn eliminar_auto(\u0026mut self, auto: Auto) -\u003e Result\u003c(), ErrorConcecionaria\u003e {\n        if self.autos.is_empty() {\n            return Err(ErrorConcecionaria::ErrorConcecionarioVacio);\n        }\n        if let Some(pos) = self.autos.iter().position(|f| *f == auto) {\n            self.autos.remove(pos);\n            self.escribir_json()?;\n            return Ok(());\n        } else {\n            Err(ErrorConcecionaria::ErrorAutoNoEncontrado)\n        }\n    }\n\n    pub fn buscar_auto(\u0026self, auto: Auto) -\u003e Option\u003cAuto\u003e {\n        if let Some(pos) = self.autos.iter().position(|f| *f == auto) {\n            Some(self.autos[pos].clone())\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn crea_nuevo_concesionario_auto_correctamente() {\n        assert_eq!(\n            ConcesionarioAuto::new(\n                \"Concesionario 44\".to_owned(),\n                \"44 13 y 14\".to_owned(),\n                5,\n                Vec::new()\n            ),\n            ConcesionarioAuto {\n                nombre: \"Concesionario 44\".to_owned(),\n                direccion: \"44 13 y 14\".to_owned(),\n                capacidad_max: 5,\n                autos: Vec::new()\n            },\n            \"No se creo el objeto como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn crea_auto_nuevo_correctamente() {\n        let auto = Auto::new(\n            \"Toyota\".to_string(),\n            \"Corolla\".to_string(),\n            2010,\n            15000.0,\n            ColorAuto::Negro,\n        );\n\n        assert_eq!(auto.marca, \"Toyota\");\n        assert_eq!(auto.modelo, \"Corolla\");\n        assert_eq!(auto.anio, 2010);\n        assert_eq!(auto.precio_bruto, 15000.0);\n        assert_eq!(auto.color, ColorAuto::Negro);\n    }\n\n    #[test]\n    fn calcular_precio_auto_color_azul_sin_descuento_marca() {\n        let auto = Auto {\n            marca: \"Toyota\".to_owned(),\n            modelo: \"Corolla\".to_owned(),\n            anio: 2020,\n            precio_bruto: 20000.0,\n            color: ColorAuto::Azul,\n        };\n\n        assert_eq!(auto.calcular_precio(), 18000.0);\n    }\n\n    #[test]\n    fn agregar_auto_a_concesionario_correctamente() {\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            5,\n            Vec::new(),\n        );\n\n        conce\n            .agregar_auto(Auto {\n                marca: \"BMW\".to_owned(),\n                modelo: \"M3\".to_owned(),\n                anio: 1995,\n                precio_bruto: 30_000.0,\n                color: ColorAuto::Rojo,\n            })\n            .unwrap();\n\n        assert_eq!(\n            conce.autos.len(),\n            1,\n            \"No se agrego el auto al concesionario como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn agregar_auto_concecionaria_llena() {\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            1,\n            Vec::new(),\n        );\n\n        conce\n            .agregar_auto(Auto {\n                marca: \"BMW\".to_owned(),\n                modelo: \"M3\".to_owned(),\n                anio: 1995,\n                precio_bruto: 30_000.0,\n                color: ColorAuto::Rojo,\n            })\n            .unwrap();\n\n        assert_eq!(\n            conce.agregar_auto(Auto {\n                marca: \"BMW\".to_owned(),\n                modelo: \"M3\".to_owned(),\n                anio: 1995,\n                precio_bruto: 30_000.0,\n                color: ColorAuto::Rojo,\n            }),\n            Err(ErrorConcecionaria::ErrorCapacidadMaxima(\"1\".to_string())),\n            \"Se esperaba un error de capacidad 1\"\n        );\n    }\n\n    #[test]\n    fn eliminar_auto_de_concesionario_correctamente() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            5,\n            Vec::new(),\n        );\n        conce.agregar_auto(auto.clone()).unwrap();\n        assert_eq!(conce.autos.len(), 1,);\n        conce.eliminar_auto(auto).unwrap();\n        assert_eq!(\n            conce.autos.len(),\n            0,\n            \"No se elimino el auto al concesionario como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn eliminar_auto_no_existente_devuelve_error() {\n        let auto = Auto::new(\n            \"Ford\".to_string(),\n            \"Fiesta\".to_string(),\n            2015,\n            10000.0,\n            ColorAuto::Blanco,\n        );\n\n        let otro_auto = Auto::new(\n            \"Toyota\".to_string(),\n            \"Corolla\".to_string(),\n            2020,\n            20000.0,\n            ColorAuto::Azul,\n        );\n\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario Test\".to_string(),\n            \"Calle Falsa 123\".to_string(),\n            2,\n            vec![otro_auto],\n        );\n\n        assert_eq!(\n            conce.eliminar_auto(auto),\n            Err(ErrorConcecionaria::ErrorAutoNoEncontrado),\n            \"Se esperaba error al intentar eliminar un auto inexistente\"\n        );\n    }\n\n    #[test]\n    fn eliminar_auto_de_concesionario_vacio() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            1,\n            Vec::new(),\n        );\n        assert_eq!(\n            conce.eliminar_auto(auto),\n            Err(ErrorConcecionaria::ErrorConcecionarioVacio),\n            \"Se esperaba un error al eliminar un auto de una concecionaria vacia\"\n        );\n    }\n\n    #[test]\n    fn buscar_auto_en_concesionario_correctamente() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n        let mut conce = ConcesionarioAuto::new(\n            \"Concesionario 44\".to_owned(),\n            \"44 13 y 14\".to_owned(),\n            5,\n            Vec::new(),\n        );\n        conce.agregar_auto(auto.clone()).unwrap();\n\n        assert_eq!(\n            conce.buscar_auto(auto.clone()),\n            Some(auto),\n            \"No se encontro el auto en el concesionario como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn calcular_precio_de_auto_correctamente() {\n        let auto = Auto {\n            marca: \"BMW\".to_owned(),\n            modelo: \"M3\".to_owned(),\n            anio: 1995,\n            precio_bruto: 30_000.0,\n            color: ColorAuto::Rojo,\n        };\n\n        assert_eq!(\n            auto.calcular_precio(),\n            40_500.0,\n            \"No se calculo el precio del auto como se esperaba\"\n        );\n    }\n}\n","traces":[{"line":28,"address":[625648],"length":1,"stats":{"Line":1}},{"line":38,"address":[625760],"length":1,"stats":{"Line":1}},{"line":39,"address":[625774],"length":1,"stats":{"Line":1}},{"line":40,"address":[625785],"length":1,"stats":{"Line":1}},{"line":42,"address":[625868],"length":1,"stats":{"Line":1}},{"line":44,"address":[625820],"length":1,"stats":{"Line":1}},{"line":46,"address":[625910,625984],"length":1,"stats":{"Line":2}},{"line":47,"address":[625947],"length":1,"stats":{"Line":1}},{"line":49,"address":[625931,626043],"length":1,"stats":{"Line":2}},{"line":50,"address":[626002],"length":1,"stats":{"Line":1}},{"line":52,"address":[625986],"length":1,"stats":{"Line":1}},{"line":65,"address":[626048,626176],"length":1,"stats":{"Line":0}},{"line":66,"address":[626121,626077],"length":1,"stats":{"Line":0}},{"line":71,"address":[626208],"length":1,"stats":{"Line":0}},{"line":72,"address":[626241],"length":1,"stats":{"Line":0}},{"line":73,"address":[626277],"length":1,"stats":{"Line":0}},{"line":75,"address":[626370],"length":1,"stats":{"Line":0}},{"line":78,"address":[626420],"length":1,"stats":{"Line":0}},{"line":80,"address":[626472],"length":1,"stats":{"Line":0}},{"line":94,"address":[626608,627395,627483],"length":1,"stats":{"Line":1}},{"line":95,"address":[626774,626653],"length":1,"stats":{"Line":4}},{"line":102,"address":[627088,627040],"length":1,"stats":{"Line":4}},{"line":103,"address":[627194,627126],"length":1,"stats":{"Line":2}},{"line":105,"address":[627279],"length":1,"stats":{"Line":1}},{"line":108,"address":[628145,627520,628166],"length":1,"stats":{"Line":1}},{"line":109,"address":[627532,627614],"length":1,"stats":{"Line":1}},{"line":110,"address":[627702,628159,627827,627607],"length":1,"stats":{"Line":4}},{"line":111,"address":[627810,628112,627916,628049],"length":1,"stats":{"Line":4}},{"line":112,"address":[628024],"length":1,"stats":{"Line":2}},{"line":115,"address":[628707,628732,628192],"length":1,"stats":{"Line":1}},{"line":116,"address":[628318,628643,628235],"length":1,"stats":{"Line":4}},{"line":117,"address":[628358],"length":1,"stats":{"Line":1}},{"line":118,"address":[628560,628650,628705],"length":1,"stats":{"Line":1}},{"line":119,"address":[628636],"length":1,"stats":{"Line":2}},{"line":121,"address":[628432],"length":1,"stats":{"Line":1}},{"line":122,"address":[628329],"length":1,"stats":{"Line":1}},{"line":127,"address":[629356,628752],"length":1,"stats":{"Line":1}},{"line":128,"address":[628795,628851],"length":1,"stats":{"Line":2}},{"line":129,"address":[628888],"length":1,"stats":{"Line":1}},{"line":131,"address":[628862,628953],"length":1,"stats":{"Line":4}},{"line":132,"address":[629084,629197],"length":1,"stats":{"Line":2}},{"line":133,"address":[629341,629209,629299],"length":1,"stats":{"Line":1}},{"line":134,"address":[629285],"length":1,"stats":{"Line":1}},{"line":136,"address":[629120],"length":1,"stats":{"Line":1}},{"line":140,"address":[629714,629392],"length":1,"stats":{"Line":1}},{"line":141,"address":[629653,629435,629503],"length":1,"stats":{"Line":4}},{"line":142,"address":[629613,629664],"length":1,"stats":{"Line":2}},{"line":144,"address":[629640],"length":1,"stats":{"Line":0}}],"covered":39,"coverable":48},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp5","ej2.rs"],"content":"use serde::Serialize;\nuse std::fs::File;\nuse std::io::Write;\n\nconst FILE_NAME: \u0026str = \"src/tp5/archivo_canciones.json\";\n\n#[derive(Debug, PartialEq, Clone, Serialize)]\npub enum Genero {\n    Rock,\n    Pop,\n    Rap,\n    Jazz,\n    Otros,\n}\n\n#[derive(Debug, PartialEq, Clone, Serialize)]\npub struct Cancion {\n    pub titulo: String,\n    pub artista: String,\n    pub genero: Genero,\n}\n\n#[derive(Serialize)]\npub struct Playlist {\n    pub canciones: Vec\u003cCancion\u003e,\n    pub nombre: String,\n}\n\n#[derive(Debug)]\npub enum PlaylistError {\n    JsonFileError(std::io::Error),\n    SongNotFound,\n}\n\nimpl From\u003cstd::io::Error\u003e for PlaylistError {\n    fn from(e: std::io::Error) -\u003e Self {\n        PlaylistError::JsonFileError(e)\n    }\n}\n\nimpl Playlist {\n    pub fn new(nombre: String) -\u003e Self {\n        let mut file = File::create(FILE_NAME).unwrap();\n        let playlist = Playlist {\n            canciones: Vec::new(),\n            nombre,\n        };\n        let buf = serde_json::to_string(\u0026playlist).unwrap();\n        file.write_all(\u0026buf.as_bytes())\n            .expect(\"error escribiendo el archivo\");\n        playlist\n    }\n\n    pub fn escribir_json(\u0026self) -\u003e Result\u003c(), std::io::Error\u003e {\n        let mut file = File::create(FILE_NAME)?;\n        let buf = serde_json::to_string(\u0026self)?;\n        file.write_all(\u0026buf.as_bytes())?;\n        Ok(())\n    }\n\n    pub fn agregar_cancion(\u0026mut self, cancion: Cancion) -\u003e Result\u003c(), PlaylistError\u003e {\n        self.canciones.push(cancion);\n        self.escribir_json()?;\n        Ok(())\n    }\n\n    pub fn eliminar_cancion(\u0026mut self, cancion: Cancion) -\u003e Result\u003c(), PlaylistError\u003e {\n        if let Some(pos) = self.canciones.iter().position(|f| *f == cancion) {\n            self.canciones.remove(pos);\n            self.escribir_json()?;\n            Ok(())\n        } else {\n            Err(PlaylistError::SongNotFound)\n        }\n    }\n\n    pub fn mover_cancion(\n        \u0026mut self,\n        cancion: Cancion,\n        posicion: usize,\n    ) -\u003e Result\u003c(), PlaylistError\u003e {\n        if let Some(pos) = self.canciones.iter().position(|f| *f == cancion) {\n            let cancion = self.canciones.remove(pos);\n\n            let nueva_posicion = if posicion \u003e self.canciones.len() {\n                self.canciones.len()\n            } else {\n                posicion // Si la posicion está fuera de rango, la nueva posicion sera la última del vector.\n            };\n\n            self.canciones.insert(nueva_posicion, cancion);\n            self.escribir_json()?;\n            Ok(())\n        } else {\n            Err(PlaylistError::SongNotFound)\n        }\n    }\n\n    pub fn buscar_cancion_por_nombre(\u0026self, cancion: Cancion) -\u003e Option\u003c\u0026Cancion\u003e {\n        self.canciones.iter().find(|f| **f == cancion)\n    }\n\n    pub fn obtener_canciones_por_genero(\u0026self, genero: Genero) -\u003e Vec\u003c\u0026Cancion\u003e {\n        self.canciones\n            .iter()\n            .filter(|f| f.genero == genero)\n            .collect()\n    }\n\n    pub fn obtener_canciones_por_artista(\u0026self, artista: String) -\u003e Vec\u003c\u0026Cancion\u003e {\n        self.canciones\n            .iter()\n            .filter(|f| f.artista == artista)\n            .collect()\n    }\n\n    pub fn modificar_titulo(\u0026mut self, titulo: String) {\n        self.nombre = titulo;\n    }\n\n    pub fn limpiar_playlist(\u0026mut self) {\n        self.canciones.clear();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn build_cancion_01() -\u003e Cancion {\n        Cancion {\n            titulo: \"Flying Whales\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Gojira\".to_owned(),\n        }\n    }\n\n    fn build_cancion_02() -\u003e Cancion {\n        Cancion {\n            titulo: \"Trance Awake\".to_owned(),\n            genero: Genero::Otros,\n            artista: \"Lacuna Coil\".to_owned(),\n        }\n    }\n\n    fn build_cancion_from(titulo: String, artista: String) -\u003e Cancion {\n        Cancion {\n            titulo,\n            genero: Genero::Otros,\n            artista,\n        }\n    }\n\n    fn build_set_canciones() -\u003e (Cancion, Cancion) {\n        (build_cancion_01(), build_cancion_02())\n    }\n\n    fn build_playlist() -\u003e Playlist {\n        Playlist::new(\"Mi Playlist\".to_owned())\n    }\n\n    #[test]\n    fn agrega_cancion_a_playlist_correctamente() {\n        let mut playlist = build_playlist();\n        let cancion = build_cancion_01();\n\n        playlist.agregar_cancion(cancion.clone()).unwrap();\n\n        assert_eq!(\n            playlist.canciones[0], cancion,\n            \"No se agrego la cancion a la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn elimina_cancion_de_playlist_correctamente() {\n        let mut playlist = build_playlist();\n        let cancion = build_cancion_01();\n\n        playlist.agregar_cancion(cancion.clone()).unwrap();\n        playlist.eliminar_cancion(cancion).unwrap();\n\n        assert_eq!(\n            playlist.canciones.len(),\n            0,\n            \"No se elimino la cancion de la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn mueve_cancion_a_una_determinada_posicion_de_la_playlist() {\n        let mut playlist = build_playlist();\n\n        let (cancion_1, cancion_2) = build_set_canciones();\n\n        playlist.agregar_cancion(cancion_1.clone()).unwrap();\n        playlist.agregar_cancion(cancion_2).unwrap();\n\n        playlist.mover_cancion(cancion_1.clone(), 1).unwrap();\n\n        assert_eq!(\n            playlist.canciones[1], cancion_1,\n            \"No se movio la cancion de la playlist a la posicion que se esperaba\"\n        );\n    }\n\n    #[test]\n    fn mueve_cancion_a_una_posicion_fuera_de_rango_de_la_playlist() {\n        let mut playlist = build_playlist();\n\n        let (cancion_1, cancion_2) = build_set_canciones();\n\n        playlist.agregar_cancion(cancion_1.clone()).unwrap();\n        playlist.agregar_cancion(cancion_2).unwrap();\n\n        playlist.mover_cancion(cancion_1.clone(), 3).unwrap();\n\n        assert_eq!(\n            playlist.canciones[1], cancion_1,\n            \"Se esperaba que la cancion de la playlist se mueva a la última posicion del vector\"\n        );\n    }\n\n    #[test]\n    fn busca_cancion_por_nombre_en_playlist() {\n        let mut playlist = build_playlist();\n        let cancion = build_cancion_01();\n\n        playlist.agregar_cancion(cancion.clone()).unwrap();\n\n        assert_eq!(\n            playlist\n                .buscar_cancion_por_nombre(cancion.clone())\n                .unwrap()\n                .to_owned(),\n            cancion,\n            \"No se encontro la cancion en la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn obtener_canciones_por_genero_en_playlist() {\n        let mut playlist = build_playlist();\n        let (cancion_1, cancion_2) = build_set_canciones();\n\n        playlist.agregar_cancion(cancion_1.clone()).unwrap();\n        playlist.agregar_cancion(cancion_2.clone()).unwrap();\n\n        let mut expected = Vec::\u003c\u0026Cancion\u003e::new();\n        expected.push(\u0026cancion_1);\n        expected.push(\u0026cancion_2);\n\n        assert_eq!(\n            playlist.obtener_canciones_por_genero(Genero::Otros),\n            expected,\n            \"No se obtuvieron las canciones de la playlist por genero como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn obtener_canciones_por_artista_en_playlist() {\n        let mut playlist = build_playlist();\n        let (cancion_1, cancion_2) = build_set_canciones();\n\n        playlist.agregar_cancion(cancion_1.clone()).unwrap();\n        playlist.agregar_cancion(cancion_2.clone()).unwrap();\n\n        let mut expected = Vec::\u003c\u0026Cancion\u003e::new();\n        expected.push(\u0026cancion_2);\n\n        assert_eq!(\n            playlist.obtener_canciones_por_artista(\"Lacuna Coil\".to_owned()),\n            expected,\n            \"No se obtuvieron las canciones de la playlist por artista como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn modificar_titulo_de_playlist() {\n        let mut playlist = build_playlist();\n        playlist.modificar_titulo(\"Metal only\".to_owned());\n\n        assert_eq!(\n            playlist.nombre,\n            \"Metal only\".to_owned(),\n            \"No se cambio el título de la playlist como se esperaba\"\n        );\n    }\n\n    #[test]\n    fn eliminar_canciones_de_playlist() {\n        let mut playlist = build_playlist();\n        let (cancion_1, cancion_2) = build_set_canciones();\n\n        playlist.agregar_cancion(cancion_1.clone()).unwrap();\n        playlist.agregar_cancion(cancion_2.clone()).unwrap();\n\n        playlist.limpiar_playlist();\n\n        assert_eq!(\n            playlist.canciones,\n            Vec::\u003cCancion\u003e::new(),\n            \"No se eliminaron todas las canciones de la playlist como se esperaba\"\n        );\n    }\n}\n","traces":[{"line":23,"address":[608384],"length":1,"stats":{"Line":1}},{"line":24,"address":[608389],"length":1,"stats":{"Line":1}},{"line":27,"address":[608662,608416],"length":1,"stats":{"Line":1}},{"line":28,"address":[608441,608505],"length":1,"stats":{"Line":4}},{"line":29,"address":[608613,608655],"length":1,"stats":{"Line":2}},{"line":33,"address":[609214,608688],"length":1,"stats":{"Line":1}},{"line":34,"address":[608798,608726,609191],"length":1,"stats":{"Line":5}},{"line":35,"address":[608953,608908],"length":1,"stats":{"Line":2}},{"line":36,"address":[609024,608961,609042],"length":1,"stats":{"Line":3}},{"line":37,"address":[609049,609173],"length":1,"stats":{"Line":2}},{"line":39,"address":[609034],"length":1,"stats":{"Line":1}},{"line":42,"address":[609066],"length":1,"stats":{"Line":1}},{"line":46,"address":[609394,609248],"length":1,"stats":{"Line":1}},{"line":47,"address":[609317,609262],"length":1,"stats":{"Line":4}},{"line":50,"address":[609424],"length":1,"stats":{"Line":1}},{"line":51,"address":[609462],"length":1,"stats":{"Line":1}},{"line":53,"address":[1059153,1059136],"length":1,"stats":{"Line":2}},{"line":57,"address":[609714,609536],"length":1,"stats":{"Line":1}},{"line":58,"address":[609573,609632],"length":1,"stats":{"Line":2}},{"line":60,"address":[1059184,1059201],"length":1,"stats":{"Line":2}},{"line":64,"address":[609801,609744],"length":1,"stats":{"Line":1}},{"line":65,"address":[609762,609836],"length":1,"stats":{"Line":2}},{"line":68,"address":[609872],"length":1,"stats":{"Line":1}},{"line":69,"address":[609877],"length":1,"stats":{"Line":1}}],"covered":24,"coverable":24},{"path":["/","home","netcreature","dev","unlp","sdl-rust","practica","src","tp5","mod.rs"],"content":"pub mod ej1;\npub mod ej2;\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>